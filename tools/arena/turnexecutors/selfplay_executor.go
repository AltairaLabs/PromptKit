package turnexecutors

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/AltairaLabs/PromptKit/runtime/pipeline"
	"github.com/AltairaLabs/PromptKit/runtime/pipeline/stage"
	"github.com/AltairaLabs/PromptKit/runtime/statestore"
	"github.com/AltairaLabs/PromptKit/runtime/types"
	"github.com/AltairaLabs/PromptKit/runtime/validators"
	"github.com/AltairaLabs/PromptKit/tools/arena/selfplay"
	arenastages "github.com/AltairaLabs/PromptKit/tools/arena/stages"
)

// SelfPlayExecutor executes turns where the user message is generated by an LLM
type SelfPlayExecutor struct {
	pipelineExecutor *PipelineExecutor
	contentProvider  selfplay.Provider
}

// NewSelfPlayExecutor creates a new executor for self-play turns
func NewSelfPlayExecutor(pipelineExecutor *PipelineExecutor, contentProvider selfplay.Provider) *SelfPlayExecutor {
	return &SelfPlayExecutor{
		pipelineExecutor: pipelineExecutor,
		contentProvider:  contentProvider,
	}
}

// ExecuteTurn executes a self-play turn (LLM-generated user message + AI response)
//
//nolint:gocritic // Public API - changing to pointer would break callers
func (e *SelfPlayExecutor) ExecuteTurn(ctx context.Context, req TurnRequest) error {
	// Load history from StateStore if configured
	history, err := e.loadHistory(ctx, &req)
	if err != nil {
		return err
	}

	// Generate user message using LLM
	userMessage, err := e.generateUserMessage(ctx, &req, history)
	if err != nil {
		return err
	}

	// Execute AI response through the pipeline
	return e.pipelineExecutor.Execute(ctx, &req, &userMessage)
}

// loadHistory loads conversation history from StateStore
func (e *SelfPlayExecutor) loadHistory(ctx context.Context, req *TurnRequest) ([]types.Message, error) {
	if req.StateStoreConfig == nil || req.ConversationID == "" {
		return nil, nil
	}

	store, ok := req.StateStoreConfig.Store.(statestore.Store)
	if !ok {
		return nil, nil
	}

	state, err := store.Load(ctx, req.ConversationID)
	if err != nil && !errors.Is(err, statestore.ErrNotFound) {
		return nil, fmt.Errorf("failed to load history from StateStore: %w", err)
	}

	if state != nil && len(state.Messages) > 0 {
		return state.Messages, nil
	}

	return nil, nil
}

// generateUserMessage generates a user message using the content provider
func (e *SelfPlayExecutor) generateUserMessage(
	ctx context.Context,
	req *TurnRequest,
	history []types.Message,
) (types.Message, error) {
	filteredHistory := filterOutToolMessages(history)

	contentGen, err := e.contentProvider.GetContentGenerator(req.SelfPlayRole, req.SelfPlayPersona)
	if err != nil {
		return types.Message{}, fmt.Errorf("failed to get content generator: %w", err)
	}

	execResult, err := contentGen.NextUserTurn(ctx, filteredHistory, req.Scenario.ID)
	if err != nil {
		return types.Message{}, fmt.Errorf("failed to generate user turn: %w", err)
	}

	if execResult.Response == nil || execResult.Response.Content == "" {
		return types.Message{}, fmt.Errorf("no response content generated")
	}

	return e.buildUserMessageFromResult(req, execResult), nil
}

// buildUserMessageFromResult constructs a user message from execution result
func (e *SelfPlayExecutor) buildUserMessageFromResult(
	req *TurnRequest,
	execResult *pipeline.ExecutionResult,
) types.Message {
	selfPlayMeta := e.buildSelfPlayMetadata(req, execResult)

	var latencyMs int64
	if execResult.Trace.CompletedAt != nil {
		latencyMs = execResult.Trace.CompletedAt.Sub(execResult.Trace.StartedAt).Milliseconds()
	}

	return types.Message{
		Role:      "user",
		Content:   execResult.Response.Content,
		CostInfo:  &execResult.CostInfo,
		LatencyMs: latencyMs,
		Meta: map[string]interface{}{
			"raw_response": selfPlayMeta,
		},
	}
}

// buildSelfPlayMetadata creates metadata for self-play execution
func (e *SelfPlayExecutor) buildSelfPlayMetadata(
	req *TurnRequest,
	execResult *pipeline.ExecutionResult,
) map[string]interface{} {
	meta := map[string]interface{}{
		"role":                req.SelfPlayRole,
		"self_play_execution": true,
		"trace":               execResult.Trace,
	}

	if execResult.Metadata != nil {
		for k, v := range execResult.Metadata {
			meta[k] = v
		}
	}

	return meta
}

// ExecuteTurnStream executes a self-play turn with streaming
//
//nolint:gocritic // Public API - changing to pointer would break callers
func (e *SelfPlayExecutor) ExecuteTurnStream(
	ctx context.Context,
	req TurnRequest,
) (<-chan MessageStreamChunk, error) {
	outChan := make(chan MessageStreamChunk)

	go func() {
		defer close(outChan)

		// Load history from StateStore if configured
		history, err := e.loadHistoryForStream(ctx, &req, outChan)
		if err != nil {
			return // Error already sent to channel
		}

		// Generate user message using LLM
		userMessage, err := e.generateUserMessageForStream(ctx, &req, history, outChan)
		if err != nil {
			return // Error already sent to channel
		}

		// Handle non-streaming providers
		if e.handleNonStreamingProvider(ctx, &req, &userMessage, outChan) {
			return
		}

		// Execute streaming pipeline
		e.executeStreamingPipeline(ctx, &req, &userMessage, outChan)
	}()

	return outChan, nil
}

// loadHistoryForStream loads conversation history from StateStore
func (e *SelfPlayExecutor) loadHistoryForStream(
	ctx context.Context,
	req *TurnRequest,
	outChan chan<- MessageStreamChunk,
) ([]types.Message, error) {
	if req.StateStoreConfig == nil || req.ConversationID == "" {
		return nil, nil
	}

	store, ok := req.StateStoreConfig.Store.(statestore.Store)
	if !ok {
		return nil, nil
	}

	state, err := store.Load(ctx, req.ConversationID)
	if err != nil && !errors.Is(err, statestore.ErrNotFound) {
		outChan <- MessageStreamChunk{
			Error: fmt.Errorf("failed to load history from StateStore: %w", err),
		}
		return nil, err
	}

	if state != nil && len(state.Messages) > 0 {
		return state.Messages, nil
	}

	return nil, nil
}

// generateUserMessageForStream generates the user message for self-play
func (e *SelfPlayExecutor) generateUserMessageForStream(
	ctx context.Context,
	req *TurnRequest,
	history []types.Message,
	outChan chan<- MessageStreamChunk,
) (types.Message, error) {
	// Tool role messages are not valid input for LLM chat APIs; drop them before generation.
	filteredHistory := filterOutToolMessages(history)

	contentGen, err := e.contentProvider.GetContentGenerator(req.SelfPlayRole, req.SelfPlayPersona)
	if err != nil {
		outChan <- MessageStreamChunk{Error: fmt.Errorf("failed to get content generator: %w", err)}
		return types.Message{}, err
	}

	execResult, err := contentGen.NextUserTurn(ctx, filteredHistory, req.Scenario.ID)
	if err != nil {
		outChan <- MessageStreamChunk{Error: fmt.Errorf("failed to generate user turn: %w", err)}
		return types.Message{}, err
	}

	if execResult.Response == nil || execResult.Response.Content == "" {
		err := fmt.Errorf("no response content generated")
		outChan <- MessageStreamChunk{Error: err}
		return types.Message{}, err
	}

	return e.buildUserMessage(req, execResult), nil
}

// buildUserMessage constructs a user message from execution result
func (e *SelfPlayExecutor) buildUserMessage(
	req *TurnRequest,
	execResult *pipeline.ExecutionResult,
) types.Message {
	userMessage := types.Message{
		Role:     "user",
		Content:  execResult.Response.Content,
		CostInfo: &execResult.CostInfo,
	}

	if execResult.Trace.CompletedAt != nil {
		userMessage.LatencyMs = execResult.Trace.CompletedAt.Sub(execResult.Trace.StartedAt).Milliseconds()
	}

	selfPlayMeta := map[string]interface{}{
		"role":                req.SelfPlayRole,
		"self_play_execution": true,
		"trace":               execResult.Trace,
	}

	if execResult.Metadata != nil {
		for k, v := range execResult.Metadata {
			selfPlayMeta[k] = v
		}
	}

	userMessage.Meta = map[string]interface{}{
		"raw_response": selfPlayMeta,
	}

	return userMessage
}

// filterOutToolMessages removes tool role messages from history to avoid invalid provider payloads.
func filterOutToolMessages(messages []types.Message) []types.Message {
	if len(messages) == 0 {
		return messages
	}
	filtered := make([]types.Message, 0, len(messages))
	for i := range messages {
		if strings.EqualFold(messages[i].Role, "tool") {
			continue
		}
		filtered = append(filtered, messages[i])
	}
	return filtered
}

// handleNonStreamingProvider handles providers that don't support streaming
// Returns true if handled (caller should return)
func (e *SelfPlayExecutor) handleNonStreamingProvider(
	ctx context.Context,
	req *TurnRequest,
	userMessage *types.Message,
	outChan chan<- MessageStreamChunk,
) bool {
	if req.Provider.SupportsStreaming() {
		return false
	}

	messages := []types.Message{*userMessage}
	err := e.pipelineExecutor.Execute(ctx, req, userMessage)
	if err != nil {
		outChan <- MessageStreamChunk{Messages: messages, Error: err}
		return true
	}

	finishReason := finishReasonStop
	outChan <- MessageStreamChunk{
		Messages:     []types.Message{},
		FinishReason: &finishReason,
	}
	return true
}

// executeStreamingPipeline builds and executes the streaming stage pipeline
func (e *SelfPlayExecutor) executeStreamingPipeline(
	ctx context.Context,
	req *TurnRequest,
	userMessage *types.Message,
	outChan chan<- MessageStreamChunk,
) {
	messages := []types.Message{*userMessage}

	// Build and execute stage pipeline
	pl, err := e.buildStreamingStages(req)
	if err != nil {
		outChan <- MessageStreamChunk{Messages: messages, Error: fmt.Errorf("failed to build streaming pipeline: %w", err)}
		return
	}

	// Create input element
	inputElem := stage.StreamElement{
		Message: userMessage,
		Metadata: map[string]interface{}{
			"run_id":          req.RunID,
			"conversation_id": req.ConversationID,
		},
	}

	// Create input channel
	inputChan := make(chan stage.StreamElement, 1)
	inputChan <- inputElem
	close(inputChan)

	// Execute pipeline (returns streaming output channel)
	outputChan, err := pl.Execute(ctx, inputChan)
	if err != nil {
		outChan <- MessageStreamChunk{Messages: messages, Error: err}
		return
	}

	// Convert stage stream to provider chunks
	e.forwardStageElements(outputChan, messages, outChan)
}

// buildStreamingStages constructs the stage pipeline for streaming
func (e *SelfPlayExecutor) buildStreamingStages(req *TurnRequest) (*stage.StreamPipeline, error) {
	baseVariables := buildBaseVariables(req.Region)
	mergedVars := map[string]string{}
	for k, v := range baseVariables {
		mergedVars[k] = v
	}
	for k, v := range req.PromptVars {
		mergedVars[k] = v
	}

	builder := stage.NewPipelineBuilder()
	var stages []stage.Stage

	// StateStore Load + TurnIndex stages
	if req.StateStoreConfig != nil && req.ConversationID != "" {
		storeConfig := &pipeline.StateStoreConfig{
			Store:          req.StateStoreConfig.Store,
			ConversationID: req.ConversationID,
			UserID:         req.StateStoreConfig.UserID,
			Metadata:       req.StateStoreConfig.Metadata,
		}
		stages = append(stages,
			stage.NewStateStoreLoadStage(storeConfig),
			arenastages.NewTurnIndexStage(),
		)
	}

	// Variable injection
	stages = append(stages, arenastages.NewVariableInjectionStage(mergedVars))
	if len(req.Metadata) > 0 {
		stages = append(stages, arenastages.NewMetadataInjectionStage(req.Metadata))
	}

	// Prompt, template, and strip tool messages
	stages = append(stages,
		stage.NewPromptAssemblyStage(req.PromptRegistry, req.TaskType, mergedVars),
		stage.NewTemplateStage(),
		arenastages.NewStripToolMessagesStage(),
	)

	// Mock scenario context for mock providers (pre-provider)
	if isMockProvider(req.Provider) {
		stages = append(stages, arenastages.NewMockScenarioContextStage(req.Scenario))
	}

	// Provider + Dynamic validator stages
	providerConfig := &stage.ProviderConfig{
		MaxTokens:   req.MaxTokens,
		Temperature: float32(req.Temperature),
		Seed:        req.Seed,
	}

	stages = append(stages,
		stage.NewProviderStage(req.Provider, e.pipelineExecutor.toolRegistry, buildToolPolicy(req.Scenario), providerConfig),
		stage.NewValidationStage(validators.DefaultRegistry, true),
	)

	// StateStore Save stage
	if req.StateStoreConfig != nil && req.ConversationID != "" {
		storeConfig := &pipeline.StateStoreConfig{
			Store:          req.StateStoreConfig.Store,
			ConversationID: req.ConversationID,
			UserID:         req.StateStoreConfig.UserID,
			Metadata:       req.StateStoreConfig.Metadata,
		}
		stages = append(stages, stage.NewStateStoreSaveStage(storeConfig))
	}

	return builder.Chain(stages...).Build()
}

// forwardStageElements forwards stage elements from pipeline to output channel
func (e *SelfPlayExecutor) forwardStageElements(
	outputChan <-chan stage.StreamElement,
	messages []types.Message,
	outChan chan<- MessageStreamChunk,
) {
	assistantIndex := 1
	var assistantMsg types.Message
	assistantMsg.Role = roleAssistant

	for elem := range outputChan {
		if elem.Error != nil {
			outChan <- MessageStreamChunk{Messages: messages, Error: elem.Error}
			return
		}

		if done := e.processAssistantElement(&elem, &messages, &assistantMsg, assistantIndex, outChan); done {
			break
		}
	}
}

// processAssistantElement processes an assistant message element.
// Returns true if streaming should stop.
func (e *SelfPlayExecutor) processAssistantElement(
	elem *stage.StreamElement,
	messages *[]types.Message,
	assistantMsg *types.Message,
	assistantIndex int,
	outChan chan<- MessageStreamChunk,
) bool {
	if elem.Message == nil || elem.Message.Role != roleAssistant {
		return false
	}

	*assistantMsg = *elem.Message
	*messages = e.updateMessagesList(*messages, assistantMsg, assistantIndex)

	finishReason := e.extractFinishReason(elem.Metadata)

	outChan <- MessageStreamChunk{
		Messages:     *messages,
		MessageIndex: assistantIndex,
		FinishReason: finishReason,
	}

	return finishReason != nil
}

// extractFinishReason extracts the finish reason from element metadata.
func (e *SelfPlayExecutor) extractFinishReason(metadata map[string]interface{}) *string {
	if metadata == nil {
		return nil
	}
	if fr, ok := metadata["finish_reason"].(string); ok {
		return &fr
	}
	return nil
}

// updateMessagesList updates the messages list with current assistant message
func (e *SelfPlayExecutor) updateMessagesList(
	messages []types.Message,
	assistantMsg *types.Message,
	assistantIndex int,
) []types.Message {
	if len(messages) == assistantIndex {
		return append(messages, *assistantMsg)
	}
	messages[assistantIndex] = *assistantMsg
	return messages
}
