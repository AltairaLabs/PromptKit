name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        type: string
      phase:
        description: 'Release phase'
        required: true
        type: choice
        options:
          - full
          - libs-only
          - tools-only
        default: full
      skip_tests:
        description: 'Skip running tests'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write

jobs:
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      with:
        fetch-depth: 0
    
    - name: Validate version format
      id: validate
      env:
        INPUT_VERSION: ${{ inputs.version }}
      run: |
        VERSION="$INPUT_VERSION"
        
        # Ensure version starts with 'v'
        if [[ ! $VERSION =~ ^v ]]; then
          VERSION="v$VERSION"
        fi
        
        # Validate semver format
        if [[ ! $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "::error::Version must be in format v1.0.0"
          exit 1
        fi
        
        # Check if version already exists
        if git tag -l | grep -q "^$VERSION$\|^runtime/$VERSION$"; then
          echo "::error::Version $VERSION already exists"
          exit 1
        fi
        
        # Get latest version and compare
        echo "Checking if $VERSION is newer than existing versions..."
        LATEST_TAG=$(git tag -l "runtime/v*" | sort -V | tail -n1)
        
        if [ -n "$LATEST_TAG" ]; then
          LATEST_VERSION="${LATEST_TAG#runtime/}"
          echo "Latest existing version: $LATEST_VERSION"
          echo "New version: $VERSION"
          
          # Extract version numbers for comparison
          LATEST_MAJOR=$(echo "$LATEST_VERSION" | cut -d. -f1 | sed 's/v//')
          LATEST_MINOR=$(echo "$LATEST_VERSION" | cut -d. -f2)
          LATEST_PATCH=$(echo "$LATEST_VERSION" | cut -d. -f3)
          
          NEW_MAJOR=$(echo "$VERSION" | cut -d. -f1 | sed 's/v//')
          NEW_MINOR=$(echo "$VERSION" | cut -d. -f2)
          NEW_PATCH=$(echo "$VERSION" | cut -d. -f3)
          
          # Compare versions
          if [ "$NEW_MAJOR" -lt "$LATEST_MAJOR" ]; then
            echo "::error::New version $VERSION is older than latest $LATEST_VERSION (major version is lower)"
            exit 1
          elif [ "$NEW_MAJOR" -eq "$LATEST_MAJOR" ] && [ "$NEW_MINOR" -lt "$LATEST_MINOR" ]; then
            echo "::error::New version $VERSION is older than latest $LATEST_VERSION (minor version is lower)"
            exit 1
          elif [ "$NEW_MAJOR" -eq "$LATEST_MAJOR" ] && [ "$NEW_MINOR" -eq "$LATEST_MINOR" ] && [ "$NEW_PATCH" -le "$LATEST_PATCH" ]; then
            echo "::error::New version $VERSION is not newer than latest $LATEST_VERSION (patch version is not higher)"
            exit 1
          fi
          
          echo "âœ“ Version $VERSION is newer than $LATEST_VERSION"
        else
          echo "âœ“ No existing versions found, this will be the first release"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "âœ“ Version $VERSION is valid and available"
    
    - name: Setup Go
      if: ${{ !inputs.skip_tests }}
      uses: actions/setup-go@3041bf56c941b39c61721a86cd11f3bb1338122a # v5.2.0
      with:
        go-version: '1.25.1'
        cache: false  # Disable cache since we use a workspace setup
    
    - name: Install dependencies
      if: ${{ !inputs.skip_tests }}
      run: make install
    
    - name: Generate schemas for tests
      if: ${{ !inputs.skip_tests }}
      run: make schemas-copy
    
    - name: Run tests
      if: ${{ !inputs.skip_tests }}
      run: |
        echo "Running full test suite..."
        make test
        make test-race
        echo "âœ“ All tests passed"

  tag-dependencies:
    name: Tag Libraries
    runs-on: ubuntu-latest
    needs: validate
    if: ${{ inputs.phase == 'full' || inputs.phase == 'libs-only' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      with:
        fetch-depth: 0
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Tag runtime
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        echo "Tagging runtime/$VERSION"
        if git rev-parse "runtime/$VERSION" >/dev/null 2>&1; then
          echo "âš  Tag runtime/$VERSION already exists, skipping"
        else
          git tag -a "runtime/$VERSION" -m "Release runtime $VERSION"
          git push origin "runtime/$VERSION"
          echo "âœ“ Tagged runtime/$VERSION"
        fi
    
    - name: Tag pkg
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        echo "Tagging pkg/$VERSION"
        if git rev-parse "pkg/$VERSION" >/dev/null 2>&1; then
          echo "âš  Tag pkg/$VERSION already exists, skipping"
        else
          git tag -a "pkg/$VERSION" -m "Release pkg $VERSION"
          git push origin "pkg/$VERSION"
          echo "âœ“ Tagged pkg/$VERSION"
        fi
    
    - name: Tag sdk
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        echo "Tagging sdk/$VERSION"
        if git rev-parse "sdk/$VERSION" >/dev/null 2>&1; then
          echo "âš  Tag sdk/$VERSION already exists, skipping"
        else
          git tag -a "sdk/$VERSION" -m "Release sdk $VERSION"
          git push origin "sdk/$VERSION"
          echo "âœ“ Tagged sdk/$VERSION"
        fi
    
    - name: Tag root version (for GoReleaser)
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        echo "Tagging $VERSION (root-level for GoReleaser/releases)"
        if git rev-parse "$VERSION" >/dev/null 2>&1; then
          echo "âš  Tag $VERSION already exists, skipping"
        else
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"
          echo "âœ“ Tagged $VERSION"
        fi
    
    - name: Verify on Go proxy
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        echo "Verifying tags are available on Go proxy..."
        
        # Function to check if a module version is available
        check_module() {
          local module=$1
          local version=$2
          echo "Checking $module..."
          for i in {1..10}; do
            if curl -f -s "https://proxy.golang.org/github.com/!altaira!labs/!prompt!kit/$module/@v/$version.info" >/dev/null 2>&1; then
              echo "âœ“ $module@$version is available"
              return 0
            fi
            echo "  Attempt $i/10: Not available yet, waiting 20s..."
            sleep 20
          done
          echo "âš  $module@$version still not available after 200s"
          return 1
        }
        
        # Check all three modules
        check_module "runtime" "$VERSION" &
        PID_RUNTIME=$!
        
        check_module "pkg" "$VERSION" &
        PID_PKG=$!
        
        check_module "sdk" "$VERSION" &
        PID_SDK=$!
        
        # Wait for all checks to complete
        wait $PID_RUNTIME
        RESULT_RUNTIME=$?
        
        wait $PID_PKG
        RESULT_PKG=$?
        
        wait $PID_SDK
        RESULT_SDK=$?
        
        # Report overall status
        if [ $RESULT_RUNTIME -eq 0 ] && [ $RESULT_PKG -eq 0 ] && [ $RESULT_SDK -eq 0 ]; then
          echo "âœ“ All modules are available on Go proxy"
        else
          echo "âš  Some modules may need more time to propagate"
          echo "  This is normal and they will be available shortly"
        fi

  update-tools:
    name: Update and Tag Tools
    runs-on: ubuntu-latest
    needs: [validate, tag-dependencies]
    if: ${{ always() && (inputs.phase == 'full' || inputs.phase == 'tools-only') && needs.validate.result == 'success' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      with:
        fetch-depth: 0
    
    - name: Setup Go
      uses: actions/setup-go@3041bf56c941b39c61721a86cd11f3bb1338122a # v5.2.0
      with:
        go-version: '1.25.1'
        cache: false  # Disable cache since we use a workspace setup
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Create release branch
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        BRANCH="release/tools/$VERSION"
        # Check if branch already exists remotely
        if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
          echo "âš  Branch $BRANCH already exists, checking it out"
          git fetch origin "$BRANCH"
          git checkout "$BRANCH"
        else
          git checkout -b "$BRANCH"
          echo "âœ“ Created branch $BRANCH"
        fi
    
    - name: Update arena dependencies
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        echo "Updating tools/arena to use $VERSION..."
        cd tools/arena
        
        # First, explicitly require the new versions (before dropping replace)
        echo "Setting required versions to $VERSION..."
        go mod edit -require="github.com/AltairaLabs/PromptKit/runtime@$VERSION"
        go mod edit -require="github.com/AltairaLabs/PromptKit/pkg@$VERSION"
        
        # Now remove local replace directives
        go mod edit -dropreplace=github.com/AltairaLabs/PromptKit/runtime
        go mod edit -dropreplace=github.com/AltairaLabs/PromptKit/pkg
        
        # Download the modules with retry logic
        echo "Downloading dependencies..."
        for i in {1..10}; do
          if go mod download 2>&1; then
            echo "âœ“ Downloaded dependencies"
            break
          fi
          if [ $i -eq 10 ]; then
            echo "::error::Failed to download dependencies after 10 attempts"
            exit 1
          fi
          echo "  Attempt $i/10 failed, waiting 30s..."
          sleep 30
        done
        
        go mod tidy
        
        echo "Building arena..."
        go build -v ./...
        
        cd ../..
        echo "âœ“ Updated arena to $VERSION"
    
    - name: Update packc dependencies
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        echo "Updating tools/packc to use $VERSION..."
        cd tools/packc
        
        # First, explicitly require the new versions (before dropping replace)
        echo "Setting required versions to $VERSION..."
        go mod edit -require="github.com/AltairaLabs/PromptKit/runtime@$VERSION"
        go mod edit -require="github.com/AltairaLabs/PromptKit/pkg@$VERSION"
        
        # Now remove local replace directives
        go mod edit -dropreplace=github.com/AltairaLabs/PromptKit/runtime
        go mod edit -dropreplace=github.com/AltairaLabs/PromptKit/pkg
        
        # Download the modules with retry logic
        echo "Downloading dependencies..."
        for i in {1..10}; do
          if go mod download 2>&1; then
            echo "âœ“ Downloaded dependencies"
            break
          fi
          if [ $i -eq 10 ]; then
            echo "::error::Failed to download dependencies after 10 attempts"
            exit 1
          fi
          echo "  Attempt $i/10 failed, waiting 30s..."
          sleep 30
        done
        
        go mod tidy
        
        echo "Building packc..."
        go build -v ./...
        
        cd ../..
        echo "âœ“ Updated packc to $VERSION"
    
    - name: Commit changes
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        BRANCH="release/tools/$VERSION"
        
        # Check if there are changes to commit
        if git diff --quiet tools/arena/go.mod tools/arena/go.sum tools/packc/go.mod tools/packc/go.sum; then
          echo "âš  No changes to commit (already up to date)"
        else
          git add tools/arena/go.mod tools/arena/go.sum
          git add tools/packc/go.mod tools/packc/go.sum
          git commit -m "release: update tools to $VERSION"
          git push origin "$BRANCH"
          echo "âœ“ Pushed $BRANCH"
        fi
    
    - name: Tag arena
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        if git rev-parse "tools/arena/$VERSION" >/dev/null 2>&1; then
          echo "âš  Tag tools/arena/$VERSION already exists, skipping"
        else
          git tag -a "tools/arena/$VERSION" -m "Release arena $VERSION"
          git push origin "tools/arena/$VERSION"
          echo "âœ“ Tagged tools/arena/$VERSION"
        fi
    
    - name: Tag packc
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      run: |
        if git rev-parse "tools/packc/$VERSION" >/dev/null 2>&1; then
          echo "âš  Tag tools/packc/$VERSION already exists, skipping"
          else
          git tag -a "tools/packc/$VERSION" -m "Release packc $VERSION"
          git push origin "tools/packc/$VERSION"
          echo "âœ“ Tagged tools/packc/$VERSION"
        fi
    
    - name: Verify installation
      env:
        VERSION: ${{ needs.validate.outputs.version }}
      continue-on-error: true
      run: |
        echo "Testing arena installation..."
        echo "Note: This may fail if modules haven't fully propagated to the Go proxy yet."
        echo "Installation will still work once propagation completes (usually within a few minutes)."
        echo ""
        
        if go install "github.com/AltairaLabs/PromptKit/tools/arena/cmd/promptarena@$VERSION" 2>&1; then
          echo "âœ“ Arena installation successful"
        else
          echo "âš  Arena installation needs more time to propagate"
        fi
        
        echo ""
        echo "Testing packc installation..."
        if go install "github.com/AltairaLabs/PromptKit/tools/packc@$VERSION" 2>&1; then
          echo "âœ“ Packc installation successful"
        else
          echo "âš  Packc installation needs more time to propagate"
        fi

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate, tag-dependencies]
    if: ${{ inputs.phase == 'full' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      with:
        fetch-depth: 0
    
    - name: Setup Go
      uses: actions/setup-go@3041bf56c941b39c61721a86cd11f3bb1338122a # v5.2.0
      with:
        go-version: '1.25.1'
        cache: false  # Disable cache since we use a workspace setup
    
    - name: Run GoReleaser
      uses: goreleaser/goreleaser-action@9ed2f89a662bf1735a48bc8557fd212fa902bebf # v6.1.0
      with:
        distribution: goreleaser
        version: latest
        args: release --clean
      env:
        GITHUB_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
    
    - name: Upload artifacts summary
      run: |
        echo "## ðŸ“¦ Release Artifacts Created" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "GoReleaser has created:" >> $GITHUB_STEP_SUMMARY
        echo "- Multi-platform binaries (Linux, macOS, Windows)" >> $GITHUB_STEP_SUMMARY
        echo "- Archives (tar.gz, zip)" >> $GITHUB_STEP_SUMMARY
        echo "- Checksums for verification" >> $GITHUB_STEP_SUMMARY
        echo "- Automated changelog" >> $GITHUB_STEP_SUMMARY
        echo "- Draft GitHub release" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Review at:** https://github.com/${{ github.repository }}/releases" >> $GITHUB_STEP_SUMMARY

  summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs: [validate, tag-dependencies, update-tools, create-release]
    if: always()
    
    steps:
    - name: Generate summary
      env:
        VERSION: ${{ needs.validate.outputs.version }}
        VALIDATION_RESULT: ${{ needs.validate.result }}
        DEPENDENCIES_RESULT: ${{ needs.tag-dependencies.result }}
        TOOLS_RESULT: ${{ needs.update-tools.result }}
        RELEASE_RESULT: ${{ needs.create-release.result }}
        GITHUB_REPO: ${{ github.repository }}
      run: |
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # Release $VERSION Summary
        
        ## Status
        
        - Validation: $VALIDATION_RESULT
        - Dependencies: $DEPENDENCIES_RESULT
        - Tools: $TOOLS_RESULT
        - GitHub Release: $RELEASE_RESULT
        
        ## Installation
        
        **SDK Library:**
        \`\`\`bash
        go get github.com/AltairaLabs/PromptKit/sdk@$VERSION
        \`\`\`
        
        **CLI Tools:**
        \`\`\`bash
        go install github.com/AltairaLabs/PromptKit/tools/arena/cmd/promptarena@$VERSION
        go install github.com/AltairaLabs/PromptKit/tools/packc@$VERSION
        \`\`\`
        
        ## Next Steps
        
        1. Review and publish the [draft release](https://github.com/$GITHUB_REPO/releases)
        2. Update README.md with new version
        3. Announce the release
        4. Restore replace directives on main branch (if needed)
        
        ## Verification
        
        Test the release:
        \`\`\`bash
        promptarena --version
        packc --version
        \`\`\`
        EOF
