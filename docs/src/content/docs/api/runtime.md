---
title: Runtime API Reference
description: Complete API reference for the PromptKit Runtime
sidebar:
  order: 2
---
<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# audio

```go
import "github.com/AltairaLabs/PromptKit/runtime/audio"
```

Package audio provides voice activity detection \(VAD\), turn detection, and audio session management for real\-time voice AI applications.

The package follows industry\-standard patterns for voice AI:

- VAD \(Voice Activity Detection\): Detects when someone is speaking vs. silent
- Turn Detection: Determines when a speaker has finished their turn
- Interruption Handling: Manages user interrupting bot output

### Architecture

Audio processing follows a two\-stage approach:

1. VADAnalyzer detects voice activity in real\-time
2. TurnDetector uses VAD output plus additional signals to detect turn boundaries

### Usage Example

```
vad := audio.NewSimpleVAD(audio.DefaultVADParams())
detector := audio.NewSilenceDetector(500 * time.Millisecond)

for chunk := range audioStream {
    vad.Analyze(ctx, chunk)
    if detector.DetectTurnEnd(ctx, vad) {
        // User finished speaking
    }
}
```

Package audio provides audio processing utilities.

## Index

- [Constants](<#constants>)
- [func Resample24kTo16k\(input \[\]byte\) \(\[\]byte, error\)](<#Resample24kTo16k>)
- [func ResamplePCM16\(input \[\]byte, fromRate, toRate int\) \(\[\]byte, error\)](<#ResamplePCM16>)
- [type AccumulatingTurnDetector](<#AccumulatingTurnDetector>)
- [type InterruptionCallback](<#InterruptionCallback>)
- [type InterruptionHandler](<#InterruptionHandler>)
  - [func NewInterruptionHandler\(strategy InterruptionStrategy, vad VADAnalyzer\) \*InterruptionHandler](<#NewInterruptionHandler>)
  - [func \(h \*InterruptionHandler\) IsBotSpeaking\(\) bool](<#InterruptionHandler.IsBotSpeaking>)
  - [func \(h \*InterruptionHandler\) NotifySentenceBoundary\(\)](<#InterruptionHandler.NotifySentenceBoundary>)
  - [func \(h \*InterruptionHandler\) OnInterrupt\(callback InterruptionCallback\)](<#InterruptionHandler.OnInterrupt>)
  - [func \(h \*InterruptionHandler\) ProcessAudio\(ctx context.Context, audio \[\]byte\) \(bool, error\)](<#InterruptionHandler.ProcessAudio>)
  - [func \(h \*InterruptionHandler\) ProcessVADState\(ctx context.Context, state VADState\) \(bool, error\)](<#InterruptionHandler.ProcessVADState>)
  - [func \(h \*InterruptionHandler\) Reset\(\)](<#InterruptionHandler.Reset>)
  - [func \(h \*InterruptionHandler\) SetBotSpeaking\(speaking bool\)](<#InterruptionHandler.SetBotSpeaking>)
  - [func \(h \*InterruptionHandler\) WasInterrupted\(\) bool](<#InterruptionHandler.WasInterrupted>)
- [type InterruptionStrategy](<#InterruptionStrategy>)
  - [func \(s InterruptionStrategy\) String\(\) string](<#InterruptionStrategy.String>)
- [type SilenceDetector](<#SilenceDetector>)
  - [func NewSilenceDetector\(threshold time.Duration\) \*SilenceDetector](<#NewSilenceDetector>)
  - [func \(d \*SilenceDetector\) GetAccumulatedAudio\(\) \[\]byte](<#SilenceDetector.GetAccumulatedAudio>)
  - [func \(d \*SilenceDetector\) IsUserSpeaking\(\) bool](<#SilenceDetector.IsUserSpeaking>)
  - [func \(d \*SilenceDetector\) Name\(\) string](<#SilenceDetector.Name>)
  - [func \(d \*SilenceDetector\) OnTurnComplete\(callback TurnCallback\)](<#SilenceDetector.OnTurnComplete>)
  - [func \(d \*SilenceDetector\) ProcessAudio\(ctx context.Context, audio \[\]byte\) \(bool, error\)](<#SilenceDetector.ProcessAudio>)
  - [func \(d \*SilenceDetector\) ProcessVADState\(ctx context.Context, state VADState\) \(bool, error\)](<#SilenceDetector.ProcessVADState>)
  - [func \(d \*SilenceDetector\) Reset\(\)](<#SilenceDetector.Reset>)
  - [func \(d \*SilenceDetector\) SetTranscript\(transcript string\)](<#SilenceDetector.SetTranscript>)
- [type SimpleVAD](<#SimpleVAD>)
  - [func NewSimpleVAD\(params VADParams\) \(\*SimpleVAD, error\)](<#NewSimpleVAD>)
  - [func \(v \*SimpleVAD\) Analyze\(ctx context.Context, audio \[\]byte\) \(float64, error\)](<#SimpleVAD.Analyze>)
  - [func \(v \*SimpleVAD\) Name\(\) string](<#SimpleVAD.Name>)
  - [func \(v \*SimpleVAD\) OnStateChange\(\) \<\-chan VADEvent](<#SimpleVAD.OnStateChange>)
  - [func \(v \*SimpleVAD\) Reset\(\)](<#SimpleVAD.Reset>)
  - [func \(v \*SimpleVAD\) State\(\) VADState](<#SimpleVAD.State>)
- [type TurnCallback](<#TurnCallback>)
- [type TurnDetector](<#TurnDetector>)
- [type VADAnalyzer](<#VADAnalyzer>)
- [type VADEvent](<#VADEvent>)
- [type VADParams](<#VADParams>)
  - [func DefaultVADParams\(\) VADParams](<#DefaultVADParams>)
  - [func \(p VADParams\) Validate\(\) error](<#VADParams.Validate>)
- [type VADState](<#VADState>)
  - [func \(s VADState\) String\(\) string](<#VADState.String>)
- [type ValidationError](<#ValidationError>)
  - [func \(e \*ValidationError\) Error\(\) string](<#ValidationError.Error>)


## Constants

<a name="SampleRate24kHz"></a>Standard audio sample rates for common use cases.

```go
const (
    SampleRate24kHz = 24000 // Common TTS output rate
    SampleRate16kHz = 16000 // Common STT/ASR input rate
)
```

<a name="DefaultVADConfidence"></a>Default VAD parameter values.

```go
const (
    DefaultVADConfidence = 0.5
    DefaultVADStartSecs  = 0.2
    DefaultVADStopSecs   = 0.8
    DefaultVADMinVolume  = 0.01
    DefaultVADSampleRate = 16000
)
```

<a name="Resample24kTo16k"></a>
## func Resample24kTo16k

```go
func Resample24kTo16k(input []byte) ([]byte, error)
```

Resample24kTo16k is a convenience function for the common case of resampling from 24kHz \(TTS output\) to 16kHz \(Gemini input\).

<a name="ResamplePCM16"></a>
## func ResamplePCM16

```go
func ResamplePCM16(input []byte, fromRate, toRate int) ([]byte, error)
```

ResamplePCM16 resamples PCM16 audio data from one sample rate to another. Uses linear interpolation for reasonable quality resampling. Input and output are little\-endian 16\-bit signed PCM samples.

<a name="AccumulatingTurnDetector"></a>
## type AccumulatingTurnDetector

AccumulatingTurnDetector is a TurnDetector that accumulates audio during a turn.

```go
type AccumulatingTurnDetector interface {
    TurnDetector

    // OnTurnComplete registers a callback for when a complete turn is detected.
    OnTurnComplete(callback TurnCallback)

    // GetAccumulatedAudio returns audio accumulated so far (may be incomplete turn).
    GetAccumulatedAudio() []byte

    // SetTranscript sets the transcript for the current turn (from external STT).
    SetTranscript(transcript string)
}
```

<a name="InterruptionCallback"></a>
## type InterruptionCallback

InterruptionCallback is called when user interrupts the bot.

```go
type InterruptionCallback func()
```

<a name="InterruptionHandler"></a>
## type InterruptionHandler

InterruptionHandler manages user interruption logic during bot output.

```go
type InterruptionHandler struct {
    // contains filtered or unexported fields
}
```

<a name="NewInterruptionHandler"></a>
### func NewInterruptionHandler

```go
func NewInterruptionHandler(strategy InterruptionStrategy, vad VADAnalyzer) *InterruptionHandler
```

NewInterruptionHandler creates an InterruptionHandler with the given strategy and VAD.

<a name="InterruptionHandler.IsBotSpeaking"></a>
### func \(\*InterruptionHandler\) IsBotSpeaking

```go
func (h *InterruptionHandler) IsBotSpeaking() bool
```

IsBotSpeaking returns true if the bot is currently outputting audio.

<a name="InterruptionHandler.NotifySentenceBoundary"></a>
### func \(\*InterruptionHandler\) NotifySentenceBoundary

```go
func (h *InterruptionHandler) NotifySentenceBoundary()
```

NotifySentenceBoundary notifies the handler of a sentence boundary. For deferred interruption strategy, this may trigger the pending interruption.

<a name="InterruptionHandler.OnInterrupt"></a>
### func \(\*InterruptionHandler\) OnInterrupt

```go
func (h *InterruptionHandler) OnInterrupt(callback InterruptionCallback)
```

OnInterrupt registers a callback for when interruption occurs.

<a name="InterruptionHandler.ProcessAudio"></a>
### func \(\*InterruptionHandler\) ProcessAudio

```go
func (h *InterruptionHandler) ProcessAudio(ctx context.Context, audio []byte) (bool, error)
```

ProcessAudio processes audio and detects user interruption. Returns true if an interruption was detected and should be acted upon.

<a name="InterruptionHandler.ProcessVADState"></a>
### func \(\*InterruptionHandler\) ProcessVADState

```go
func (h *InterruptionHandler) ProcessVADState(ctx context.Context, state VADState) (bool, error)
```

ProcessVADState processes a VAD state update for interruption detection. Returns true if an interruption was detected and should be acted upon.

<a name="InterruptionHandler.Reset"></a>
### func \(\*InterruptionHandler\) Reset

```go
func (h *InterruptionHandler) Reset()
```

Reset clears interruption state for a new turn.

<a name="InterruptionHandler.SetBotSpeaking"></a>
### func \(\*InterruptionHandler\) SetBotSpeaking

```go
func (h *InterruptionHandler) SetBotSpeaking(speaking bool)
```

SetBotSpeaking sets whether the bot is currently outputting audio.

<a name="InterruptionHandler.WasInterrupted"></a>
### func \(\*InterruptionHandler\) WasInterrupted

```go
func (h *InterruptionHandler) WasInterrupted() bool
```

WasInterrupted returns true if an interruption occurred.

<a name="InterruptionStrategy"></a>
## type InterruptionStrategy

InterruptionStrategy determines how to handle user interrupting bot.

```go
type InterruptionStrategy int
```

<a name="InterruptionIgnore"></a>

```go
const (
    // InterruptionIgnore ignores user speech during bot output.
    InterruptionIgnore InterruptionStrategy = iota
    // InterruptionImmediate immediately stops bot and starts listening.
    InterruptionImmediate
    // InterruptionDeferred waits for bot's current sentence, then switches.
    InterruptionDeferred
)
```

<a name="InterruptionStrategy.String"></a>
### func \(InterruptionStrategy\) String

```go
func (s InterruptionStrategy) String() string
```

String returns a human\-readable representation of the interruption strategy.

<a name="SilenceDetector"></a>
## type SilenceDetector

SilenceDetector detects turn boundaries based on silence duration. It triggers end\-of\-turn when silence exceeds a configurable threshold.

```go
type SilenceDetector struct {
    // Threshold is the silence duration required to trigger turn end.
    Threshold time.Duration
    // contains filtered or unexported fields
}
```

<a name="NewSilenceDetector"></a>
### func NewSilenceDetector

```go
func NewSilenceDetector(threshold time.Duration) *SilenceDetector
```

NewSilenceDetector creates a SilenceDetector with the given threshold. threshold is the duration of silence required to trigger end\-of\-turn.

<a name="SilenceDetector.GetAccumulatedAudio"></a>
### func \(\*SilenceDetector\) GetAccumulatedAudio

```go
func (d *SilenceDetector) GetAccumulatedAudio() []byte
```

GetAccumulatedAudio returns audio accumulated so far.

<a name="SilenceDetector.IsUserSpeaking"></a>
### func \(\*SilenceDetector\) IsUserSpeaking

```go
func (d *SilenceDetector) IsUserSpeaking() bool
```

IsUserSpeaking returns true if user is currently speaking.

<a name="SilenceDetector.Name"></a>
### func \(\*SilenceDetector\) Name

```go
func (d *SilenceDetector) Name() string
```

Name returns the detector identifier.

<a name="SilenceDetector.OnTurnComplete"></a>
### func \(\*SilenceDetector\) OnTurnComplete

```go
func (d *SilenceDetector) OnTurnComplete(callback TurnCallback)
```

OnTurnComplete registers a callback for when a complete turn is detected.

<a name="SilenceDetector.ProcessAudio"></a>
### func \(\*SilenceDetector\) ProcessAudio

```go
func (d *SilenceDetector) ProcessAudio(ctx context.Context, audio []byte) (bool, error)
```

ProcessAudio processes an incoming audio chunk. This implementation delegates to ProcessVADState and expects VAD to be run separately. Returns true if end of turn is detected.

<a name="SilenceDetector.ProcessVADState"></a>
### func \(\*SilenceDetector\) ProcessVADState

```go
func (d *SilenceDetector) ProcessVADState(ctx context.Context, state VADState) (bool, error)
```

ProcessVADState processes a VAD state update and detects turn boundaries. Returns true if end of turn is detected.

<a name="SilenceDetector.Reset"></a>
### func \(\*SilenceDetector\) Reset

```go
func (d *SilenceDetector) Reset()
```

Reset clears state for a new conversation.

<a name="SilenceDetector.SetTranscript"></a>
### func \(\*SilenceDetector\) SetTranscript

```go
func (d *SilenceDetector) SetTranscript(transcript string)
```

SetTranscript sets the transcript for the current turn.

<a name="SimpleVAD"></a>
## type SimpleVAD

SimpleVAD is a basic voice activity detector using RMS \(Root Mean Square\) analysis. It provides a lightweight VAD implementation without requiring external ML models. For more accurate detection, consider using SileroVAD.

```go
type SimpleVAD struct {
    // contains filtered or unexported fields
}
```

<a name="NewSimpleVAD"></a>
### func NewSimpleVAD

```go
func NewSimpleVAD(params VADParams) (*SimpleVAD, error)
```

NewSimpleVAD creates a SimpleVAD analyzer with the given parameters.

<a name="SimpleVAD.Analyze"></a>
### func \(\*SimpleVAD\) Analyze

```go
func (v *SimpleVAD) Analyze(ctx context.Context, audio []byte) (float64, error)
```

Analyze processes audio and returns voice probability based on RMS volume.

<a name="SimpleVAD.Name"></a>
### func \(\*SimpleVAD\) Name

```go
func (v *SimpleVAD) Name() string
```

Name returns the analyzer identifier.

<a name="SimpleVAD.OnStateChange"></a>
### func \(\*SimpleVAD\) OnStateChange

```go
func (v *SimpleVAD) OnStateChange() <-chan VADEvent
```

OnStateChange returns a channel that receives state transitions.

<a name="SimpleVAD.Reset"></a>
### func \(\*SimpleVAD\) Reset

```go
func (v *SimpleVAD) Reset()
```

Reset clears accumulated state for a new conversation.

<a name="SimpleVAD.State"></a>
### func \(\*SimpleVAD\) State

```go
func (v *SimpleVAD) State() VADState
```

State returns the current VAD state.

<a name="TurnCallback"></a>
## type TurnCallback

TurnCallback is called when a complete user turn is detected. audio contains the accumulated audio for the turn. transcript contains any accumulated transcript \(may be empty\).

```go
type TurnCallback func(audio []byte, transcript string)
```

<a name="TurnDetector"></a>
## type TurnDetector

TurnDetector determines when a speaker has finished their turn. This is separate from VAD \- VAD detects voice activity, turn detection determines conversation boundaries.

```go
type TurnDetector interface {
    // Name returns the detector identifier.
    Name() string

    // ProcessAudio processes an incoming audio chunk.
    // Returns true if end of turn is detected.
    ProcessAudio(ctx context.Context, audio []byte) (bool, error)

    // ProcessVADState processes a VAD state update.
    // Returns true if end of turn is detected based on VAD state.
    ProcessVADState(ctx context.Context, state VADState) (bool, error)

    // IsUserSpeaking returns true if user is currently speaking.
    IsUserSpeaking() bool

    // Reset clears state for a new conversation.
    Reset()
}
```

<a name="VADAnalyzer"></a>
## type VADAnalyzer

VADAnalyzer analyzes audio for voice activity.

```go
type VADAnalyzer interface {
    // Name returns the analyzer identifier.
    Name() string

    // Analyze processes audio and returns voice probability (0.0-1.0).
    // audio should be raw PCM samples at the configured sample rate.
    Analyze(ctx context.Context, audio []byte) (float64, error)

    // State returns the current VAD state based on accumulated analysis.
    State() VADState

    // OnStateChange returns a channel that receives state transitions.
    // The channel is buffered and may drop events if not consumed.
    OnStateChange() <-chan VADEvent

    // Reset clears accumulated state for a new conversation.
    Reset()
}
```

<a name="VADEvent"></a>
## type VADEvent

VADEvent represents a state transition in VAD.

```go
type VADEvent struct {
    State      VADState
    PrevState  VADState
    Timestamp  time.Time
    Duration   time.Duration // How long in the previous state
    Confidence float64       // Voice confidence at transition
}
```

<a name="VADParams"></a>
## type VADParams

VADParams configures voice activity detection behavior.

```go
type VADParams struct {
    // Confidence threshold for voice detection (0.0-1.0, default: 0.5).
    // Higher values require more confidence before triggering.
    Confidence float64

    // StartSecs is seconds of speech required to trigger VADStateSpeaking (default: 0.2).
    // Prevents false starts from brief noise.
    StartSecs float64

    // StopSecs is seconds of silence required to trigger VADStateQuiet (default: 0.8).
    // Allows natural pauses without ending turn.
    StopSecs float64

    // MinVolume is the minimum RMS volume threshold (default: 0.01).
    // Audio below this is treated as silence.
    MinVolume float64

    // SampleRate is the audio sample rate in Hz (default: 16000).
    SampleRate int
}
```

<a name="DefaultVADParams"></a>
### func DefaultVADParams

```go
func DefaultVADParams() VADParams
```

DefaultVADParams returns sensible defaults for voice activity detection.

<a name="VADParams.Validate"></a>
### func \(VADParams\) Validate

```go
func (p VADParams) Validate() error
```

Validate checks that VAD parameters are within acceptable ranges.

<a name="VADState"></a>
## type VADState

VADState represents the current voice activity state.

```go
type VADState int
```

<a name="VADStateQuiet"></a>

```go
const (
    // VADStateQuiet indicates no voice activity detected.
    VADStateQuiet VADState = iota
    // VADStateStarting indicates voice is starting (within start threshold).
    VADStateStarting
    // VADStateSpeaking indicates active speech.
    VADStateSpeaking
    // VADStateStopping indicates voice is stopping (within stop threshold).
    VADStateStopping
)
```

<a name="VADState.String"></a>
### func \(VADState\) String

```go
func (s VADState) String() string
```

String returns a human\-readable representation of the VAD state.

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a parameter validation error.

```go
type ValidationError struct {
    Field   string
    Message string
}
```

<a name="ValidationError.Error"></a>
### func \(\*ValidationError\) Error

```go
func (e *ValidationError) Error() string
```



# events

```go
import "github.com/AltairaLabs/PromptKit/runtime/events"
```

Package events provides a lightweight pub/sub event bus for runtime observability.

## Index

- [type ContextBuiltData](<#ContextBuiltData>)
- [type ConversationStartedData](<#ConversationStartedData>)
- [type CustomEventData](<#CustomEventData>)
- [type Emitter](<#Emitter>)
  - [func NewEmitter\(bus \*EventBus, runID, sessionID, conversationID string\) \*Emitter](<#NewEmitter>)
  - [func \(e \*Emitter\) ContextBuilt\(messageCount, tokenCount, tokenBudget int, truncated bool\)](<#Emitter.ContextBuilt>)
  - [func \(e \*Emitter\) ConversationStarted\(systemPrompt string\)](<#Emitter.ConversationStarted>)
  - [func \(e \*Emitter\) EmitCustom\(eventType EventType, middlewareName, eventName string, data map\[string\]interface\{\}, message string\)](<#Emitter.EmitCustom>)
  - [func \(e \*Emitter\) MessageCreated\(role, content string, index int, toolCalls \[\]MessageToolCall, toolResult \*MessageToolResult\)](<#Emitter.MessageCreated>)
  - [func \(e \*Emitter\) MessageUpdated\(index int, latencyMs int64, inputTokens, outputTokens int, totalCost float64\)](<#Emitter.MessageUpdated>)
  - [func \(e \*Emitter\) MiddlewareCompleted\(name string, index int, duration time.Duration\)](<#Emitter.MiddlewareCompleted>)
  - [func \(e \*Emitter\) MiddlewareFailed\(name string, index int, err error, duration time.Duration\)](<#Emitter.MiddlewareFailed>)
  - [func \(e \*Emitter\) MiddlewareStarted\(name string, index int\)](<#Emitter.MiddlewareStarted>)
  - [func \(e \*Emitter\) PipelineCompleted\(duration time.Duration, totalCost float64, inputTokens, outputTokens, messageCount int\)](<#Emitter.PipelineCompleted>)
  - [func \(e \*Emitter\) PipelineFailed\(err error, duration time.Duration\)](<#Emitter.PipelineFailed>)
  - [func \(e \*Emitter\) PipelineStarted\(middlewareCount int\)](<#Emitter.PipelineStarted>)
  - [func \(e \*Emitter\) ProviderCallCompleted\(data \*ProviderCallCompletedData\)](<#Emitter.ProviderCallCompleted>)
  - [func \(e \*Emitter\) ProviderCallFailed\(provider, model string, err error, duration time.Duration\)](<#Emitter.ProviderCallFailed>)
  - [func \(e \*Emitter\) ProviderCallStarted\(provider, model string, messageCount, toolCount int\)](<#Emitter.ProviderCallStarted>)
  - [func \(e \*Emitter\) StageCompleted\(name string, index int, duration time.Duration\)](<#Emitter.StageCompleted>)
  - [func \(e \*Emitter\) StageFailed\(name string, index int, err error, duration time.Duration\)](<#Emitter.StageFailed>)
  - [func \(e \*Emitter\) StageStarted\(name string, index int, stageType interface\{\}\)](<#Emitter.StageStarted>)
  - [func \(e \*Emitter\) StateLoaded\(conversationID string, messageCount int\)](<#Emitter.StateLoaded>)
  - [func \(e \*Emitter\) StateSaved\(conversationID string, messageCount int\)](<#Emitter.StateSaved>)
  - [func \(e \*Emitter\) StreamInterrupted\(reason string\)](<#Emitter.StreamInterrupted>)
  - [func \(e \*Emitter\) TokenBudgetExceeded\(required, budget, excess int\)](<#Emitter.TokenBudgetExceeded>)
  - [func \(e \*Emitter\) ToolCallCompleted\(toolName, callID string, duration time.Duration, status string\)](<#Emitter.ToolCallCompleted>)
  - [func \(e \*Emitter\) ToolCallFailed\(toolName, callID string, err error, duration time.Duration\)](<#Emitter.ToolCallFailed>)
  - [func \(e \*Emitter\) ToolCallStarted\(toolName, callID string, args map\[string\]interface\{\}\)](<#Emitter.ToolCallStarted>)
  - [func \(e \*Emitter\) ValidationFailed\(validatorName, validatorType string, err error, duration time.Duration, violations \[\]string\)](<#Emitter.ValidationFailed>)
  - [func \(e \*Emitter\) ValidationPassed\(validatorName, validatorType string, duration time.Duration\)](<#Emitter.ValidationPassed>)
  - [func \(e \*Emitter\) ValidationStarted\(validatorName, validatorType string\)](<#Emitter.ValidationStarted>)
- [type Event](<#Event>)
- [type EventBus](<#EventBus>)
  - [func NewEventBus\(\) \*EventBus](<#NewEventBus>)
  - [func \(eb \*EventBus\) Clear\(\)](<#EventBus.Clear>)
  - [func \(eb \*EventBus\) Publish\(event \*Event\)](<#EventBus.Publish>)
  - [func \(eb \*EventBus\) Subscribe\(eventType EventType, listener Listener\)](<#EventBus.Subscribe>)
  - [func \(eb \*EventBus\) SubscribeAll\(listener Listener\)](<#EventBus.SubscribeAll>)
- [type EventData](<#EventData>)
- [type EventType](<#EventType>)
- [type Listener](<#Listener>)
- [type MessageCreatedData](<#MessageCreatedData>)
- [type MessageToolCall](<#MessageToolCall>)
- [type MessageToolResult](<#MessageToolResult>)
- [type MessageUpdatedData](<#MessageUpdatedData>)
- [type MiddlewareCompletedData](<#MiddlewareCompletedData>)
- [type MiddlewareFailedData](<#MiddlewareFailedData>)
- [type MiddlewareStartedData](<#MiddlewareStartedData>)
- [type PipelineCompletedData](<#PipelineCompletedData>)
- [type PipelineFailedData](<#PipelineFailedData>)
- [type PipelineStartedData](<#PipelineStartedData>)
- [type ProviderCallCompletedData](<#ProviderCallCompletedData>)
- [type ProviderCallFailedData](<#ProviderCallFailedData>)
- [type ProviderCallStartedData](<#ProviderCallStartedData>)
- [type StageCompletedData](<#StageCompletedData>)
- [type StageFailedData](<#StageFailedData>)
- [type StageStartedData](<#StageStartedData>)
- [type StateLoadedData](<#StateLoadedData>)
- [type StateSavedData](<#StateSavedData>)
- [type StreamInterruptedData](<#StreamInterruptedData>)
- [type TokenBudgetExceededData](<#TokenBudgetExceededData>)
- [type ToolCallCompletedData](<#ToolCallCompletedData>)
- [type ToolCallFailedData](<#ToolCallFailedData>)
- [type ToolCallStartedData](<#ToolCallStartedData>)
- [type ValidationFailedData](<#ValidationFailedData>)
- [type ValidationPassedData](<#ValidationPassedData>)
- [type ValidationStartedData](<#ValidationStartedData>)


<a name="ContextBuiltData"></a>
## type ContextBuiltData

ContextBuiltData contains data for context building events.

```go
type ContextBuiltData struct {
    MessageCount int
    TokenCount   int
    TokenBudget  int
    Truncated    bool
    // contains filtered or unexported fields
}
```

<a name="ConversationStartedData"></a>
## type ConversationStartedData

ConversationStartedData contains data for conversation start events.

```go
type ConversationStartedData struct {
    SystemPrompt string // The assembled system prompt for this conversation
    // contains filtered or unexported fields
}
```

<a name="CustomEventData"></a>
## type CustomEventData

CustomEventData allows middleware to emit arbitrary structured events.

```go
type CustomEventData struct {
    MiddlewareName string
    EventName      string
    Data           map[string]interface{}
    Message        string
    // contains filtered or unexported fields
}
```

<a name="Emitter"></a>
## type Emitter

Emitter provides helpers for publishing runtime events with shared metadata.

```go
type Emitter struct {
    // contains filtered or unexported fields
}
```

<a name="NewEmitter"></a>
### func NewEmitter

```go
func NewEmitter(bus *EventBus, runID, sessionID, conversationID string) *Emitter
```

NewEmitter creates a new event emitter.

<a name="Emitter.ContextBuilt"></a>
### func \(\*Emitter\) ContextBuilt

```go
func (e *Emitter) ContextBuilt(messageCount, tokenCount, tokenBudget int, truncated bool)
```

ContextBuilt emits the context.built event.

<a name="Emitter.ConversationStarted"></a>
### func \(\*Emitter\) ConversationStarted

```go
func (e *Emitter) ConversationStarted(systemPrompt string)
```

ConversationStarted emits the conversation.started event with the system prompt.

<a name="Emitter.EmitCustom"></a>
### func \(\*Emitter\) EmitCustom

```go
func (e *Emitter) EmitCustom(eventType EventType, middlewareName, eventName string, data map[string]interface{}, message string)
```

EmitCustom allows middleware to emit arbitrary event types with structured payloads.

<a name="Emitter.MessageCreated"></a>
### func \(\*Emitter\) MessageCreated

```go
func (e *Emitter) MessageCreated(role, content string, index int, toolCalls []MessageToolCall, toolResult *MessageToolResult)
```

MessageCreated emits the message.created event.

<a name="Emitter.MessageUpdated"></a>
### func \(\*Emitter\) MessageUpdated

```go
func (e *Emitter) MessageUpdated(index int, latencyMs int64, inputTokens, outputTokens int, totalCost float64)
```

MessageUpdated emits the message.updated event.

<a name="Emitter.MiddlewareCompleted"></a>
### func \(\*Emitter\) MiddlewareCompleted

```go
func (e *Emitter) MiddlewareCompleted(name string, index int, duration time.Duration)
```

MiddlewareCompleted emits the middleware.completed event.

<a name="Emitter.MiddlewareFailed"></a>
### func \(\*Emitter\) MiddlewareFailed

```go
func (e *Emitter) MiddlewareFailed(name string, index int, err error, duration time.Duration)
```

MiddlewareFailed emits the middleware.failed event.

<a name="Emitter.MiddlewareStarted"></a>
### func \(\*Emitter\) MiddlewareStarted

```go
func (e *Emitter) MiddlewareStarted(name string, index int)
```

MiddlewareStarted emits the middleware.started event.

<a name="Emitter.PipelineCompleted"></a>
### func \(\*Emitter\) PipelineCompleted

```go
func (e *Emitter) PipelineCompleted(duration time.Duration, totalCost float64, inputTokens, outputTokens, messageCount int)
```

PipelineCompleted emits the pipeline.completed event.

<a name="Emitter.PipelineFailed"></a>
### func \(\*Emitter\) PipelineFailed

```go
func (e *Emitter) PipelineFailed(err error, duration time.Duration)
```

PipelineFailed emits the pipeline.failed event.

<a name="Emitter.PipelineStarted"></a>
### func \(\*Emitter\) PipelineStarted

```go
func (e *Emitter) PipelineStarted(middlewareCount int)
```

PipelineStarted emits the pipeline.started event.

<a name="Emitter.ProviderCallCompleted"></a>
### func \(\*Emitter\) ProviderCallCompleted

```go
func (e *Emitter) ProviderCallCompleted(data *ProviderCallCompletedData)
```

ProviderCallCompleted emits the provider.call.completed event.

<a name="Emitter.ProviderCallFailed"></a>
### func \(\*Emitter\) ProviderCallFailed

```go
func (e *Emitter) ProviderCallFailed(provider, model string, err error, duration time.Duration)
```

ProviderCallFailed emits the provider.call.failed event.

<a name="Emitter.ProviderCallStarted"></a>
### func \(\*Emitter\) ProviderCallStarted

```go
func (e *Emitter) ProviderCallStarted(provider, model string, messageCount, toolCount int)
```

ProviderCallStarted emits the provider.call.started event.

<a name="Emitter.StageCompleted"></a>
### func \(\*Emitter\) StageCompleted

```go
func (e *Emitter) StageCompleted(name string, index int, duration time.Duration)
```

StageCompleted emits the stage.completed event \(for streaming architecture\).

<a name="Emitter.StageFailed"></a>
### func \(\*Emitter\) StageFailed

```go
func (e *Emitter) StageFailed(name string, index int, err error, duration time.Duration)
```

StageFailed emits the stage.failed event \(for streaming architecture\).

<a name="Emitter.StageStarted"></a>
### func \(\*Emitter\) StageStarted

```go
func (e *Emitter) StageStarted(name string, index int, stageType interface{})
```

StageStarted emits the stage.started event \(for streaming architecture\).

<a name="Emitter.StateLoaded"></a>
### func \(\*Emitter\) StateLoaded

```go
func (e *Emitter) StateLoaded(conversationID string, messageCount int)
```

StateLoaded emits the state.loaded event.

<a name="Emitter.StateSaved"></a>
### func \(\*Emitter\) StateSaved

```go
func (e *Emitter) StateSaved(conversationID string, messageCount int)
```

StateSaved emits the state.saved event.

<a name="Emitter.StreamInterrupted"></a>
### func \(\*Emitter\) StreamInterrupted

```go
func (e *Emitter) StreamInterrupted(reason string)
```

StreamInterrupted emits the stream.interrupted event.

<a name="Emitter.TokenBudgetExceeded"></a>
### func \(\*Emitter\) TokenBudgetExceeded

```go
func (e *Emitter) TokenBudgetExceeded(required, budget, excess int)
```

TokenBudgetExceeded emits the context.token\_budget\_exceeded event.

<a name="Emitter.ToolCallCompleted"></a>
### func \(\*Emitter\) ToolCallCompleted

```go
func (e *Emitter) ToolCallCompleted(toolName, callID string, duration time.Duration, status string)
```

ToolCallCompleted emits the tool.call.completed event.

<a name="Emitter.ToolCallFailed"></a>
### func \(\*Emitter\) ToolCallFailed

```go
func (e *Emitter) ToolCallFailed(toolName, callID string, err error, duration time.Duration)
```

ToolCallFailed emits the tool.call.failed event.

<a name="Emitter.ToolCallStarted"></a>
### func \(\*Emitter\) ToolCallStarted

```go
func (e *Emitter) ToolCallStarted(toolName, callID string, args map[string]interface{})
```

ToolCallStarted emits the tool.call.started event.

<a name="Emitter.ValidationFailed"></a>
### func \(\*Emitter\) ValidationFailed

```go
func (e *Emitter) ValidationFailed(validatorName, validatorType string, err error, duration time.Duration, violations []string)
```

ValidationFailed emits the validation.failed event.

<a name="Emitter.ValidationPassed"></a>
### func \(\*Emitter\) ValidationPassed

```go
func (e *Emitter) ValidationPassed(validatorName, validatorType string, duration time.Duration)
```

ValidationPassed emits the validation.passed event.

<a name="Emitter.ValidationStarted"></a>
### func \(\*Emitter\) ValidationStarted

```go
func (e *Emitter) ValidationStarted(validatorName, validatorType string)
```

ValidationStarted emits the validation.started event.

<a name="Event"></a>
## type Event

Event represents a runtime event delivered to listeners.

```go
type Event struct {
    Type           EventType
    Timestamp      time.Time
    RunID          string
    SessionID      string
    ConversationID string
    Data           EventData
}
```

<a name="EventBus"></a>
## type EventBus

EventBus manages event distribution to listeners.

```go
type EventBus struct {
    // contains filtered or unexported fields
}
```

<a name="NewEventBus"></a>
### func NewEventBus

```go
func NewEventBus() *EventBus
```

NewEventBus creates a new event bus.

<a name="EventBus.Clear"></a>
### func \(\*EventBus\) Clear

```go
func (eb *EventBus) Clear()
```

Clear removes all listeners \(primarily for tests\).

<a name="EventBus.Publish"></a>
### func \(\*EventBus\) Publish

```go
func (eb *EventBus) Publish(event *Event)
```

Publish sends an event to all registered listeners asynchronously.

<a name="EventBus.Subscribe"></a>
### func \(\*EventBus\) Subscribe

```go
func (eb *EventBus) Subscribe(eventType EventType, listener Listener)
```

Subscribe registers a listener for a specific event type.

<a name="EventBus.SubscribeAll"></a>
### func \(\*EventBus\) SubscribeAll

```go
func (eb *EventBus) SubscribeAll(listener Listener)
```

SubscribeAll registers a listener for all event types.

<a name="EventData"></a>
## type EventData

EventData is a marker interface for event payloads.

```go
type EventData interface {
    // contains filtered or unexported methods
}
```

<a name="EventType"></a>
## type EventType

EventType identifies the type of event emitted by the runtime.

```go
type EventType string
```

<a name="EventPipelineStarted"></a>

```go
const (
    // EventPipelineStarted marks pipeline start.
    EventPipelineStarted EventType = "pipeline.started"
    // EventPipelineCompleted marks pipeline completion.
    EventPipelineCompleted EventType = "pipeline.completed"
    // EventPipelineFailed marks pipeline failure.
    EventPipelineFailed EventType = "pipeline.failed"

    // EventMiddlewareStarted marks middleware start.
    EventMiddlewareStarted EventType = "middleware.started"
    // EventMiddlewareCompleted marks middleware completion.
    EventMiddlewareCompleted EventType = "middleware.completed"
    // EventMiddlewareFailed marks middleware failure.
    EventMiddlewareFailed EventType = "middleware.failed"

    // EventStageStarted marks stage start (for new streaming architecture).
    EventStageStarted EventType = "stage.started"
    // EventStageCompleted marks stage completion (for new streaming architecture).
    EventStageCompleted EventType = "stage.completed"
    // EventStageFailed marks stage failure (for new streaming architecture).
    EventStageFailed EventType = "stage.failed"

    // EventProviderCallStarted marks provider call start.
    EventProviderCallStarted EventType = "provider.call.started"
    // EventProviderCallCompleted marks provider call completion.
    EventProviderCallCompleted EventType = "provider.call.completed"
    // EventProviderCallFailed marks provider call failure.
    EventProviderCallFailed EventType = "provider.call.failed"

    // EventToolCallStarted marks tool call start.
    EventToolCallStarted EventType = "tool.call.started"
    // EventToolCallCompleted marks tool call completion.
    EventToolCallCompleted EventType = "tool.call.completed"
    // EventToolCallFailed marks tool call failure.
    EventToolCallFailed EventType = "tool.call.failed"

    // EventValidationStarted marks validation start.
    EventValidationStarted EventType = "validation.started"
    // EventValidationPassed marks validation success.
    EventValidationPassed EventType = "validation.passed"
    // EventValidationFailed marks validation failure.
    EventValidationFailed EventType = "validation.failed"

    // EventContextBuilt marks context creation.
    EventContextBuilt EventType = "context.built"
    // EventTokenBudgetExceeded marks token budget overflow.
    EventTokenBudgetExceeded EventType = "context.token_budget_exceeded"
    // EventStateLoaded marks state load.
    EventStateLoaded EventType = "state.loaded"
    // EventStateSaved marks state save.
    EventStateSaved EventType = "state.saved"

    // EventStreamInterrupted marks a stream interruption.
    EventStreamInterrupted EventType = "stream.interrupted"

    // EventMessageCreated marks message creation.
    EventMessageCreated EventType = "message.created"
    // EventMessageUpdated marks message update (e.g., cost/latency after completion).
    EventMessageUpdated EventType = "message.updated"

    // EventConversationStarted marks the start of a new conversation.
    EventConversationStarted EventType = "conversation.started"
)
```

<a name="Listener"></a>
## type Listener

Listener is a function that handles events.

```go
type Listener func(*Event)
```

<a name="MessageCreatedData"></a>
## type MessageCreatedData

MessageCreatedData contains data for message creation events.

```go
type MessageCreatedData struct {
    Role       string
    Content    string
    Index      int                // Position in conversation history
    ToolCalls  []MessageToolCall  // Tool calls requested by assistant (if any)
    ToolResult *MessageToolResult // Tool result for tool messages (if any)
    // contains filtered or unexported fields
}
```

<a name="MessageToolCall"></a>
## type MessageToolCall

MessageToolCall represents a tool call in a message event \(mirrors runtime/types.MessageToolCall\).

```go
type MessageToolCall struct {
    ID   string `json:"id"`   // Unique identifier for this tool call
    Name string `json:"name"` // Name of the tool to invoke
    Args string `json:"args"` // JSON-encoded tool arguments as string
}
```

<a name="MessageToolResult"></a>
## type MessageToolResult

MessageToolResult represents a tool result in a message event \(mirrors runtime/types.MessageToolResult\).

```go
type MessageToolResult struct {
    ID        string `json:"id"`                   // References the MessageToolCall.ID
    Name      string `json:"name"`                 // Tool name that was executed
    Content   string `json:"content"`              // Result content
    Error     string `json:"error,omitempty"`      // Error message if tool failed
    LatencyMs int64  `json:"latency_ms,omitempty"` // Tool execution latency
}
```

<a name="MessageUpdatedData"></a>
## type MessageUpdatedData

MessageUpdatedData contains data for message update events.

```go
type MessageUpdatedData struct {
    Index        int // Position in conversation history
    LatencyMs    int64
    InputTokens  int
    OutputTokens int
    TotalCost    float64
    // contains filtered or unexported fields
}
```

<a name="MiddlewareCompletedData"></a>
## type MiddlewareCompletedData

MiddlewareCompletedData contains data for middleware completion events.

```go
type MiddlewareCompletedData struct {
    Name     string
    Index    int
    Duration time.Duration
    // contains filtered or unexported fields
}
```

<a name="MiddlewareFailedData"></a>
## type MiddlewareFailedData

MiddlewareFailedData contains data for middleware failure events.

```go
type MiddlewareFailedData struct {
    Name     string
    Index    int
    Error    error
    Duration time.Duration
    // contains filtered or unexported fields
}
```

<a name="MiddlewareStartedData"></a>
## type MiddlewareStartedData

MiddlewareStartedData contains data for middleware start events.

```go
type MiddlewareStartedData struct {
    Name  string
    Index int
    // contains filtered or unexported fields
}
```

<a name="PipelineCompletedData"></a>
## type PipelineCompletedData

PipelineCompletedData contains data for pipeline completion events.

```go
type PipelineCompletedData struct {
    Duration     time.Duration
    TotalCost    float64
    InputTokens  int
    OutputTokens int
    MessageCount int
    // contains filtered or unexported fields
}
```

<a name="PipelineFailedData"></a>
## type PipelineFailedData

PipelineFailedData contains data for pipeline failure events.

```go
type PipelineFailedData struct {
    Error    error
    Duration time.Duration
    // contains filtered or unexported fields
}
```

<a name="PipelineStartedData"></a>
## type PipelineStartedData

PipelineStartedData contains data for pipeline start events.

```go
type PipelineStartedData struct {
    MiddlewareCount int
    // contains filtered or unexported fields
}
```

<a name="ProviderCallCompletedData"></a>
## type ProviderCallCompletedData

ProviderCallCompletedData contains data for provider call completion events.

```go
type ProviderCallCompletedData struct {
    Provider      string
    Model         string
    Duration      time.Duration
    InputTokens   int
    OutputTokens  int
    CachedTokens  int
    Cost          float64
    FinishReason  string
    ToolCallCount int
    // contains filtered or unexported fields
}
```

<a name="ProviderCallFailedData"></a>
## type ProviderCallFailedData

ProviderCallFailedData contains data for provider call failure events.

```go
type ProviderCallFailedData struct {
    Provider string
    Model    string
    Error    error
    Duration time.Duration
    // contains filtered or unexported fields
}
```

<a name="ProviderCallStartedData"></a>
## type ProviderCallStartedData

ProviderCallStartedData contains data for provider call start events.

```go
type ProviderCallStartedData struct {
    Provider     string
    Model        string
    MessageCount int
    ToolCount    int
    // contains filtered or unexported fields
}
```

<a name="StageCompletedData"></a>
## type StageCompletedData

StageCompletedData contains data for stage completion events \(streaming architecture\).

```go
type StageCompletedData struct {
    Name      string
    Index     int
    Duration  time.Duration
    StageType string
    // contains filtered or unexported fields
}
```

<a name="StageFailedData"></a>
## type StageFailedData

StageFailedData contains data for stage failure events \(streaming architecture\).

```go
type StageFailedData struct {
    Name      string
    Index     int
    Error     error
    Duration  time.Duration
    StageType string
    // contains filtered or unexported fields
}
```

<a name="StageStartedData"></a>
## type StageStartedData

StageStartedData contains data for stage start events \(streaming architecture\).

```go
type StageStartedData struct {
    Name      string
    Index     int
    StageType string // Type of stage (transform, accumulate, generate, sink, bidirectional)
    // contains filtered or unexported fields
}
```

<a name="StateLoadedData"></a>
## type StateLoadedData

StateLoadedData contains data for state load events.

```go
type StateLoadedData struct {
    ConversationID string
    MessageCount   int
    // contains filtered or unexported fields
}
```

<a name="StateSavedData"></a>
## type StateSavedData

StateSavedData contains data for state save events.

```go
type StateSavedData struct {
    ConversationID string
    MessageCount   int
    // contains filtered or unexported fields
}
```

<a name="StreamInterruptedData"></a>
## type StreamInterruptedData

StreamInterruptedData contains data for stream interruption events.

```go
type StreamInterruptedData struct {
    Reason string
    // contains filtered or unexported fields
}
```

<a name="TokenBudgetExceededData"></a>
## type TokenBudgetExceededData

TokenBudgetExceededData contains data for token budget exceeded events.

```go
type TokenBudgetExceededData struct {
    RequiredTokens int
    Budget         int
    Excess         int
    // contains filtered or unexported fields
}
```

<a name="ToolCallCompletedData"></a>
## type ToolCallCompletedData

ToolCallCompletedData contains data for tool call completion events.

```go
type ToolCallCompletedData struct {
    ToolName string
    CallID   string
    Duration time.Duration
    Status   string // e.g. "success", "error", "pending"
    // contains filtered or unexported fields
}
```

<a name="ToolCallFailedData"></a>
## type ToolCallFailedData

ToolCallFailedData contains data for tool call failure events.

```go
type ToolCallFailedData struct {
    ToolName string
    CallID   string
    Error    error
    Duration time.Duration
    // contains filtered or unexported fields
}
```

<a name="ToolCallStartedData"></a>
## type ToolCallStartedData

ToolCallStartedData contains data for tool call start events.

```go
type ToolCallStartedData struct {
    ToolName string
    CallID   string
    Args     map[string]interface{}
    // contains filtered or unexported fields
}
```

<a name="ValidationFailedData"></a>
## type ValidationFailedData

ValidationFailedData contains data for validation failure events.

```go
type ValidationFailedData struct {
    ValidatorName string
    ValidatorType string
    Error         error
    Duration      time.Duration
    Violations    []string
    // contains filtered or unexported fields
}
```

<a name="ValidationPassedData"></a>
## type ValidationPassedData

ValidationPassedData contains data for validation success events.

```go
type ValidationPassedData struct {
    ValidatorName string
    ValidatorType string
    Duration      time.Duration
    // contains filtered or unexported fields
}
```

<a name="ValidationStartedData"></a>
## type ValidationStartedData

ValidationStartedData contains data for validation start events.

```go
type ValidationStartedData struct {
    ValidatorName string
    ValidatorType string // e.g. "input", "output", "semantic"
    // contains filtered or unexported fields
}
```

# logger

```go
import "github.com/AltairaLabs/PromptKit/runtime/logger"
```

Package logger provides structured logging with automatic PII redaction.

Package logger provides structured logging with automatic PII redaction.

This package wraps Go's standard log/slog with convenience functions for:

- LLM API call logging \(requests, responses, errors\)
- Tool execution logging
- Automatic API key and sensitive data redaction
- Contextual logging with request tracing
- Level\-based verbosity control

All exported functions use the global DefaultLogger which can be configured for different output formats and log levels.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func APIRequest\(provider, method, url string, headers map\[string\]string, body interface\{\}\)](<#APIRequest>)
- [func APIResponse\(provider string, statusCode int, body string, err error\)](<#APIResponse>)
- [func Configure\(cfg \*LoggingConfigSpec\) error](<#Configure>)
- [func Debug\(msg string, args ...any\)](<#Debug>)
- [func DebugContext\(ctx context.Context, msg string, args ...any\)](<#DebugContext>)
- [func Error\(msg string, args ...any\)](<#Error>)
- [func ErrorContext\(ctx context.Context, msg string, args ...any\)](<#ErrorContext>)
- [func Info\(msg string, args ...any\)](<#Info>)
- [func InfoContext\(ctx context.Context, msg string, args ...any\)](<#InfoContext>)
- [func LLMCall\(provider, role string, messages int, temperature float64, attrs ...any\)](<#LLMCall>)
- [func LLMError\(provider, role string, err error, attrs ...any\)](<#LLMError>)
- [func LLMResponse\(provider, role string, tokensIn, tokensOut int, cost float64, attrs ...any\)](<#LLMResponse>)
- [func ParseLevel\(s string\) slog.Level](<#ParseLevel>)
- [func RedactSensitiveData\(input string\) string](<#RedactSensitiveData>)
- [func SetLevel\(level slog.Level\)](<#SetLevel>)
- [func SetOutput\(w io.Writer\)](<#SetOutput>)
- [func SetVerbose\(verbose bool\)](<#SetVerbose>)
- [func ToolCall\(provider string, messages, tools int, choice string, attrs ...any\)](<#ToolCall>)
- [func ToolResponse\(provider string, tokensIn, tokensOut, toolCalls int, cost float64, attrs ...any\)](<#ToolResponse>)
- [func Warn\(msg string, args ...any\)](<#Warn>)
- [func WarnContext\(ctx context.Context, msg string, args ...any\)](<#WarnContext>)
- [func WithCorrelationID\(ctx context.Context, correlationID string\) context.Context](<#WithCorrelationID>)
- [func WithEnvironment\(ctx context.Context, environment string\) context.Context](<#WithEnvironment>)
- [func WithLoggingContext\(ctx context.Context, fields \*LoggingFields\) context.Context](<#WithLoggingContext>)
- [func WithModel\(ctx context.Context, model string\) context.Context](<#WithModel>)
- [func WithProvider\(ctx context.Context, provider string\) context.Context](<#WithProvider>)
- [func WithRequestID\(ctx context.Context, requestID string\) context.Context](<#WithRequestID>)
- [func WithScenario\(ctx context.Context, scenario string\) context.Context](<#WithScenario>)
- [func WithScenarioVersion\(ctx context.Context, version string\) context.Context](<#WithScenarioVersion>)
- [func WithSessionID\(ctx context.Context, sessionID string\) context.Context](<#WithSessionID>)
- [func WithStage\(ctx context.Context, stage string\) context.Context](<#WithStage>)
- [func WithTurnID\(ctx context.Context, turnID string\) context.Context](<#WithTurnID>)
- [type ContextHandler](<#ContextHandler>)
  - [func NewContextHandler\(inner slog.Handler, commonFields ...slog.Attr\) \*ContextHandler](<#NewContextHandler>)
  - [func \(h \*ContextHandler\) Enabled\(ctx context.Context, level slog.Level\) bool](<#ContextHandler.Enabled>)
  - [func \(h \*ContextHandler\) Handle\(ctx context.Context, r slog.Record\) error](<#ContextHandler.Handle>)
  - [func \(h \*ContextHandler\) Unwrap\(\) slog.Handler](<#ContextHandler.Unwrap>)
  - [func \(h \*ContextHandler\) WithAttrs\(attrs \[\]slog.Attr\) slog.Handler](<#ContextHandler.WithAttrs>)
  - [func \(h \*ContextHandler\) WithGroup\(name string\) slog.Handler](<#ContextHandler.WithGroup>)
- [type LoggingConfigSpec](<#LoggingConfigSpec>)
- [type LoggingFields](<#LoggingFields>)
  - [func ExtractLoggingFields\(ctx context.Context\) LoggingFields](<#ExtractLoggingFields>)
- [type ModuleConfig](<#ModuleConfig>)
  - [func GetModuleConfig\(\) \*ModuleConfig](<#GetModuleConfig>)
  - [func NewModuleConfig\(defaultLevel slog.Level\) \*ModuleConfig](<#NewModuleConfig>)
  - [func \(m \*ModuleConfig\) LevelFor\(module string\) slog.Level](<#ModuleConfig.LevelFor>)
  - [func \(m \*ModuleConfig\) SetDefaultLevel\(level slog.Level\)](<#ModuleConfig.SetDefaultLevel>)
  - [func \(m \*ModuleConfig\) SetModuleLevel\(module string, level slog.Level\)](<#ModuleConfig.SetModuleLevel>)
- [type ModuleHandler](<#ModuleHandler>)
  - [func NewModuleHandler\(inner slog.Handler, moduleConfig \*ModuleConfig, commonFields ...slog.Attr\) \*ModuleHandler](<#NewModuleHandler>)
  - [func \(h \*ModuleHandler\) Enabled\(ctx context.Context, level slog.Level\) bool](<#ModuleHandler.Enabled>)
  - [func \(h \*ModuleHandler\) Handle\(ctx context.Context, r slog.Record\) error](<#ModuleHandler.Handle>)
  - [func \(h \*ModuleHandler\) WithAttrs\(attrs \[\]slog.Attr\) slog.Handler](<#ModuleHandler.WithAttrs>)
  - [func \(h \*ModuleHandler\) WithGroup\(name string\) slog.Handler](<#ModuleHandler.WithGroup>)
- [type ModuleLoggingSpec](<#ModuleLoggingSpec>)


## Constants

<a name="FormatJSON"></a>Log format constants

```go
const (
    FormatJSON = "json"
    FormatText = "text"
)
```

## Variables

<a name="DefaultLogger"></a>

```go
var (
    // DefaultLogger is the global structured logger instance.
    // It is safe for concurrent use and initialized with slog.LevelInfo by default.
    DefaultLogger *slog.Logger
)
```

<a name="APIRequest"></a>
## func APIRequest

```go
func APIRequest(provider, method, url string, headers map[string]string, body interface{})
```

APIRequest logs HTTP API request details at debug level with automatic PII redaction. This function is a no\-op when debug logging is disabled for performance.

Parameters:

- provider: The API provider name \(e.g., "OpenAI", "Anthropic"\)
- method: HTTP method \(GET, POST, etc.\)
- url: Request URL \(will be redacted for sensitive data\)
- headers: HTTP headers map \(will be redacted\)
- body: Request body \(will be marshaled to JSON and redacted\)

Sensitive data in URL, headers, and body are automatically redacted.

<a name="APIResponse"></a>
## func APIResponse

```go
func APIResponse(provider string, statusCode int, body string, err error)
```

APIResponse logs HTTP API response details at debug level with automatic PII redaction. This function is a no\-op when debug logging is disabled for performance.

Parameters:

- provider: The API provider name
- statusCode: HTTP status code
- body: Response body as string \(will be redacted\)
- err: Error if the request failed \(takes precedence over body logging\)

Response bodies are attempted to be parsed as JSON for pretty formatting. Status codes are logged with emoji indicators:  \(2xx\),  \(3xx\),  \(4xx/5xx\).

<a name="Configure"></a>
## func Configure

```go
func Configure(cfg *LoggingConfigSpec) error
```

Configure applies a LoggingConfigSpec to the global logger. This reconfigures the logger with the new settings.

<a name="Debug"></a>
## func Debug

```go
func Debug(msg string, args ...any)
```

Debug logs a debug\-level message with structured attributes. Debug messages are only output when the log level is set to LevelDebug or lower.

<a name="DebugContext"></a>
## func DebugContext

```go
func DebugContext(ctx context.Context, msg string, args ...any)
```

DebugContext logs a debug message with context and structured attributes.

<a name="Error"></a>
## func Error

```go
func Error(msg string, args ...any)
```

Error logs an error message with structured attributes. Use for errors that affect operation but don't cause complete failure.

<a name="ErrorContext"></a>
## func ErrorContext

```go
func ErrorContext(ctx context.Context, msg string, args ...any)
```

ErrorContext logs an error message with context and structured attributes.

<a name="Info"></a>
## func Info

```go
func Info(msg string, args ...any)
```

Info logs an informational message with structured key\-value attributes. Args should be provided in key\-value pairs: key1, value1, key2, value2, ...

<a name="InfoContext"></a>
## func InfoContext

```go
func InfoContext(ctx context.Context, msg string, args ...any)
```

InfoContext logs an informational message with context and structured attributes. The context can be used for request tracing and cancellation.

<a name="LLMCall"></a>
## func LLMCall

```go
func LLMCall(provider, role string, messages int, temperature float64, attrs ...any)
```

LLMCall logs an LLM API call with structured fields for observability. Additional attributes can be passed as key\-value pairs after the required parameters.

<a name="LLMError"></a>
## func LLMError

```go
func LLMError(provider, role string, err error, attrs ...any)
```

LLMError logs an LLM API error for debugging and monitoring.

<a name="LLMResponse"></a>
## func LLMResponse

```go
func LLMResponse(provider, role string, tokensIn, tokensOut int, cost float64, attrs ...any)
```

LLMResponse logs an LLM API response with token usage and cost tracking. Cost should be provided in USD \(e.g., 0.0001 for $0.0001\).

<a name="ParseLevel"></a>
## func ParseLevel

```go
func ParseLevel(s string) slog.Level
```

ParseLevel converts a string log level to slog.Level. Supported values: "trace", "debug", "info", "warn", "warning", "error". Unknown values default to LevelInfo.

<a name="RedactSensitiveData"></a>
## func RedactSensitiveData

```go
func RedactSensitiveData(input string) string
```

RedactSensitiveData removes API keys and other sensitive information from strings. It replaces matched patterns with a redacted form that preserves the first few characters for debugging while hiding the sensitive portion.

Supported patterns:

- OpenAI keys \(sk\-...\): Shows first 4 chars
- Google keys \(AIza...\): Shows first 4 chars
- Bearer tokens: Shows only "Bearer \[REDACTED\]"

This function is safe for concurrent use as it only reads from the compiled patterns.

<a name="SetLevel"></a>
## func SetLevel

```go
func SetLevel(level slog.Level)
```

SetLevel changes the logging level for all subsequent log operations. This is safe for concurrent use as it replaces the entire logger instance.

<a name="SetOutput"></a>
## func SetOutput

```go
func SetOutput(w io.Writer)
```

SetOutput changes the log output destination and reinitializes the logger. This is primarily for testing. Pass nil to reset to os.Stderr.

<a name="SetVerbose"></a>
## func SetVerbose

```go
func SetVerbose(verbose bool)
```

SetVerbose enables debug\-level logging when verbose is true, otherwise sets info\-level. This is a convenience wrapper around SetLevel for command\-line verbose flags.

<a name="ToolCall"></a>
## func ToolCall

```go
func ToolCall(provider string, messages, tools int, choice string, attrs ...any)
```

ToolCall logs a tool execution request with context about available tools. The choice parameter indicates the tool selection mode \(e.g., "auto", "required", "none"\).

<a name="ToolResponse"></a>
## func ToolResponse

```go
func ToolResponse(provider string, tokensIn, tokensOut, toolCalls int, cost float64, attrs ...any)
```

ToolResponse logs the result of tool executions with token usage and cost.

<a name="Warn"></a>
## func Warn

```go
func Warn(msg string, args ...any)
```

Warn logs a warning message with structured attributes. Use for recoverable errors or unexpected but non\-critical situations.

<a name="WarnContext"></a>
## func WarnContext

```go
func WarnContext(ctx context.Context, msg string, args ...any)
```

WarnContext logs a warning message with context and structured attributes.

<a name="WithCorrelationID"></a>
## func WithCorrelationID

```go
func WithCorrelationID(ctx context.Context, correlationID string) context.Context
```

WithCorrelationID returns a new context with the correlation ID set.

<a name="WithEnvironment"></a>
## func WithEnvironment

```go
func WithEnvironment(ctx context.Context, environment string) context.Context
```

WithEnvironment returns a new context with the environment set.

<a name="WithLoggingContext"></a>
## func WithLoggingContext

```go
func WithLoggingContext(ctx context.Context, fields *LoggingFields) context.Context
```

WithLoggingContext returns a new context with multiple logging fields set at once. This is a convenience function for setting multiple fields in one call. Only non\-empty values are set.

<a name="WithModel"></a>
## func WithModel

```go
func WithModel(ctx context.Context, model string) context.Context
```

WithModel returns a new context with the model name set.

<a name="WithProvider"></a>
## func WithProvider

```go
func WithProvider(ctx context.Context, provider string) context.Context
```

WithProvider returns a new context with the provider name set.

<a name="WithRequestID"></a>
## func WithRequestID

```go
func WithRequestID(ctx context.Context, requestID string) context.Context
```

WithRequestID returns a new context with the request ID set.

<a name="WithScenario"></a>
## func WithScenario

```go
func WithScenario(ctx context.Context, scenario string) context.Context
```

WithScenario returns a new context with the scenario name set.

<a name="WithScenarioVersion"></a>
## func WithScenarioVersion

```go
func WithScenarioVersion(ctx context.Context, version string) context.Context
```

WithScenarioVersion returns a new context with the scenario version set.

<a name="WithSessionID"></a>
## func WithSessionID

```go
func WithSessionID(ctx context.Context, sessionID string) context.Context
```

WithSessionID returns a new context with the session ID set.

<a name="WithStage"></a>
## func WithStage

```go
func WithStage(ctx context.Context, stage string) context.Context
```

WithStage returns a new context with the pipeline stage set.

<a name="WithTurnID"></a>
## func WithTurnID

```go
func WithTurnID(ctx context.Context, turnID string) context.Context
```

WithTurnID returns a new context with the turn ID set.

<a name="ContextHandler"></a>
## type ContextHandler

ContextHandler is a slog.Handler that automatically extracts logging fields from context and adds them to log records. It wraps an inner handler and delegates all actual logging to it after enriching records with context data.

```go
type ContextHandler struct {
    // contains filtered or unexported fields
}
```

<a name="NewContextHandler"></a>
### func NewContextHandler

```go
func NewContextHandler(inner slog.Handler, commonFields ...slog.Attr) *ContextHandler
```

NewContextHandler creates a new ContextHandler wrapping the given handler. The commonFields are added to every log record \(useful for environment, service name, etc.\).

<a name="ContextHandler.Enabled"></a>
### func \(\*ContextHandler\) Enabled

```go
func (h *ContextHandler) Enabled(ctx context.Context, level slog.Level) bool
```

Enabled reports whether the handler handles records at the given level. It delegates to the inner handler.

<a name="ContextHandler.Handle"></a>
### func \(\*ContextHandler\) Handle

```go
func (h *ContextHandler) Handle(ctx context.Context, r slog.Record) error
```

Handle processes the log record by extracting context fields and adding them to the record before delegating to the inner handler.

<a name="ContextHandler.Unwrap"></a>
### func \(\*ContextHandler\) Unwrap

```go
func (h *ContextHandler) Unwrap() slog.Handler
```

Unwrap returns the inner handler. This is useful for handler chains that need to inspect or replace the underlying handler.

<a name="ContextHandler.WithAttrs"></a>
### func \(\*ContextHandler\) WithAttrs

```go
func (h *ContextHandler) WithAttrs(attrs []slog.Attr) slog.Handler
```

WithAttrs returns a new handler with the given attributes added. The attributes are added to the inner handler.

<a name="ContextHandler.WithGroup"></a>
### func \(\*ContextHandler\) WithGroup

```go
func (h *ContextHandler) WithGroup(name string) slog.Handler
```

WithGroup returns a new handler with the given group name. The group is added to the inner handler.

<a name="LoggingConfigSpec"></a>
## type LoggingConfigSpec

LoggingConfigSpec defines the logging configuration for the Configure function. This mirrors the config.LoggingConfigSpec to avoid import cycles.

```go
type LoggingConfigSpec struct {
    DefaultLevel string
    Format       string // "json" or "text"
    CommonFields map[string]string
    Modules      []ModuleLoggingSpec
}
```

<a name="LoggingFields"></a>
## type LoggingFields

LoggingFields holds all standard logging context fields. This struct is used with WithLoggingContext for bulk field setting.

```go
type LoggingFields struct {
    TurnID          string
    Scenario        string
    ScenarioVersion string
    Provider        string
    Model           string
    Stage           string
    SessionID       string
    RequestID       string
    CorrelationID   string
    Environment     string
}
```

<a name="ExtractLoggingFields"></a>
### func ExtractLoggingFields

```go
func ExtractLoggingFields(ctx context.Context) LoggingFields
```

ExtractLoggingFields extracts all logging fields from a context. Returns a LoggingFields struct with all values found in the context.

<a name="ModuleConfig"></a>
## type ModuleConfig

ModuleConfig manages per\-module logging configuration. It supports hierarchical module names where more specific modules override less specific ones \(e.g., "runtime.pipeline" overrides "runtime"\).

```go
type ModuleConfig struct {
    // contains filtered or unexported fields
}
```

<a name="GetModuleConfig"></a>
### func GetModuleConfig

```go
func GetModuleConfig() *ModuleConfig
```

GetModuleConfig returns the global module configuration. This is primarily for testing.

<a name="NewModuleConfig"></a>
### func NewModuleConfig

```go
func NewModuleConfig(defaultLevel slog.Level) *ModuleConfig
```

NewModuleConfig creates a new ModuleConfig with the given default level.

<a name="ModuleConfig.LevelFor"></a>
### func \(\*ModuleConfig\) LevelFor

```go
func (m *ModuleConfig) LevelFor(module string) slog.Level
```

LevelFor returns the log level for the given module. It checks for exact match first, then walks up the hierarchy. For example, for "runtime.pipeline.stage":

1. Check "runtime.pipeline.stage" \(exact match\)
2. Check "runtime.pipeline" \(parent\)
3. Check "runtime" \(grandparent\)
4. Return default level

<a name="ModuleConfig.SetDefaultLevel"></a>
### func \(\*ModuleConfig\) SetDefaultLevel

```go
func (m *ModuleConfig) SetDefaultLevel(level slog.Level)
```

SetDefaultLevel sets the default log level.

<a name="ModuleConfig.SetModuleLevel"></a>
### func \(\*ModuleConfig\) SetModuleLevel

```go
func (m *ModuleConfig) SetModuleLevel(module string, level slog.Level)
```

SetModuleLevel sets the log level for a specific module. Module names use dot notation \(e.g., "runtime.pipeline"\).

<a name="ModuleHandler"></a>
## type ModuleHandler

ModuleHandler extends ContextHandler with per\-module log level filtering. It determines the module name from the call stack and applies the appropriate log level from the module configuration.

```go
type ModuleHandler struct {
    ContextHandler
    // contains filtered or unexported fields
}
```

<a name="NewModuleHandler"></a>
### func NewModuleHandler

```go
func NewModuleHandler(inner slog.Handler, moduleConfig *ModuleConfig, commonFields ...slog.Attr) *ModuleHandler
```

NewModuleHandler creates a new ModuleHandler with per\-module log level filtering.

<a name="ModuleHandler.Enabled"></a>
### func \(\*ModuleHandler\) Enabled

```go
func (h *ModuleHandler) Enabled(ctx context.Context, level slog.Level) bool
```

Enabled reports whether the handler handles records at the given level. It uses the module configuration to determine the level for the calling module.

<a name="ModuleHandler.Handle"></a>
### func \(\*ModuleHandler\) Handle

```go
func (h *ModuleHandler) Handle(ctx context.Context, r slog.Record) error
```

Handle processes the log record, adding the module name as an attribute.

<a name="ModuleHandler.WithAttrs"></a>
### func \(\*ModuleHandler\) WithAttrs

```go
func (h *ModuleHandler) WithAttrs(attrs []slog.Attr) slog.Handler
```

WithAttrs returns a new handler with the given attributes added.

<a name="ModuleHandler.WithGroup"></a>
### func \(\*ModuleHandler\) WithGroup

```go
func (h *ModuleHandler) WithGroup(name string) slog.Handler
```

WithGroup returns a new handler with the given group name.

<a name="ModuleLoggingSpec"></a>
## type ModuleLoggingSpec

ModuleLoggingSpec configures logging for a specific module.

```go
type ModuleLoggingSpec struct {
    Name   string
    Level  string
    Fields map[string]string
}
```

# mcp

```go
import "github.com/AltairaLabs/PromptKit/runtime/mcp"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [type Client](<#Client>)
- [type ClientCapabilities](<#ClientCapabilities>)
- [type ClientOptions](<#ClientOptions>)
  - [func DefaultClientOptions\(\) ClientOptions](<#DefaultClientOptions>)
- [type Content](<#Content>)
- [type ElicitationCapability](<#ElicitationCapability>)
- [type Implementation](<#Implementation>)
- [type InitializeRequest](<#InitializeRequest>)
- [type InitializeResponse](<#InitializeResponse>)
- [type JSONRPCError](<#JSONRPCError>)
- [type JSONRPCMessage](<#JSONRPCMessage>)
- [type LoggingCapability](<#LoggingCapability>)
- [type PromptsCapability](<#PromptsCapability>)
- [type Registry](<#Registry>)
- [type RegistryImpl](<#RegistryImpl>)
  - [func NewRegistry\(\) \*RegistryImpl](<#NewRegistry>)
  - [func NewRegistryWithServers\(serverConfigs \[\]ServerConfigData\) \(\*RegistryImpl, error\)](<#NewRegistryWithServers>)
  - [func \(r \*RegistryImpl\) Close\(\) error](<#RegistryImpl.Close>)
  - [func \(r \*RegistryImpl\) GetClient\(ctx context.Context, serverName string\) \(Client, error\)](<#RegistryImpl.GetClient>)
  - [func \(r \*RegistryImpl\) GetClientForTool\(ctx context.Context, toolName string\) \(Client, error\)](<#RegistryImpl.GetClientForTool>)
  - [func \(r \*RegistryImpl\) GetToolSchema\(ctx context.Context, toolName string\) \(\*Tool, error\)](<#RegistryImpl.GetToolSchema>)
  - [func \(r \*RegistryImpl\) ListAllTools\(ctx context.Context\) \(map\[string\]\[\]Tool, error\)](<#RegistryImpl.ListAllTools>)
  - [func \(r \*RegistryImpl\) ListServers\(\) \[\]string](<#RegistryImpl.ListServers>)
  - [func \(r \*RegistryImpl\) RegisterServer\(config ServerConfig\) error](<#RegistryImpl.RegisterServer>)
- [type ResourcesCapability](<#ResourcesCapability>)
- [type SamplingCapability](<#SamplingCapability>)
- [type ServerCapabilities](<#ServerCapabilities>)
- [type ServerConfig](<#ServerConfig>)
- [type ServerConfigData](<#ServerConfigData>)
- [type StdioClient](<#StdioClient>)
  - [func NewStdioClient\(config ServerConfig\) \*StdioClient](<#NewStdioClient>)
  - [func NewStdioClientWithOptions\(config ServerConfig, options ClientOptions\) \*StdioClient](<#NewStdioClientWithOptions>)
  - [func \(c \*StdioClient\) CallTool\(ctx context.Context, name string, arguments json.RawMessage\) \(\*ToolCallResponse, error\)](<#StdioClient.CallTool>)
  - [func \(c \*StdioClient\) Close\(\) error](<#StdioClient.Close>)
  - [func \(c \*StdioClient\) Initialize\(ctx context.Context\) \(\*InitializeResponse, error\)](<#StdioClient.Initialize>)
  - [func \(c \*StdioClient\) IsAlive\(\) bool](<#StdioClient.IsAlive>)
  - [func \(c \*StdioClient\) ListTools\(ctx context.Context\) \(\[\]Tool, error\)](<#StdioClient.ListTools>)
- [type Tool](<#Tool>)
- [type ToolCallRequest](<#ToolCallRequest>)
- [type ToolCallResponse](<#ToolCallResponse>)
- [type ToolsCapability](<#ToolsCapability>)
- [type ToolsListRequest](<#ToolsListRequest>)
- [type ToolsListResponse](<#ToolsListResponse>)


## Constants

<a name="ProtocolVersion"></a>ProtocolVersion defines the MCP protocol version \(as of 2025\-06\-18\).

```go
const ProtocolVersion = "2025-06-18"
```

## Variables

<a name="ErrClientNotInitialized"></a>

```go
var (
    // ErrClientNotInitialized is returned when attempting operations on uninitialized client
    ErrClientNotInitialized = errors.New("mcp: client not initialized")
    // ErrClientClosed is returned when attempting operations on closed client
    ErrClientClosed = errors.New("mcp: client closed")
    // ErrServerUnresponsive is returned when server doesn't respond
    ErrServerUnresponsive = errors.New("mcp: server unresponsive")
    // ErrProcessDied is returned when server process dies unexpectedly
    ErrProcessDied = errors.New("mcp: server process died")
)
```

<a name="Client"></a>
## type Client

Client interface defines the MCP client operations

```go
type Client interface {
    // Initialize establishes the MCP connection and negotiates capabilities
    Initialize(ctx context.Context) (*InitializeResponse, error)

    // ListTools retrieves all available tools from the server
    ListTools(ctx context.Context) ([]Tool, error)

    // CallTool executes a tool with the given arguments
    CallTool(ctx context.Context, name string, arguments json.RawMessage) (*ToolCallResponse, error)

    // Close terminates the connection to the MCP server
    Close() error

    // IsAlive checks if the connection is still active
    IsAlive() bool
}
```

<a name="ClientCapabilities"></a>
## type ClientCapabilities

ClientCapabilities describes what the client supports

```go
type ClientCapabilities struct {
    Elicitation *ElicitationCapability `json:"elicitation,omitempty"`
    Sampling    *SamplingCapability    `json:"sampling,omitempty"`
    Logging     *LoggingCapability     `json:"logging,omitempty"`
}
```

<a name="ClientOptions"></a>
## type ClientOptions

ClientOptions configures MCP client behavior

```go
type ClientOptions struct {
    // RequestTimeout is the default timeout for RPC requests
    RequestTimeout time.Duration
    // InitTimeout is the timeout for the initialization handshake
    InitTimeout time.Duration
    // MaxRetries is the number of times to retry failed requests
    MaxRetries int
    // RetryDelay is the initial delay between retries (exponential backoff)
    RetryDelay time.Duration
    // EnableGracefulDegradation allows operations to continue even if MCP is unavailable
    EnableGracefulDegradation bool
}
```

<a name="DefaultClientOptions"></a>
### func DefaultClientOptions

```go
func DefaultClientOptions() ClientOptions
```

DefaultClientOptions returns sensible defaults

<a name="Content"></a>
## type Content

Content represents a content item in MCP responses

```go
type Content struct {
    Type     string `json:"type"` // "text", "image", "resource", etc.
    Text     string `json:"text,omitempty"`
    Data     string `json:"data,omitempty"`     // Base64 encoded data
    MimeType string `json:"mimeType,omitempty"` // MIME type for data
    URI      string `json:"uri,omitempty"`      // URI for resources
}
```

<a name="ElicitationCapability"></a>
## type ElicitationCapability

ElicitationCapability indicates the client supports elicitation

```go
type ElicitationCapability struct{}
```

<a name="Implementation"></a>
## type Implementation

Implementation describes client or server implementation details

```go
type Implementation struct {
    Name    string `json:"name"`
    Version string `json:"version"`
}
```

<a name="InitializeRequest"></a>
## type InitializeRequest

InitializeRequest represents the initialization request params

```go
type InitializeRequest struct {
    ProtocolVersion string             `json:"protocolVersion"`
    Capabilities    ClientCapabilities `json:"capabilities"`
    ClientInfo      Implementation     `json:"clientInfo"`
}
```

<a name="InitializeResponse"></a>
## type InitializeResponse

InitializeResponse represents the initialization response

```go
type InitializeResponse struct {
    ProtocolVersion string             `json:"protocolVersion"`
    Capabilities    ServerCapabilities `json:"capabilities"`
    ServerInfo      Implementation     `json:"serverInfo"`
}
```

<a name="JSONRPCError"></a>
## type JSONRPCError

JSONRPCError represents a JSON\-RPC 2.0 error

```go
type JSONRPCError struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
}
```

<a name="JSONRPCMessage"></a>
## type JSONRPCMessage

JSONRPCMessage represents a JSON\-RPC 2.0 message

```go
type JSONRPCMessage struct {
    JSONRPC string          `json:"jsonrpc"`
    ID      interface{}     `json:"id,omitempty"`     // Request ID (number or string)
    Method  string          `json:"method,omitempty"` // Method name for requests/notifications
    Params  json.RawMessage `json:"params,omitempty"` // Parameters for method
    Result  json.RawMessage `json:"result,omitempty"` // Result for responses
    Error   *JSONRPCError   `json:"error,omitempty"`  // Error for error responses
}
```

<a name="LoggingCapability"></a>
## type LoggingCapability

LoggingCapability indicates the client supports logging

```go
type LoggingCapability struct{}
```

<a name="PromptsCapability"></a>
## type PromptsCapability

PromptsCapability indicates the server supports prompts

```go
type PromptsCapability struct {
    ListChanged bool `json:"listChanged,omitempty"`
}
```

<a name="Registry"></a>
## type Registry

Registry interface defines the MCP server registry operations

```go
type Registry interface {
    // RegisterServer adds a new MCP server configuration
    RegisterServer(config ServerConfig) error

    // GetClient returns an active client for the given server name
    GetClient(ctx context.Context, serverName string) (Client, error)

    // GetClientForTool returns the client that provides the specified tool
    GetClientForTool(ctx context.Context, toolName string) (Client, error)

    // ListServers returns all registered server names
    ListServers() []string

    // ListAllTools returns all tools from all connected servers
    ListAllTools(ctx context.Context) (map[string][]Tool, error)

    // Close shuts down all MCP servers and connections
    Close() error
}
```

<a name="RegistryImpl"></a>
## type RegistryImpl

RegistryImpl implements the Registry interface

```go
type RegistryImpl struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *RegistryImpl
```

NewRegistry creates a new MCP server registry

<a name="NewRegistryWithServers"></a>
### func NewRegistryWithServers

```go
func NewRegistryWithServers(serverConfigs []ServerConfigData) (*RegistryImpl, error)
```

NewRegistryWithServers creates a registry and registers multiple servers. Returns error if any server registration fails.

<a name="RegistryImpl.Close"></a>
### func \(\*RegistryImpl\) Close

```go
func (r *RegistryImpl) Close() error
```

Close shuts down all MCP servers and connections

<a name="RegistryImpl.GetClient"></a>
### func \(\*RegistryImpl\) GetClient

```go
func (r *RegistryImpl) GetClient(ctx context.Context, serverName string) (Client, error)
```

GetClient returns an active client for the given server name

<a name="RegistryImpl.GetClientForTool"></a>
### func \(\*RegistryImpl\) GetClientForTool

```go
func (r *RegistryImpl) GetClientForTool(ctx context.Context, toolName string) (Client, error)
```

GetClientForTool returns the client that provides the specified tool

<a name="RegistryImpl.GetToolSchema"></a>
### func \(\*RegistryImpl\) GetToolSchema

```go
func (r *RegistryImpl) GetToolSchema(ctx context.Context, toolName string) (*Tool, error)
```

GetToolSchema returns the schema for a specific tool

<a name="RegistryImpl.ListAllTools"></a>
### func \(\*RegistryImpl\) ListAllTools

```go
func (r *RegistryImpl) ListAllTools(ctx context.Context) (map[string][]Tool, error)
```

ListAllTools returns all tools from all connected servers

<a name="RegistryImpl.ListServers"></a>
### func \(\*RegistryImpl\) ListServers

```go
func (r *RegistryImpl) ListServers() []string
```

ListServers returns all registered server names

<a name="RegistryImpl.RegisterServer"></a>
### func \(\*RegistryImpl\) RegisterServer

```go
func (r *RegistryImpl) RegisterServer(config ServerConfig) error
```

RegisterServer adds a new MCP server configuration

<a name="ResourcesCapability"></a>
## type ResourcesCapability

ResourcesCapability indicates the server supports resources

```go
type ResourcesCapability struct {
    ListChanged bool `json:"listChanged,omitempty"`
}
```

<a name="SamplingCapability"></a>
## type SamplingCapability

SamplingCapability indicates the client supports sampling

```go
type SamplingCapability struct{}
```

<a name="ServerCapabilities"></a>
## type ServerCapabilities

ServerCapabilities describes what the server supports

```go
type ServerCapabilities struct {
    Tools     *ToolsCapability     `json:"tools,omitempty"`
    Resources *ResourcesCapability `json:"resources,omitempty"`
    Prompts   *PromptsCapability   `json:"prompts,omitempty"`
}
```

<a name="ServerConfig"></a>
## type ServerConfig

ServerConfig represents configuration for an MCP server

```go
type ServerConfig struct {
    Name    string            `json:"name" yaml:"name"`       // Unique identifier for this server
    Command string            `json:"command" yaml:"command"` // Command to execute
    Args    []string          `json:"args,omitempty" yaml:"args,omitempty"`
    Env     map[string]string `json:"env,omitempty" yaml:"env,omitempty"`
}
```

<a name="ServerConfigData"></a>
## type ServerConfigData

ServerConfigData holds MCP server configuration matching config.MCPServerConfig

```go
type ServerConfigData struct {
    Name    string
    Command string
    Args    []string
    Env     map[string]string
}
```

<a name="StdioClient"></a>
## type StdioClient

StdioClient implements the MCP Client interface using stdio transport

```go
type StdioClient struct {
    // contains filtered or unexported fields
}
```

<a name="NewStdioClient"></a>
### func NewStdioClient

```go
func NewStdioClient(config ServerConfig) *StdioClient
```

NewStdioClient creates a new MCP client using stdio transport

<a name="NewStdioClientWithOptions"></a>
### func NewStdioClientWithOptions

```go
func NewStdioClientWithOptions(config ServerConfig, options ClientOptions) *StdioClient
```

NewStdioClientWithOptions creates a client with custom options

<a name="StdioClient.CallTool"></a>
### func \(\*StdioClient\) CallTool

```go
func (c *StdioClient) CallTool(ctx context.Context, name string, arguments json.RawMessage) (*ToolCallResponse, error)
```

CallTool executes a tool with the given arguments

<a name="StdioClient.Close"></a>
### func \(\*StdioClient\) Close

```go
func (c *StdioClient) Close() error
```

Close terminates the connection to the MCP server

<a name="StdioClient.Initialize"></a>
### func \(\*StdioClient\) Initialize

```go
func (c *StdioClient) Initialize(ctx context.Context) (*InitializeResponse, error)
```

Initialize establishes the MCP connection and negotiates capabilities

<a name="StdioClient.IsAlive"></a>
### func \(\*StdioClient\) IsAlive

```go
func (c *StdioClient) IsAlive() bool
```

IsAlive checks if the connection is still active

<a name="StdioClient.ListTools"></a>
### func \(\*StdioClient\) ListTools

```go
func (c *StdioClient) ListTools(ctx context.Context) ([]Tool, error)
```

ListTools retrieves all available tools from the server

<a name="Tool"></a>
## type Tool

Tool represents an MCP tool definition

```go
type Tool struct {
    Name        string          `json:"name"`
    Description string          `json:"description,omitempty"`
    InputSchema json.RawMessage `json:"inputSchema"` // JSON Schema for tool input
}
```

<a name="ToolCallRequest"></a>
## type ToolCallRequest

ToolCallRequest represents a request to execute a tool

```go
type ToolCallRequest struct {
    Name      string          `json:"name"`
    Arguments json.RawMessage `json:"arguments,omitempty"`
}
```

<a name="ToolCallResponse"></a>
## type ToolCallResponse

ToolCallResponse represents the response from a tool execution

```go
type ToolCallResponse struct {
    Content []Content `json:"content"`
    IsError bool      `json:"isError,omitempty"`
}
```

<a name="ToolsCapability"></a>
## type ToolsCapability

ToolsCapability indicates the server supports tools

```go
type ToolsCapability struct {
    ListChanged bool `json:"listChanged,omitempty"` // Server can send notifications
}
```

<a name="ToolsListRequest"></a>
## type ToolsListRequest

ToolsListRequest represents a request to list available tools

```go
type ToolsListRequest struct {
}
```

<a name="ToolsListResponse"></a>
## type ToolsListResponse

ToolsListResponse represents the response to a tools/list request

```go
type ToolsListResponse struct {
    Tools []Tool `json:"tools"`
}
```

# persistence

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence"
```

Package persistence provides abstract persistence layer for Runtime components.

This package implements the Repository Pattern to decouple Runtime from storage implementations. It provides interfaces for loading prompts, tools, and fragments from various backends \(YAML files, JSON files, memory, packs, etc.\).

## Index

- [type PromptRepository](<#PromptRepository>)
- [type ToolRepository](<#ToolRepository>)


<a name="PromptRepository"></a>
## type PromptRepository

PromptRepository provides abstract access to prompt configurations

```go
type PromptRepository interface {
    // LoadPrompt loads a prompt configuration by task type
    LoadPrompt(taskType string) (*prompt.Config, error)

    // LoadFragment loads a fragment by name and optional path
    LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)

    // ListPrompts returns all available prompt task types
    ListPrompts() ([]string, error)

    // SavePrompt saves a prompt configuration (for future write support)
    SavePrompt(config *prompt.Config) error
}
```

<a name="ToolRepository"></a>
## type ToolRepository

ToolRepository provides abstract access to tool descriptors

```go
type ToolRepository interface {
    // LoadTool loads a tool descriptor by name
    LoadTool(name string) (*tools.ToolDescriptor, error)

    // ListTools returns all available tool names
    ListTools() ([]string, error)

    // SaveTool saves a tool descriptor (for future write support)
    SaveTool(descriptor *tools.ToolDescriptor) error
}
```

# pipeline

```go
import "github.com/AltairaLabs/PromptKit/runtime/pipeline"
```

Package pipeline provides types and configuration for stage\-based pipeline execution. The legacy middleware\-based pipeline has been removed in favor of the stage architecture. See runtime/pipeline/stage for the current implementation.

## Index

- [type Config](<#Config>)
- [type ExecutionResult](<#ExecutionResult>)
- [type ExecutionTrace](<#ExecutionTrace>)
- [type LLMCall](<#LLMCall>)
  - [func \(l \*LLMCall\) GetError\(\) error](<#LLMCall.GetError>)
  - [func \(l \*LLMCall\) SetError\(err error\)](<#LLMCall.SetError>)
- [type MiddlewareConfig](<#MiddlewareConfig>)
- [type ProviderMiddlewareConfig](<#ProviderMiddlewareConfig>)
- [type Response](<#Response>)
- [type RetryPolicy](<#RetryPolicy>)
- [type StateStoreConfig](<#StateStoreConfig>)
- [type TemplateMiddlewareConfig](<#TemplateMiddlewareConfig>)
- [type ToolPolicy](<#ToolPolicy>)
- [type TraceEvent](<#TraceEvent>)
- [type ValidationError](<#ValidationError>)
  - [func \(e \*ValidationError\) Error\(\) string](<#ValidationError.Error>)
- [type ValidatorMiddlewareConfig](<#ValidatorMiddlewareConfig>)


<a name="Config"></a>
## type Config

PipelineConfig represents the complete pipeline configuration for pack format

```go
type Config struct {
    Stages     []string           `json:"stages"`               // Pipeline stages in order
    Middleware []MiddlewareConfig `json:"middleware,omitempty"` // Deprecated: for backward compatibility only
}
```

<a name="ExecutionResult"></a>
## type ExecutionResult

ExecutionResult is the output of a pipeline execution.

```go
type ExecutionResult struct {
    Messages []types.Message        `json:"messages"`  // All messages including history and responses
    Response *Response              `json:"response"`  // The final response
    Trace    ExecutionTrace         `json:"trace"`     // Complete execution trace with all LLM calls
    CostInfo types.CostInfo         `json:"cost_info"` // Aggregate cost across all LLM calls
    Metadata map[string]interface{} `json:"metadata"`  // Metadata populated by stages
}
```

<a name="ExecutionTrace"></a>
## type ExecutionTrace

ExecutionTrace captures the complete execution history of a pipeline run.

```go
type ExecutionTrace struct {
    LLMCalls    []LLMCall    `json:"llm_calls"`              // All LLM API calls made during execution
    Events      []TraceEvent `json:"events,omitempty"`       // Other trace events
    StartedAt   time.Time    `json:"started_at"`             // When pipeline execution started
    CompletedAt *time.Time   `json:"completed_at,omitempty"` // When pipeline execution completed
}
```

<a name="LLMCall"></a>
## type LLMCall

LLMCall represents a single LLM API call within a pipeline execution.

```go
type LLMCall struct {
    Sequence     int                     `json:"sequence"`               // Call number in sequence
    MessageIndex int                     `json:"message_index"`          // Index into messages array
    Request      interface{}             `json:"request,omitempty"`      // Raw request (if debugging enabled)
    Response     interface{}             `json:"response"`               // Parsed response
    RawResponse  interface{}             `json:"raw_response,omitempty"` // Raw provider response
    StartedAt    time.Time               `json:"started_at"`             // When call started
    Duration     time.Duration           `json:"duration"`               // How long the call took
    Cost         types.CostInfo          `json:"cost"`                   // Cost information for this call
    ToolCalls    []types.MessageToolCall `json:"tool_calls,omitempty"`   // If this call triggered tool execution
    Error        *string                 `json:"error,omitempty"`        // Error message if the call failed
}
```

<a name="LLMCall.GetError"></a>
### func \(\*LLMCall\) GetError

```go
func (l *LLMCall) GetError() error
```

GetError returns the error as an error type, or nil if no error occurred.

<a name="LLMCall.SetError"></a>
### func \(\*LLMCall\) SetError

```go
func (l *LLMCall) SetError(err error)
```

SetError sets the error for this LLM call from an error value.

<a name="MiddlewareConfig"></a>
## type MiddlewareConfig

MiddlewareConfig represents configuration for a specific middleware \(deprecated\)

```go
type MiddlewareConfig struct {
    Type   string                 `json:"type"`             // Middleware type
    Config map[string]interface{} `json:"config,omitempty"` // Type-specific configuration
}
```

<a name="ProviderMiddlewareConfig"></a>
## type ProviderMiddlewareConfig

ProviderMiddlewareConfig contains configuration for provider middleware

```go
type ProviderMiddlewareConfig struct {
    RetryPolicy  *RetryPolicy `json:"retry_policy,omitempty"`  // Retry policy
    TimeoutMs    int          `json:"timeout_ms,omitempty"`    // Request timeout in milliseconds
    DisableTrace bool         `json:"disable_trace,omitempty"` // Disable execution tracing
}
```

<a name="Response"></a>
## type Response

Response represents the output from a pipeline execution.

```go
type Response struct {
    Role      string                  `json:"role"`
    Content   string                  `json:"content"`
    ToolCalls []types.MessageToolCall `json:"tool_calls,omitempty"`
}
```

<a name="RetryPolicy"></a>
## type RetryPolicy

RetryPolicy defines retry behavior for provider middleware

```go
type RetryPolicy struct {
    MaxRetries     int    `json:"max_retries"`                // Maximum retry attempts
    Backoff        string `json:"backoff"`                    // Backoff strategy ("fixed", "exponential")
    InitialDelayMs int    `json:"initial_delay_ms,omitempty"` // Initial delay in milliseconds
}
```

<a name="StateStoreConfig"></a>
## type StateStoreConfig

StateStoreConfig contains configuration for state store middleware

```go
type StateStoreConfig struct {
    Store          interface{}            // State store implementation (statestore.Store)
    ConversationID string                 // Unique conversation identifier
    UserID         string                 // User identifier (optional)
    Metadata       map[string]interface{} // Additional metadata to store (optional)
}
```

<a name="TemplateMiddlewareConfig"></a>
## type TemplateMiddlewareConfig

TemplateMiddlewareConfig contains configuration for template middleware

```go
type TemplateMiddlewareConfig struct {
    StrictMode     bool `json:"strict_mode"`     // Fail on undefined variables
    AllowUndefined bool `json:"allow_undefined"` // Allow undefined variables
}
```

<a name="ToolPolicy"></a>
## type ToolPolicy

ToolPolicy defines constraints on tool usage.

```go
type ToolPolicy struct {
    ToolChoice          string   `json:"tool_choice,omitempty"` // "auto", "required", "none", or specific tool name
    MaxRounds           int      `json:"max_rounds,omitempty"`
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="TraceEvent"></a>
## type TraceEvent

TraceEvent represents a significant event during pipeline execution.

```go
type TraceEvent struct {
    Type      string      `json:"type"`              // Event type
    Timestamp time.Time   `json:"timestamp"`         // When the event occurred
    Data      interface{} `json:"data"`              // Event-specific data
    Message   string      `json:"message,omitempty"` // Human-readable description
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a validation failure.

```go
type ValidationError struct {
    Type     string                   `json:"type"`
    Details  string                   `json:"details"`
    Failures []types.ValidationResult `json:"failures"` // All failed validations
}
```

<a name="ValidationError.Error"></a>
### func \(\*ValidationError\) Error

```go
func (e *ValidationError) Error() string
```

Error returns the error message for this validation error.

<a name="ValidatorMiddlewareConfig"></a>
## type ValidatorMiddlewareConfig

ValidatorMiddlewareConfig contains configuration for validator middleware

```go
type ValidatorMiddlewareConfig struct {
    FailFast         bool `json:"fail_fast"`          // Stop on first validation error
    CollectAllErrors bool `json:"collect_all_errors"` // Collect all errors before failing
}
```

# prompt

```go
import "github.com/AltairaLabs/PromptKit/runtime/prompt"
```

Package prompt provides template\-based prompt management and assembly.

This package implements a registry system for loading, caching, and assembling prompt templates via repository interfaces:

- Fragment\-based prompt composition
- Variable substitution with required/optional vars
- Model\-specific overrides \(template modifications only\)
- Tool allowlist integration
- Version tracking and content hashing

The Registry uses the repository pattern to load prompt configs, avoiding direct file I/O. It resolves fragment references, performs template variable substitution, and generates AssembledPrompt objects ready for LLM execution.

### Architecture

For system architecture and design patterns, see:

- Architecture overview: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/architecture.md
- Prompt assembly pipeline: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/prompt-assembly.md
- Repository pattern: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/persistence-layer-proposal.md

### Usage

Create a registry with a repository \(config\-first pattern\):

```
repo := memory.NewRepository()
registry := prompt.NewRegistryWithRepository(repo)
assembled := registry.LoadWithVars("task_type", vars, "gpt-4")
```

See package github.com/AltairaLabs/PromptKit/sdk for higher\-level APIs.

## Index

- [Constants](<#constants>)
- [func ExtractVariablesFromTemplate\(template string\) \[\]string](<#ExtractVariablesFromTemplate>)
- [func GetDefaultPipelineConfig\(\) map\[string\]interface\{\}](<#GetDefaultPipelineConfig>)
- [func GetUsedVars\(vars map\[string\]string\) \[\]string](<#GetUsedVars>)
- [func SupportsMediaType\(config \*MediaConfig, mediaType string\) bool](<#SupportsMediaType>)
- [func ValidateMediaConfig\(config \*MediaConfig\) error](<#ValidateMediaConfig>)
- [type AssembledPrompt](<#AssembledPrompt>)
  - [func \(ap \*AssembledPrompt\) UsesTools\(\) bool](<#AssembledPrompt.UsesTools>)
- [type AudioConfig](<#AudioConfig>)
  - [func GetAudioConfig\(config \*MediaConfig\) \*AudioConfig](<#GetAudioConfig>)
- [type ChangelogEntry](<#ChangelogEntry>)
- [type CompilationInfo](<#CompilationInfo>)
- [type Config](<#Config>)
  - [func ParseConfig\(data \[\]byte\) \(\*Config, error\)](<#ParseConfig>)
  - [func \(c \*Config\) GetAllowedTools\(\) \[\]string](<#Config.GetAllowedTools>)
  - [func \(c \*Config\) GetTaskType\(\) string](<#Config.GetTaskType>)
- [type CostEstimate](<#CostEstimate>)
- [type ExampleContentPart](<#ExampleContentPart>)
- [type ExampleMedia](<#ExampleMedia>)
- [type FileWriter](<#FileWriter>)
- [type Fragment](<#Fragment>)
- [type FragmentRef](<#FragmentRef>)
- [type FragmentRepository](<#FragmentRepository>)
- [type FragmentResolver](<#FragmentResolver>)
  - [func NewFragmentResolverWithRepository\(repository FragmentRepository\) \*FragmentResolver](<#NewFragmentResolverWithRepository>)
  - [func \(fr \*FragmentResolver\) AssembleFragments\(fragments \[\]FragmentRef, vars map\[string\]string, configFilePath string\) \(map\[string\]string, error\)](<#FragmentResolver.AssembleFragments>)
  - [func \(fr \*FragmentResolver\) LoadFragment\(name, relativePath, configFilePath string\) \(\*Fragment, error\)](<#FragmentResolver.LoadFragment>)
- [type ImageConfig](<#ImageConfig>)
  - [func GetImageConfig\(config \*MediaConfig\) \*ImageConfig](<#GetImageConfig>)
- [type Info](<#Info>)
- [type Loader](<#Loader>)
- [type MediaConfig](<#MediaConfig>)
- [type Metadata](<#Metadata>)
- [type MetadataBuilder](<#MetadataBuilder>)
  - [func NewMetadataBuilder\(spec \*Spec\) \*MetadataBuilder](<#NewMetadataBuilder>)
  - [func \(mb \*MetadataBuilder\) AddChangelogEntry\(version, author, description string\)](<#MetadataBuilder.AddChangelogEntry>)
  - [func \(mb \*MetadataBuilder\) BuildCompilationInfo\(compilerVersion string\) \*CompilationInfo](<#MetadataBuilder.BuildCompilationInfo>)
  - [func \(mb \*MetadataBuilder\) BuildMetadata\(domain, language string, tags \[\]string, testResults \[\]TestResultSummary\) \*Metadata](<#MetadataBuilder.BuildMetadata>)
  - [func \(mb \*MetadataBuilder\) SetDomain\(domain string\)](<#MetadataBuilder.SetDomain>)
  - [func \(mb \*MetadataBuilder\) SetLanguage\(language string\)](<#MetadataBuilder.SetLanguage>)
  - [func \(mb \*MetadataBuilder\) SetTags\(tags \[\]string\)](<#MetadataBuilder.SetTags>)
  - [func \(mb \*MetadataBuilder\) UpdateFromCostInfo\(costs \[\]types.CostInfo\)](<#MetadataBuilder.UpdateFromCostInfo>)
  - [func \(mb \*MetadataBuilder\) ValidateMetadata\(\) \[\]string](<#MetadataBuilder.ValidateMetadata>)
- [type ModelOverride](<#ModelOverride>)
- [type ModelTestResultRef](<#ModelTestResultRef>)
  - [func AggregateTestResults\(results \[\]TestResultSummary, provider, model string\) \*ModelTestResultRef](<#AggregateTestResults>)
- [type MultimodalExample](<#MultimodalExample>)
- [type Pack](<#Pack>)
  - [func LoadPack\(filePath string\) \(\*Pack, error\)](<#LoadPack>)
  - [func \(p \*Pack\) GetOptionalVariables\(taskType string\) map\[string\]string](<#Pack.GetOptionalVariables>)
  - [func \(p \*Pack\) GetPrompt\(taskType string\) \*PackPrompt](<#Pack.GetPrompt>)
  - [func \(p \*Pack\) GetRequiredVariables\(taskType string\) \[\]string](<#Pack.GetRequiredVariables>)
  - [func \(p \*Pack\) GetToolNames\(taskType string\) \[\]string](<#Pack.GetToolNames>)
  - [func \(p \*Pack\) ListPrompts\(\) \[\]string](<#Pack.ListPrompts>)
  - [func \(p \*Pack\) Summary\(\) string](<#Pack.Summary>)
  - [func \(p \*Pack\) Validate\(\) \[\]string](<#Pack.Validate>)
- [type PackCompiler](<#PackCompiler>)
  - [func NewPackCompiler\(registry \*Registry\) \*PackCompiler](<#NewPackCompiler>)
  - [func NewPackCompilerWithDeps\(loader Loader, timeProvider TimeProvider, fileWriter FileWriter\) \*PackCompiler](<#NewPackCompilerWithDeps>)
  - [func \(pc \*PackCompiler\) Compile\(taskType, compilerVersion string\) \(\*Pack, error\)](<#PackCompiler.Compile>)
  - [func \(pc \*PackCompiler\) CompileFromRegistry\(packID, compilerVersion string\) \(\*Pack, error\)](<#PackCompiler.CompileFromRegistry>)
  - [func \(pc \*PackCompiler\) CompileFromRegistryWithParsedTools\(packID, compilerVersion string, parsedTools \[\]ParsedTool\) \(\*Pack, error\)](<#PackCompiler.CompileFromRegistryWithParsedTools>)
  - [func \(pc \*PackCompiler\) CompileFromRegistryWithTools\(packID, compilerVersion string, toolData \[\]ToolData\) \(\*Pack, error\)](<#PackCompiler.CompileFromRegistryWithTools>)
  - [func \(pc \*PackCompiler\) CompileToFile\(taskType, outputPath, compilerVersion string\) error](<#PackCompiler.CompileToFile>)
  - [func \(pc \*PackCompiler\) MarshalPack\(pack \*Pack\) \(\[\]byte, error\)](<#PackCompiler.MarshalPack>)
  - [func \(pc \*PackCompiler\) WritePack\(pack \*Pack, outputPath string\) error](<#PackCompiler.WritePack>)
- [type PackPrompt](<#PackPrompt>)
- [type PackTool](<#PackTool>)
  - [func ConvertToolToPackTool\(name, description string, inputSchema json.RawMessage\) \*PackTool](<#ConvertToolToPackTool>)
- [type ParametersPack](<#ParametersPack>)
- [type ParsedTool](<#ParsedTool>)
- [type PerformanceMetrics](<#PerformanceMetrics>)
- [type Registry](<#Registry>)
  - [func NewRegistryWithRepository\(repository Repository\) \*Registry](<#NewRegistryWithRepository>)
  - [func \(r \*Registry\) ClearCache\(\)](<#Registry.ClearCache>)
  - [func \(r \*Registry\) GetAvailableRegions\(\) \[\]string](<#Registry.GetAvailableRegions>)
  - [func \(r \*Registry\) GetAvailableTaskTypes\(\) \[\]string](<#Registry.GetAvailableTaskTypes>)
  - [func \(r \*Registry\) GetCachedFragments\(\) \[\]string](<#Registry.GetCachedFragments>)
  - [func \(r \*Registry\) GetCachedPrompts\(\) \[\]string](<#Registry.GetCachedPrompts>)
  - [func \(r \*Registry\) GetInfo\(taskType string\) \(\*Info, error\)](<#Registry.GetInfo>)
  - [func \(r \*Registry\) GetLoadedFragments\(\) \[\]string](<#Registry.GetLoadedFragments>)
  - [func \(r \*Registry\) GetLoadedPrompts\(\) \[\]string](<#Registry.GetLoadedPrompts>)
  - [func \(r \*Registry\) ListTaskTypes\(\) \[\]string](<#Registry.ListTaskTypes>)
  - [func \(r \*Registry\) Load\(activity string\) \*AssembledPrompt](<#Registry.Load>)
  - [func \(r \*Registry\) LoadConfig\(activity string\) \(\*Config, error\)](<#Registry.LoadConfig>)
  - [func \(r \*Registry\) LoadWithVars\(activity string, vars map\[string\]string, model string\) \*AssembledPrompt](<#Registry.LoadWithVars>)
  - [func \(r \*Registry\) RegisterConfig\(taskType string, config \*Config\) error](<#Registry.RegisterConfig>)
- [type Repository](<#Repository>)
- [type Spec](<#Spec>)
- [type TemplateEngineInfo](<#TemplateEngineInfo>)
- [type TestResultSummary](<#TestResultSummary>)
- [type TimeProvider](<#TimeProvider>)
- [type ToolData](<#ToolData>)
- [type ToolPolicyPack](<#ToolPolicyPack>)
- [type ValidatorConfig](<#ValidatorConfig>)
- [type VariableMetadata](<#VariableMetadata>)
- [type VideoConfig](<#VideoConfig>)
  - [func GetVideoConfig\(config \*MediaConfig\) \*VideoConfig](<#GetVideoConfig>)


## Constants

<a name="PromptPackSchemaURL"></a>PromptPackSchemaURL is the JSON Schema URL for validating PromptPack files

```go
const PromptPackSchemaURL = "https://promptpack.org/schema/latest/promptpack.schema.json"
```

<a name="ExtractVariablesFromTemplate"></a>
## func ExtractVariablesFromTemplate

```go
func ExtractVariablesFromTemplate(template string) []string
```

ExtractVariablesFromTemplate analyzes a template string and extracts variable names This helps auto\-generate variable metadata when not explicitly specified

<a name="GetDefaultPipelineConfig"></a>
## func GetDefaultPipelineConfig

```go
func GetDefaultPipelineConfig() map[string]interface{}
```

GetDefaultPipelineConfig returns the default Arena pipeline configuration Returns as map to avoid import cycle with pipeline package

<a name="GetUsedVars"></a>
## func GetUsedVars

```go
func GetUsedVars(vars map[string]string) []string
```

GetUsedVars returns a list of variable names that had non\-empty values

Deprecated: Use template.GetUsedVars instead

<a name="SupportsMediaType"></a>
## func SupportsMediaType

```go
func SupportsMediaType(config *MediaConfig, mediaType string) bool
```

SupportsMediaType checks if a MediaConfig supports a specific media type

<a name="ValidateMediaConfig"></a>
## func ValidateMediaConfig

```go
func ValidateMediaConfig(config *MediaConfig) error
```

ValidateMediaConfig validates a MediaConfig for correctness and completeness

<a name="AssembledPrompt"></a>
## type AssembledPrompt

AssembledPrompt represents a complete prompt ready for LLM execution.

```go
type AssembledPrompt struct {
    TaskType     string            `json:"task_type"`
    SystemPrompt string            `json:"system_prompt"`
    AllowedTools []string          `json:"allowed_tools,omitempty"` // Tools this prompt can use
    Validators   []ValidatorConfig `json:"validators,omitempty"`    // Validators to apply at runtime
}
```

<a name="AssembledPrompt.UsesTools"></a>
### func \(\*AssembledPrompt\) UsesTools

```go
func (ap *AssembledPrompt) UsesTools() bool
```

UsesTools returns true if this prompt has tools configured

<a name="AudioConfig"></a>
## type AudioConfig

AudioConfig contains audio\-specific configuration

```go
type AudioConfig struct {
    // Maximum audio size in MB (0 = unlimited)
    MaxSizeMB int `yaml:"max_size_mb,omitempty" json:"max_size_mb,omitempty"`
    // Allowed formats: ["mp3", "wav", "ogg", "webm"]
    AllowedFormats []string `yaml:"allowed_formats,omitempty" json:"allowed_formats,omitempty"`
    // Max duration in seconds (0 = unlimited)
    MaxDurationSec int `yaml:"max_duration_sec,omitempty" json:"max_duration_sec,omitempty"`
    // Whether metadata (duration, bitrate) is required
    RequireMetadata bool `yaml:"require_metadata,omitempty" json:"require_metadata,omitempty"`
}
```

<a name="GetAudioConfig"></a>
### func GetAudioConfig

```go
func GetAudioConfig(config *MediaConfig) *AudioConfig
```

GetAudioConfig returns the audio configuration if audio is supported

<a name="ChangelogEntry"></a>
## type ChangelogEntry

ChangelogEntry records a change in the prompt configuration

```go
type ChangelogEntry struct {
    Version     string `yaml:"version"`          // Version number
    Date        string `yaml:"date"`             // Date of change (YYYY-MM-DD)
    Author      string `yaml:"author,omitempty"` // Author of change
    Description string `yaml:"description"`      // Description of change
}
```

<a name="CompilationInfo"></a>
## type CompilationInfo

CompilationInfo contains information about prompt compilation

```go
type CompilationInfo struct {
    CompiledWith string `yaml:"compiled_with" json:"compiled_with"`       // Compiler version
    CreatedAt    string `yaml:"created_at" json:"created_at"`             // Timestamp (RFC3339)
    Schema       string `yaml:"schema,omitempty" json:"schema,omitempty"` // Pack schema version (e.g., "v1")
}
```

<a name="Config"></a>
## type Config

Config represents a YAML prompt configuration file in K8s\-style manifest format

```go
type Config struct {
    APIVersion string            `yaml:"apiVersion" json:"apiVersion"`
    Kind       string            `yaml:"kind" json:"kind"`
    Metadata   metav1.ObjectMeta `yaml:"metadata,omitempty" json:"metadata,omitempty"`
    Spec       Spec              `yaml:"spec" json:"spec"`
}
```

<a name="ParseConfig"></a>
### func ParseConfig

```go
func ParseConfig(data []byte) (*Config, error)
```

ParseConfig parses a prompt config from YAML data. This is a package\-level utility function for parsing prompt configs in the config layer. The config layer should read files using os.ReadFile and pass the data to this function. Returns the parsed Config or an error if parsing/validation fails.

<a name="Config.GetAllowedTools"></a>
### func \(\*Config\) GetAllowedTools

```go
func (c *Config) GetAllowedTools() []string
```

GetAllowedTools returns the allowed tools from the prompt config

<a name="Config.GetTaskType"></a>
### func \(\*Config\) GetTaskType

```go
func (c *Config) GetTaskType() string
```

GetTaskType returns the task type from the prompt config

<a name="CostEstimate"></a>
## type CostEstimate

CostEstimate provides estimated costs for prompt execution

```go
type CostEstimate struct {
    MinCostUSD float64 `yaml:"min_cost_usd"` // Minimum cost per execution
    MaxCostUSD float64 `yaml:"max_cost_usd"` // Maximum cost per execution
    AvgCostUSD float64 `yaml:"avg_cost_usd"` // Average cost per execution
}
```

<a name="ExampleContentPart"></a>
## type ExampleContentPart

ExampleContentPart represents a content part in an example \(simplified for YAML\)

```go
type ExampleContentPart struct {
    // Content type: "text", "image", "audio", "video"
    Type string `yaml:"type" json:"type"`
    // Text content (for type=text)
    Text string `yaml:"text,omitempty" json:"text,omitempty"`
    // For media content
    Media *ExampleMedia `yaml:"media,omitempty" json:"media,omitempty"`
}
```

<a name="ExampleMedia"></a>
## type ExampleMedia

ExampleMedia represents media references in examples

```go
type ExampleMedia struct {
    // Relative path to media file
    FilePath string `yaml:"file_path,omitempty" json:"file_path,omitempty"`
    // External URL
    URL string `yaml:"url,omitempty" json:"url,omitempty"`
    // MIME type
    MIMEType string `yaml:"mime_type" json:"mime_type"`
    // Detail level for images
    Detail string `yaml:"detail,omitempty" json:"detail,omitempty"`
    // Optional caption
    Caption string `yaml:"caption,omitempty" json:"caption,omitempty"`
}
```

<a name="FileWriter"></a>
## type FileWriter

FileWriter abstracts file writing for testing

```go
type FileWriter interface {
    WriteFile(path string, data []byte, perm os.FileMode) error
}
```

<a name="Fragment"></a>
## type Fragment

Fragment represents a reusable prompt fragment

```go
type Fragment struct {
    Type              string `yaml:"fragment_type"`
    Version           string `yaml:"version"`
    Description       string `yaml:"description"`
    Content           string `yaml:"content"`
    SourceFile        string `yaml:"source_file,omitempty"`         // Source file path (for pack compilation)
    ResolvedAtCompile bool   `yaml:"resolved_at_compile,omitempty"` // Whether resolved at compile time
}
```

<a name="FragmentRef"></a>
## type FragmentRef

FragmentRef references a prompt fragment for assembly

```go
type FragmentRef struct {
    Name     string `yaml:"name"`
    Path     string `yaml:"path,omitempty"` // Optional: relative path to fragment file
    Required bool   `yaml:"required"`
}
```

<a name="FragmentRepository"></a>
## type FragmentRepository

FragmentRepository interface for loading fragments \(to avoid import cycles\)

```go
type FragmentRepository interface {
    LoadFragment(name string, relativePath string, baseDir string) (*Fragment, error)
}
```

<a name="FragmentResolver"></a>
## type FragmentResolver

FragmentResolver handles fragment loading, resolution, and variable substitution using the repository pattern

```go
type FragmentResolver struct {
    // contains filtered or unexported fields
}
```

<a name="NewFragmentResolverWithRepository"></a>
### func NewFragmentResolverWithRepository

```go
func NewFragmentResolverWithRepository(repository FragmentRepository) *FragmentResolver
```

NewFragmentResolverWithRepository creates a new fragment resolver with a repository

<a name="FragmentResolver.AssembleFragments"></a>
### func \(\*FragmentResolver\) AssembleFragments

```go
func (fr *FragmentResolver) AssembleFragments(fragments []FragmentRef, vars map[string]string, configFilePath string) (map[string]string, error)
```

AssembleFragments loads and assembles prompt fragments into variables. Resolves dynamic names and paths using the provided variable map.

<a name="FragmentResolver.LoadFragment"></a>
### func \(\*FragmentResolver\) LoadFragment

```go
func (fr *FragmentResolver) LoadFragment(name, relativePath, configFilePath string) (*Fragment, error)
```

LoadFragment loads a fragment from the repository with caching. Uses name as cache key, or path if provided.

<a name="ImageConfig"></a>
## type ImageConfig

ImageConfig contains image\-specific configuration

```go
type ImageConfig struct {
    // Maximum image size in MB (0 = unlimited)
    MaxSizeMB int `yaml:"max_size_mb,omitempty" json:"max_size_mb,omitempty"`
    // Allowed formats: ["jpeg", "png", "webp", "gif"]
    AllowedFormats []string `yaml:"allowed_formats,omitempty" json:"allowed_formats,omitempty"`
    // Default detail level: "low", "high", "auto"
    DefaultDetail string `yaml:"default_detail,omitempty" json:"default_detail,omitempty"`
    // Whether captions are required
    RequireCaption bool `yaml:"require_caption,omitempty" json:"require_caption,omitempty"`
    // Max images per message (0 = unlimited)
    MaxImagesPerMsg int `yaml:"max_images_per_msg,omitempty" json:"max_images_per_msg,omitempty"`
}
```

<a name="GetImageConfig"></a>
### func GetImageConfig

```go
func GetImageConfig(config *MediaConfig) *ImageConfig
```

GetImageConfig returns the image configuration if images are supported

<a name="Info"></a>
## type Info

Info provides summary information about a prompt configuration

```go
type Info struct {
    TaskType       string
    Version        string
    Description    string
    FragmentCount  int
    RequiredVars   []string
    OptionalVars   []string
    ToolAllowlist  []string
    ModelOverrides []string
}
```

<a name="Loader"></a>
## type Loader

Loader interface abstracts the registry for testing

```go
type Loader interface {
    LoadConfig(taskType string) (*Config, error)
    ListTaskTypes() []string
}
```

<a name="MediaConfig"></a>
## type MediaConfig

MediaConfig defines multimodal media support configuration for a prompt

```go
type MediaConfig struct {
    // Enable multimodal support for this prompt
    Enabled bool `yaml:"enabled" json:"enabled"`
    // Supported content types: "image", "audio", "video"
    SupportedTypes []string `yaml:"supported_types,omitempty" json:"supported_types,omitempty"`
    // Image-specific configuration
    Image *ImageConfig `yaml:"image,omitempty" json:"image,omitempty"`
    // Audio-specific configuration
    Audio *AudioConfig `yaml:"audio,omitempty" json:"audio,omitempty"`
    // Video-specific configuration
    Video *VideoConfig `yaml:"video,omitempty" json:"video,omitempty"`
    // Example multimodal messages
    Examples []MultimodalExample `yaml:"examples,omitempty" json:"examples,omitempty"`
}
```

<a name="Metadata"></a>
## type Metadata

Metadata contains additional metadata for the pack format

```go
type Metadata struct {
    Domain       string              `yaml:"domain,omitempty"`        // Domain/category (e.g., "customer-support")
    Language     string              `yaml:"language,omitempty"`      // Primary language (e.g., "en")
    Tags         []string            `yaml:"tags,omitempty"`          // Tags for categorization
    CostEstimate *CostEstimate       `yaml:"cost_estimate,omitempty"` // Estimated cost per execution
    Performance  *PerformanceMetrics `yaml:"performance,omitempty"`   // Performance benchmarks
    Changelog    []ChangelogEntry    `yaml:"changelog,omitempty"`     // Version history
}
```

<a name="MetadataBuilder"></a>
## type MetadataBuilder

MetadataBuilder helps construct pack format metadata from prompt configs and test results

```go
type MetadataBuilder struct {
    // contains filtered or unexported fields
}
```

<a name="NewMetadataBuilder"></a>
### func NewMetadataBuilder

```go
func NewMetadataBuilder(spec *Spec) *MetadataBuilder
```

NewMetadataBuilder creates a new metadata builder for a prompt spec

<a name="MetadataBuilder.AddChangelogEntry"></a>
### func \(\*MetadataBuilder\) AddChangelogEntry

```go
func (mb *MetadataBuilder) AddChangelogEntry(version, author, description string)
```

AddChangelogEntry adds a new entry to the prompt's changelog

<a name="MetadataBuilder.BuildCompilationInfo"></a>
### func \(\*MetadataBuilder\) BuildCompilationInfo

```go
func (mb *MetadataBuilder) BuildCompilationInfo(compilerVersion string) *CompilationInfo
```

BuildCompilationInfo generates compilation metadata

<a name="MetadataBuilder.BuildMetadata"></a>
### func \(\*MetadataBuilder\) BuildMetadata

```go
func (mb *MetadataBuilder) BuildMetadata(domain, language string, tags []string, testResults []TestResultSummary) *Metadata
```

BuildMetadata generates Metadata from test execution results

<a name="MetadataBuilder.SetDomain"></a>
### func \(\*MetadataBuilder\) SetDomain

```go
func (mb *MetadataBuilder) SetDomain(domain string)
```

SetDomain sets the domain for the prompt metadata

<a name="MetadataBuilder.SetLanguage"></a>
### func \(\*MetadataBuilder\) SetLanguage

```go
func (mb *MetadataBuilder) SetLanguage(language string)
```

SetLanguage sets the language for the prompt metadata

<a name="MetadataBuilder.SetTags"></a>
### func \(\*MetadataBuilder\) SetTags

```go
func (mb *MetadataBuilder) SetTags(tags []string)
```

SetTags sets the tags for the prompt metadata

<a name="MetadataBuilder.UpdateFromCostInfo"></a>
### func \(\*MetadataBuilder\) UpdateFromCostInfo

```go
func (mb *MetadataBuilder) UpdateFromCostInfo(costs []types.CostInfo)
```

UpdateFromCostInfo updates cost estimate from types.CostInfo

<a name="MetadataBuilder.ValidateMetadata"></a>
### func \(\*MetadataBuilder\) ValidateMetadata

```go
func (mb *MetadataBuilder) ValidateMetadata() []string
```

ValidateMetadata checks that metadata fields are properly populated

<a name="ModelOverride"></a>
## type ModelOverride

ModelOverride contains model\-specific template modifications. Note: Temperature and MaxTokens should be configured at the scenario or provider level, not in the prompt configuration.

```go
type ModelOverride struct {
    SystemTemplate       string `yaml:"system_template,omitempty"`
    SystemTemplateSuffix string `yaml:"system_template_suffix,omitempty"`
}
```

<a name="ModelTestResultRef"></a>
## type ModelTestResultRef

ModelTestResultRef is a simplified reference to model test results The full ModelTestResult type is in pkg/engine for tracking test execution

```go
type ModelTestResultRef struct {
    Provider     string  `yaml:"provider"`
    Model        string  `yaml:"model"`
    Date         string  `yaml:"date"`
    SuccessRate  float64 `yaml:"success_rate"`
    AvgTokens    int     `yaml:"avg_tokens,omitempty"`
    AvgCost      float64 `yaml:"avg_cost,omitempty"`
    AvgLatencyMs int     `yaml:"avg_latency_ms,omitempty"`
}
```

<a name="AggregateTestResults"></a>
### func AggregateTestResults

```go
func AggregateTestResults(results []TestResultSummary, provider, model string) *ModelTestResultRef
```

AggregateTestResults computes ModelTestResultRef from test execution summaries

<a name="MultimodalExample"></a>
## type MultimodalExample

MultimodalExample represents an example multimodal message for testing/documentation

```go
type MultimodalExample struct {
    // Example name/identifier
    Name string `yaml:"name" json:"name"`
    // Human-readable description
    Description string `yaml:"description,omitempty" json:"description,omitempty"`
    // Message role: "user", "assistant"
    Role string `yaml:"role" json:"role"`
    // Content parts for this example
    Parts []ExampleContentPart `yaml:"parts" json:"parts"`
}
```

<a name="Pack"></a>
## type Pack

Pack represents the complete JSON pack format containing MULTIPLE prompts for different task types.

DESIGN DECISION: Why separate Pack types in runtime vs sdk?

This runtime Pack is optimized for COMPILATION:

- Created by PackCompiler from prompt registry
- Includes Compilation and Metadata for tracking provenance
- Returns validation warnings \(\[\]string\) for compiler feedback
- No thread\-safety needed \(single\-threaded compilation\)
- Simple types \(VariableMetadata, ValidatorConfig\) for JSON serialization

The sdk.Pack is optimized for LOADING & EXECUTION:

- Loaded from .pack.json files for application use
- Includes Tools map and filePath for execution context
- Thread\-safe with sync.RWMutex for concurrent access
- Returns validation errors for application error handling
- Rich types \(\*Variable, \*Validator\) with additional methods
- Has CreateRegistry\(\) to convert back to runtime.Registry for pipeline

Both serialize to/from the SAME JSON format \(.pack.json files\), ensuring full interoperability. The type duplication is intentional and prevents circular dependencies while allowing each module to evolve independently.

See sdk/pack.go for the corresponding SDK\-side documentation.

```go
type Pack struct {
    // Schema reference for validation
    Schema string `json:"$schema,omitempty"` // JSON Schema URL for validation

    // Identity
    ID          string `json:"id"`          // Pack ID (e.g., "customer-support")
    Name        string `json:"name"`        // Human-readable name
    Version     string `json:"version"`     // Pack version
    Description string `json:"description"` // Pack description

    // Template Engine (shared across all prompts in pack)
    TemplateEngine *TemplateEngineInfo `json:"template_engine"`

    // Prompts - Map of task_type -> PackPrompt
    Prompts map[string]*PackPrompt `json:"prompts"`

    // Tools - Map of tool_name -> PackTool (per PromptPack spec Section 9)
    // Tools are defined at pack level and referenced by name in prompts
    Tools map[string]*PackTool `json:"tools,omitempty"`

    // Shared fragments (can be referenced by any prompt)
    Fragments map[string]string `json:"fragments,omitempty"` // Resolved fragments: name -> content

    // Metadata
    Metadata    *Metadata        `json:"metadata,omitempty"`
    Compilation *CompilationInfo `json:"compilation,omitempty"`
}
```

<a name="LoadPack"></a>
### func LoadPack

```go
func LoadPack(filePath string) (*Pack, error)
```

LoadPack loads a pack from a JSON file

<a name="Pack.GetOptionalVariables"></a>
### func \(\*Pack\) GetOptionalVariables

```go
func (p *Pack) GetOptionalVariables(taskType string) map[string]string
```

GetOptionalVariables returns all optional variable names with defaults for a specific prompt

<a name="Pack.GetPrompt"></a>
### func \(\*Pack\) GetPrompt

```go
func (p *Pack) GetPrompt(taskType string) *PackPrompt
```

GetPrompt returns a specific prompt by task type

<a name="Pack.GetRequiredVariables"></a>
### func \(\*Pack\) GetRequiredVariables

```go
func (p *Pack) GetRequiredVariables(taskType string) []string
```

GetRequiredVariables returns all required variable names for a specific prompt

<a name="Pack.GetToolNames"></a>
### func \(\*Pack\) GetToolNames

```go
func (p *Pack) GetToolNames(taskType string) []string
```

GetToolNames returns the list of allowed tool names for a specific prompt

<a name="Pack.ListPrompts"></a>
### func \(\*Pack\) ListPrompts

```go
func (p *Pack) ListPrompts() []string
```

ListPrompts returns all prompt task types in the pack

<a name="Pack.Summary"></a>
### func \(\*Pack\) Summary

```go
func (p *Pack) Summary() string
```

Summary returns a brief summary of the pack

<a name="Pack.Validate"></a>
### func \(\*Pack\) Validate

```go
func (p *Pack) Validate() []string
```

Validate validates a pack format

<a name="PackCompiler"></a>
## type PackCompiler

PackCompiler compiles Config to Pack format

```go
type PackCompiler struct {
    // contains filtered or unexported fields
}
```

<a name="NewPackCompiler"></a>
### func NewPackCompiler

```go
func NewPackCompiler(registry *Registry) *PackCompiler
```

NewPackCompiler creates a new pack compiler with default dependencies

<a name="NewPackCompilerWithDeps"></a>
### func NewPackCompilerWithDeps

```go
func NewPackCompilerWithDeps(loader Loader, timeProvider TimeProvider, fileWriter FileWriter) *PackCompiler
```

NewPackCompilerWithDeps creates a pack compiler with injected dependencies \(for testing\)

<a name="PackCompiler.Compile"></a>
### func \(\*PackCompiler\) Compile

```go
func (pc *PackCompiler) Compile(taskType, compilerVersion string) (*Pack, error)
```

Compile compiles a single prompt config to Pack format \(for backward compatibility\)

<a name="PackCompiler.CompileFromRegistry"></a>
### func \(\*PackCompiler\) CompileFromRegistry

```go
func (pc *PackCompiler) CompileFromRegistry(packID, compilerVersion string) (*Pack, error)
```

CompileFromRegistry compiles ALL prompts from the registry into a single Pack

<a name="PackCompiler.CompileFromRegistryWithParsedTools"></a>
### func \(\*PackCompiler\) CompileFromRegistryWithParsedTools

```go
func (pc *PackCompiler) CompileFromRegistryWithParsedTools(packID, compilerVersion string, parsedTools []ParsedTool) (*Pack, error)
```

CompileFromRegistryWithParsedTools compiles ALL prompts from the registry into a single Pack and includes pre\-parsed tool definitions. Use this when YAML parsing happens externally.

<a name="PackCompiler.CompileFromRegistryWithTools"></a>
### func \(\*PackCompiler\) CompileFromRegistryWithTools

```go
func (pc *PackCompiler) CompileFromRegistryWithTools(packID, compilerVersion string, toolData []ToolData) (*Pack, error)
```

CompileFromRegistryWithTools compiles ALL prompts from the registry into a single Pack and includes tool definitions from the provided tool data. This method satisfies PromptPack spec Section 9 which requires tools to be defined at pack level with name, description, and parameters.

<a name="PackCompiler.CompileToFile"></a>
### func \(\*PackCompiler\) CompileToFile

```go
func (pc *PackCompiler) CompileToFile(taskType, outputPath, compilerVersion string) error
```

CompileToFile compiles a prompt config to a JSON pack file

<a name="PackCompiler.MarshalPack"></a>
### func \(\*PackCompiler\) MarshalPack

```go
func (pc *PackCompiler) MarshalPack(pack *Pack) ([]byte, error)
```

MarshalPack marshals pack to JSON \(testable without I/O\)

<a name="PackCompiler.WritePack"></a>
### func \(\*PackCompiler\) WritePack

```go
func (pc *PackCompiler) WritePack(pack *Pack, outputPath string) error
```

WritePack writes a pack to a file

<a name="PackPrompt"></a>
## type PackPrompt

PackPrompt represents a single prompt configuration within a pack

```go
type PackPrompt struct {
    // Identity
    ID          string `json:"id"`          // Prompt ID (task_type)
    Name        string `json:"name"`        // Human-readable name
    Description string `json:"description"` // Prompt description
    Version     string `json:"version"`     // Prompt version

    // Prompt
    SystemTemplate string `json:"system_template"`

    // Variables
    Variables []VariableMetadata `json:"variables,omitempty"`

    // Tools
    Tools      []string        `json:"tools,omitempty"`       // Allowed tool names
    ToolPolicy *ToolPolicyPack `json:"tool_policy,omitempty"` // Tool usage policy

    // Multimodal media configuration
    MediaConfig *MediaConfig `json:"media,omitempty"`

    // Pipeline
    Pipeline map[string]interface{} `json:"pipeline,omitempty"` // Pipeline configuration

    // Parameters
    Parameters *ParametersPack `json:"parameters,omitempty"` // Model-specific parameters

    // Validators
    Validators []ValidatorConfig `json:"validators,omitempty"`

    // Model Testing
    TestedModels []ModelTestResultRef `json:"tested_models,omitempty"`

    // Model Overrides
    ModelOverrides map[string]ModelOverride `json:"model_overrides,omitempty"`
}
```

<a name="PackTool"></a>
## type PackTool

PackTool represents a tool definition in the pack \(per PromptPack spec Section 9\) Tools are defined at pack level and referenced by prompts via the tools array

```go
type PackTool struct {
    Name        string      `json:"name"`        // Tool function name (required)
    Description string      `json:"description"` // Tool description (required)
    Parameters  interface{} `json:"parameters"`  // JSON Schema for input parameters (required)
}
```

<a name="ConvertToolToPackTool"></a>
### func ConvertToolToPackTool

```go
func ConvertToolToPackTool(name, description string, inputSchema json.RawMessage) *PackTool
```

ConvertToolToPackTool converts a tool descriptor to a PackTool This is the preferred method when tool parsing happens externally

<a name="ParametersPack"></a>
## type ParametersPack

ParametersPack represents model parameters in pack format

```go
type ParametersPack struct {
    Temperature *float64 `json:"temperature,omitempty"`
    MaxTokens   *int     `json:"max_tokens,omitempty"`
    TopP        *float64 `json:"top_p,omitempty"`
    TopK        *int     `json:"top_k,omitempty"`
}
```

<a name="ParsedTool"></a>
## type ParsedTool

ParsedTool holds pre\-parsed tool information for compilation Use this when YAML parsing happens in the calling package

```go
type ParsedTool struct {
    Name        string
    Description string
    InputSchema json.RawMessage
}
```

<a name="PerformanceMetrics"></a>
## type PerformanceMetrics

PerformanceMetrics provides performance benchmarks

```go
type PerformanceMetrics struct {
    AvgLatencyMs int     `yaml:"avg_latency_ms"` // Average latency in milliseconds
    P95LatencyMs int     `yaml:"p95_latency_ms"` // 95th percentile latency
    AvgTokens    int     `yaml:"avg_tokens"`     // Average tokens used
    SuccessRate  float64 `yaml:"success_rate"`   // Success rate (0.0-1.0)
}
```

<a name="Registry"></a>
## type Registry

Registry manages prompt templates, versions, and variable substitution.

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistryWithRepository"></a>
### func NewRegistryWithRepository

```go
func NewRegistryWithRepository(repository Repository) *Registry
```

NewRegistryWithRepository creates a registry with a repository \(new preferred method\). This constructor uses the repository pattern for loading prompts, avoiding direct file I/O.

<a name="Registry.ClearCache"></a>
### func \(\*Registry\) ClearCache

```go
func (r *Registry) ClearCache()
```

ClearCache clears all cached prompts and fragments

<a name="Registry.GetAvailableRegions"></a>
### func \(\*Registry\) GetAvailableRegions

```go
func (r *Registry) GetAvailableRegions() []string
```

GetAvailableRegions returns a list of all available regions from prompt fragments

<a name="Registry.GetAvailableTaskTypes"></a>
### func \(\*Registry\) GetAvailableTaskTypes

```go
func (r *Registry) GetAvailableTaskTypes() []string
```

GetAvailableTaskTypes is deprecated: use ListTaskTypes instead

<a name="Registry.GetCachedFragments"></a>
### func \(\*Registry\) GetCachedFragments

```go
func (r *Registry) GetCachedFragments() []string
```

GetCachedFragments returns a list of currently cached fragment keys.

<a name="Registry.GetCachedPrompts"></a>
### func \(\*Registry\) GetCachedPrompts

```go
func (r *Registry) GetCachedPrompts() []string
```

GetCachedPrompts returns a list of currently cached prompt task types. For a complete list including uncached prompts, use ListTaskTypes instead.

<a name="Registry.GetInfo"></a>
### func \(\*Registry\) GetInfo

```go
func (r *Registry) GetInfo(taskType string) (*Info, error)
```

GetInfo returns detailed information about a prompt configuration

<a name="Registry.GetLoadedFragments"></a>
### func \(\*Registry\) GetLoadedFragments

```go
func (r *Registry) GetLoadedFragments() []string
```

GetLoadedFragments is deprecated: use GetCachedFragments instead

<a name="Registry.GetLoadedPrompts"></a>
### func \(\*Registry\) GetLoadedPrompts

```go
func (r *Registry) GetLoadedPrompts() []string
```

GetLoadedPrompts is deprecated: use GetCachedPrompts instead

<a name="Registry.ListTaskTypes"></a>
### func \(\*Registry\) ListTaskTypes

```go
func (r *Registry) ListTaskTypes() []string
```

ListTaskTypes returns all available task types from the repository. Falls back to cached task types if repository is unavailable or returns empty.

<a name="Registry.Load"></a>
### func \(\*Registry\) Load

```go
func (r *Registry) Load(activity string) *AssembledPrompt
```

Load returns an assembled prompt for the specified activity with variable substitution.

<a name="Registry.LoadConfig"></a>
### func \(\*Registry\) LoadConfig

```go
func (r *Registry) LoadConfig(activity string) (*Config, error)
```

LoadConfig is deprecated: use loadConfig directly \(internal use\) or use Load/LoadWithVars

<a name="Registry.LoadWithVars"></a>
### func \(\*Registry\) LoadWithVars

```go
func (r *Registry) LoadWithVars(activity string, vars map[string]string, model string) *AssembledPrompt
```

LoadWithVars loads a prompt with variable substitution and optional model override.

<a name="Registry.RegisterConfig"></a>
### func \(\*Registry\) RegisterConfig

```go
func (r *Registry) RegisterConfig(taskType string, config *Config) error
```

RegisterConfig registers a Config directly into the registry. This allows programmatic registration of prompts without requiring disk files. Useful for loading prompts from compiled packs or other in\-memory sources. If a repository is configured, the config is persisted there as well.

<a name="Repository"></a>
## type Repository

Repository interface defines methods for loading prompts \(to avoid import cycles\) This should match persistence.Repository interface

```go
type Repository interface {
    LoadPrompt(taskType string) (*Config, error)
    LoadFragment(name string, relativePath string, baseDir string) (*Fragment, error)
    ListPrompts() ([]string, error)
    SavePrompt(config *Config) error
}
```

<a name="Spec"></a>
## type Spec

Spec contains the actual prompt configuration

```go
type Spec struct {
    TaskType       string                   `yaml:"task_type" json:"task_type"`
    Version        string                   `yaml:"version" json:"version"`
    Description    string                   `yaml:"description" json:"description"`
    TemplateEngine *TemplateEngineInfo      `yaml:"template_engine,omitempty" json:"template_engine,omitempty"` // Template engine configuration
    Fragments      []FragmentRef            `yaml:"fragments,omitempty" json:"fragments,omitempty"`             // New: fragment assembly
    SystemTemplate string                   `yaml:"system_template" json:"system_template"`
    Variables      []VariableMetadata       `yaml:"variables,omitempty" json:"variables,omitempty"` // Variable definitions with rich metadata
    ModelOverrides map[string]ModelOverride `yaml:"model_overrides,omitempty" json:"model_overrides,omitempty"`
    AllowedTools   []string                 `yaml:"allowed_tools,omitempty" json:"allowed_tools,omitempty"` // Tools this prompt can use
    MediaConfig    *MediaConfig             `yaml:"media,omitempty" json:"media,omitempty"`                 // Multimodal media configuration
    Validators     []ValidatorConfig        `yaml:"validators,omitempty" json:"validators,omitempty"`       // Validators/Guardrails for production runtime
    TestedModels   []ModelTestResultRef     `yaml:"tested_models,omitempty" json:"tested_models,omitempty"` // Model testing metadata
    Metadata       *Metadata                `yaml:"metadata,omitempty" json:"metadata,omitempty"`           // Additional metadata for pack format
    Compilation    *CompilationInfo         `yaml:"compilation,omitempty" json:"compilation,omitempty"`     // Compilation information
}
```

<a name="TemplateEngineInfo"></a>
## type TemplateEngineInfo

TemplateEngineInfo describes the template engine used for variable substitution

```go
type TemplateEngineInfo struct {
    Version  string   `yaml:"version" json:"version"`                       // Template engine version (e.g., "v1")
    Syntax   string   `yaml:"syntax" json:"syntax"`                         // Template syntax (e.g., "{{variable}}")
    Features []string `yaml:"features,omitempty" json:"features,omitempty"` // Supported features
}
```

<a name="TestResultSummary"></a>
## type TestResultSummary

TestResultSummary contains summarized test execution data

```go
type TestResultSummary struct {
    Success   bool
    Cost      float64
    LatencyMs int
    Tokens    int
}
```

<a name="TimeProvider"></a>
## type TimeProvider

TimeProvider allows injecting time for deterministic tests

```go
type TimeProvider interface {
    Now() time.Time
}
```

<a name="ToolData"></a>
## type ToolData

ToolData holds raw tool configuration data for compilation

```go
type ToolData struct {
    FilePath string
    Data     []byte
}
```

<a name="ToolPolicyPack"></a>
## type ToolPolicyPack

ToolPolicyPack represents tool policy in pack format

```go
type ToolPolicyPack struct {
    ToolChoice          string   `json:"tool_choice,omitempty"`
    MaxRounds           int      `json:"max_rounds,omitempty"`
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="ValidatorConfig"></a>
## type ValidatorConfig

ValidatorConfig extends validators.ValidatorConfig with prompt\-pack specific fields

```go
type ValidatorConfig struct {
    // Embed base config (Type, Params)
    validators.ValidatorConfig `yaml:",inline" json:",inline"`
    // Enable/disable validator (default: true)
    Enabled *bool `yaml:"enabled,omitempty" json:"enabled,omitempty"`
    // Fail execution on violation (default: true)
    FailOnViolation *bool `yaml:"fail_on_violation,omitempty" json:"fail_on_violation,omitempty"`
}
```

<a name="VariableMetadata"></a>
## type VariableMetadata

VariableMetadata contains enhanced metadata for a variable VariableMetadata defines a template variable with validation rules This struct matches the SDK Variable type for PromptPack spec compliance

```go
type VariableMetadata struct {
    Name        string                 `yaml:"name" json:"name"`
    Type        string                 `yaml:"type,omitempty" json:"type,omitempty"` // "string", "number", "boolean", "object", "array"
    Required    bool                   `yaml:"required" json:"required"`
    Default     interface{}            `yaml:"default,omitempty" json:"default,omitempty"`
    Description string                 `yaml:"description,omitempty" json:"description,omitempty"`
    Example     interface{}            `yaml:"example,omitempty" json:"example,omitempty"`
    Validation  map[string]interface{} `yaml:"validation,omitempty" json:"validation,omitempty"`
}
```

<a name="VideoConfig"></a>
## type VideoConfig

VideoConfig contains video\-specific configuration

```go
type VideoConfig struct {
    // Maximum video size in MB (0 = unlimited)
    MaxSizeMB int `yaml:"max_size_mb,omitempty" json:"max_size_mb,omitempty"`
    // Allowed formats: ["mp4", "webm", "ogg"]
    AllowedFormats []string `yaml:"allowed_formats,omitempty" json:"allowed_formats,omitempty"`
    // Max duration in seconds (0 = unlimited)
    MaxDurationSec int `yaml:"max_duration_sec,omitempty" json:"max_duration_sec,omitempty"`
    // Whether metadata (resolution, fps) is required
    RequireMetadata bool `yaml:"require_metadata,omitempty" json:"require_metadata,omitempty"`
}
```

<a name="GetVideoConfig"></a>
### func GetVideoConfig

```go
func GetVideoConfig(config *MediaConfig) *VideoConfig
```

GetVideoConfig returns the video configuration if video is supported

# providers

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers"
```

Package providers implements multi\-LLM provider support with unified interfaces.

Package providers implements multi\-LLM provider support with unified interfaces.

This package provides a common abstraction for predict\-based LLM providers including OpenAI, Anthropic Claude, and Google Gemini. It handles:

- Predict completion requests with streaming support
- Tool/function calling with provider\-specific formats
- Cost tracking and token usage calculation
- Rate limiting and error handling

All providers implement the Provider interface for basic predict, and ToolSupport interface for function calling capabilities.

## Index

- [Constants](<#constants>)
- [func CheckHTTPError\(resp \*http.Response\) error](<#CheckHTTPError>)
- [func ExtractOrderedEmbeddings\[T any\]\(data \[\]T, getIndex func\(T\) int, getEmbedding func\(T\) \[\]float32, expectedCount int\) \(\[\]\[\]float32, error\)](<#ExtractOrderedEmbeddings>)
- [func HasAudioSupport\(p Provider\) bool](<#HasAudioSupport>)
- [func HasImageSupport\(p Provider\) bool](<#HasImageSupport>)
- [func HasVideoSupport\(p Provider\) bool](<#HasVideoSupport>)
- [func IsFormatSupported\(p Provider, contentType, mimeType string\) bool](<#IsFormatSupported>)
- [func IsValidationAbort\(err error\) bool](<#IsValidationAbort>)
- [func LoadFileAsBase64\(filePath string\) \(string, error\)](<#LoadFileAsBase64>)
- [func LogEmbeddingRequest\(provider, model string, textCount int, start time.Time\)](<#LogEmbeddingRequest>)
- [func LogEmbeddingRequestWithTokens\(provider, model string, textCount, tokens int, start time.Time\)](<#LogEmbeddingRequestWithTokens>)
- [func MarshalRequest\(req any\) \(\[\]byte, error\)](<#MarshalRequest>)
- [func RegisterProviderFactory\(providerType string, factory ProviderFactory\)](<#RegisterProviderFactory>)
- [func SetErrorResponse\(predictResp \*PredictionResponse, respBody \[\]byte, start time.Time\)](<#SetErrorResponse>)
- [func StringPtr\(s string\) \*string](<#StringPtr>)
- [func SupportsMultimodal\(p Provider\) bool](<#SupportsMultimodal>)
- [func UnmarshalJSON\(respBody \[\]byte, v interface\{\}, predictResp \*PredictionResponse, start time.Time\) error](<#UnmarshalJSON>)
- [func UnmarshalResponse\(body \[\]byte, resp any\) error](<#UnmarshalResponse>)
- [func ValidateMultimodalMessage\(p Provider, msg types.Message\) error](<#ValidateMultimodalMessage>)
- [func ValidateMultimodalRequest\(p MultimodalSupport, req PredictionRequest\) error](<#ValidateMultimodalRequest>)
- [type AudioStreamingCapabilities](<#AudioStreamingCapabilities>)
- [type BaseEmbeddingProvider](<#BaseEmbeddingProvider>)
  - [func NewBaseEmbeddingProvider\(providerID, defaultModel, defaultBaseURL string, defaultDimensions, defaultBatchSize int, defaultTimeout time.Duration\) \*BaseEmbeddingProvider](<#NewBaseEmbeddingProvider>)
  - [func \(b \*BaseEmbeddingProvider\) DoEmbeddingRequest\(ctx context.Context, cfg HTTPRequestConfig\) \(\[\]byte, error\)](<#BaseEmbeddingProvider.DoEmbeddingRequest>)
  - [func \(b \*BaseEmbeddingProvider\) EmbedWithEmptyCheck\(ctx context.Context, req EmbeddingRequest, embedFn EmbedFunc\) \(EmbeddingResponse, error\)](<#BaseEmbeddingProvider.EmbedWithEmptyCheck>)
  - [func \(b \*BaseEmbeddingProvider\) EmbeddingDimensions\(\) int](<#BaseEmbeddingProvider.EmbeddingDimensions>)
  - [func \(b \*BaseEmbeddingProvider\) EmptyResponseForModel\(model string\) EmbeddingResponse](<#BaseEmbeddingProvider.EmptyResponseForModel>)
  - [func \(b \*BaseEmbeddingProvider\) HandleEmptyRequest\(req EmbeddingRequest\) \(EmbeddingResponse, bool\)](<#BaseEmbeddingProvider.HandleEmptyRequest>)
  - [func \(b \*BaseEmbeddingProvider\) ID\(\) string](<#BaseEmbeddingProvider.ID>)
  - [func \(b \*BaseEmbeddingProvider\) MaxBatchSize\(\) int](<#BaseEmbeddingProvider.MaxBatchSize>)
  - [func \(b \*BaseEmbeddingProvider\) Model\(\) string](<#BaseEmbeddingProvider.Model>)
  - [func \(b \*BaseEmbeddingProvider\) ResolveModel\(reqModel string\) string](<#BaseEmbeddingProvider.ResolveModel>)
- [type BaseProvider](<#BaseProvider>)
  - [func NewBaseProvider\(id string, includeRawOutput bool, client \*http.Client\) BaseProvider](<#NewBaseProvider>)
  - [func NewBaseProviderWithAPIKey\(id string, includeRawOutput bool, primaryKey, fallbackKey string\) \(provider BaseProvider, apiKey string\)](<#NewBaseProviderWithAPIKey>)
  - [func \(b \*BaseProvider\) Close\(\) error](<#BaseProvider.Close>)
  - [func \(b \*BaseProvider\) GetHTTPClient\(\) \*http.Client](<#BaseProvider.GetHTTPClient>)
  - [func \(b \*BaseProvider\) ID\(\) string](<#BaseProvider.ID>)
  - [func \(b \*BaseProvider\) ShouldIncludeRawOutput\(\) bool](<#BaseProvider.ShouldIncludeRawOutput>)
  - [func \(b \*BaseProvider\) SupportsStreaming\(\) bool](<#BaseProvider.SupportsStreaming>)
- [type EmbedFunc](<#EmbedFunc>)
- [type EmbeddingProvider](<#EmbeddingProvider>)
- [type EmbeddingRequest](<#EmbeddingRequest>)
- [type EmbeddingResponse](<#EmbeddingResponse>)
- [type EmbeddingUsage](<#EmbeddingUsage>)
- [type ExecutionResult](<#ExecutionResult>)
- [type HTTPRequestConfig](<#HTTPRequestConfig>)
- [type ImageDetail](<#ImageDetail>)
- [type MediaLoader](<#MediaLoader>)
  - [func NewMediaLoader\(config MediaLoaderConfig\) \*MediaLoader](<#NewMediaLoader>)
  - [func \(ml \*MediaLoader\) GetBase64Data\(ctx context.Context, media \*types.MediaContent\) \(string, error\)](<#MediaLoader.GetBase64Data>)
- [type MediaLoaderConfig](<#MediaLoaderConfig>)
- [type MultimodalCapabilities](<#MultimodalCapabilities>)
- [type MultimodalSupport](<#MultimodalSupport>)
  - [func GetMultimodalProvider\(p Provider\) MultimodalSupport](<#GetMultimodalProvider>)
- [type MultimodalToolSupport](<#MultimodalToolSupport>)
- [type PredictionRequest](<#PredictionRequest>)
- [type PredictionResponse](<#PredictionResponse>)
- [type Pricing](<#Pricing>)
- [type Provider](<#Provider>)
  - [func CreateProviderFromSpec\(spec ProviderSpec\) \(Provider, error\)](<#CreateProviderFromSpec>)
- [type ProviderDefaults](<#ProviderDefaults>)
- [type ProviderFactory](<#ProviderFactory>)
- [type ProviderSpec](<#ProviderSpec>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func \(r \*Registry\) Close\(\) error](<#Registry.Close>)
  - [func \(r \*Registry\) Get\(id string\) \(Provider, bool\)](<#Registry.Get>)
  - [func \(r \*Registry\) List\(\) \[\]string](<#Registry.List>)
  - [func \(r \*Registry\) Register\(provider Provider\)](<#Registry.Register>)
- [type SSEScanner](<#SSEScanner>)
  - [func NewSSEScanner\(r io.Reader\) \*SSEScanner](<#NewSSEScanner>)
  - [func \(s \*SSEScanner\) Data\(\) string](<#SSEScanner.Data>)
  - [func \(s \*SSEScanner\) Err\(\) error](<#SSEScanner.Err>)
  - [func \(s \*SSEScanner\) Scan\(\) bool](<#SSEScanner.Scan>)
- [type StreamChunk](<#StreamChunk>)
- [type StreamEvent](<#StreamEvent>)
- [type StreamInputSession](<#StreamInputSession>)
- [type StreamInputSupport](<#StreamInputSupport>)
- [type StreamObserver](<#StreamObserver>)
- [type StreamingCapabilities](<#StreamingCapabilities>)
- [type StreamingInputConfig](<#StreamingInputConfig>)
  - [func \(r \*StreamingInputConfig\) Validate\(\) error](<#StreamingInputConfig.Validate>)
- [type StreamingToolDefinition](<#StreamingToolDefinition>)
- [type ToolDescriptor](<#ToolDescriptor>)
- [type ToolResponse](<#ToolResponse>)
- [type ToolResponseSupport](<#ToolResponseSupport>)
- [type ToolResult](<#ToolResult>)
- [type ToolSupport](<#ToolSupport>)
- [type UnsupportedContentError](<#UnsupportedContentError>)
  - [func \(e \*UnsupportedContentError\) Error\(\) string](<#UnsupportedContentError.Error>)
- [type UnsupportedProviderError](<#UnsupportedProviderError>)
  - [func \(e \*UnsupportedProviderError\) Error\(\) string](<#UnsupportedProviderError.Error>)
- [type ValidationAbortError](<#ValidationAbortError>)
  - [func \(e \*ValidationAbortError\) Error\(\) string](<#ValidationAbortError.Error>)
- [type VideoResolution](<#VideoResolution>)
  - [func \(r VideoResolution\) String\(\) string](<#VideoResolution.String>)
- [type VideoStreamingCapabilities](<#VideoStreamingCapabilities>)


## Constants

<a name="ContentTypeHeader"></a>Common HTTP constants for embedding providers.

```go
const (
    ContentTypeHeader   = "Content-Type"
    AuthorizationHeader = "Authorization"
    ApplicationJSON     = "application/json"
    BearerPrefix        = "Bearer "
)
```

<a name="CheckHTTPError"></a>
## func CheckHTTPError

```go
func CheckHTTPError(resp *http.Response) error
```

CheckHTTPError checks if HTTP response is an error and returns formatted error with body

<a name="ExtractOrderedEmbeddings"></a>
## func ExtractOrderedEmbeddings

```go
func ExtractOrderedEmbeddings[T any](data []T, getIndex func(T) int, getEmbedding func(T) []float32, expectedCount int) ([][]float32, error)
```

ExtractOrderedEmbeddings extracts embeddings from indexed response data and places them in the correct order. Returns an error if count doesn't match.

<a name="HasAudioSupport"></a>
## func HasAudioSupport

```go
func HasAudioSupport(p Provider) bool
```

HasAudioSupport checks if a provider supports audio inputs

<a name="HasImageSupport"></a>
## func HasImageSupport

```go
func HasImageSupport(p Provider) bool
```

HasImageSupport checks if a provider supports image inputs

<a name="HasVideoSupport"></a>
## func HasVideoSupport

```go
func HasVideoSupport(p Provider) bool
```

HasVideoSupport checks if a provider supports video inputs

<a name="IsFormatSupported"></a>
## func IsFormatSupported

```go
func IsFormatSupported(p Provider, contentType, mimeType string) bool
```

IsFormatSupported checks if a provider supports a specific media format \(MIME type\)

<a name="IsValidationAbort"></a>
## func IsValidationAbort

```go
func IsValidationAbort(err error) bool
```

IsValidationAbort checks if an error is a validation abort

<a name="LoadFileAsBase64"></a>
## func LoadFileAsBase64

```go
func LoadFileAsBase64(filePath string) (string, error)
```

LoadFileAsBase64 reads a file and returns its content as a base64\-encoded string.

Deprecated: Use MediaLoader.GetBase64Data instead for better functionality including storage reference support, URL loading, and proper context handling.

This function is kept for backward compatibility but will be removed in a future version. It now delegates to the new MediaLoader implementation.

<a name="LogEmbeddingRequest"></a>
## func LogEmbeddingRequest

```go
func LogEmbeddingRequest(provider, model string, textCount int, start time.Time)
```

LogEmbeddingRequest logs a completed embedding request with common fields.

<a name="LogEmbeddingRequestWithTokens"></a>
## func LogEmbeddingRequestWithTokens

```go
func LogEmbeddingRequestWithTokens(provider, model string, textCount, tokens int, start time.Time)
```

LogEmbeddingRequestWithTokens logs a completed embedding request with token count.

<a name="MarshalRequest"></a>
## func MarshalRequest

```go
func MarshalRequest(req any) ([]byte, error)
```

MarshalRequest marshals a request body to JSON with standardized error handling.

<a name="RegisterProviderFactory"></a>
## func RegisterProviderFactory

```go
func RegisterProviderFactory(providerType string, factory ProviderFactory)
```

RegisterProviderFactory registers a factory function for a provider type

<a name="SetErrorResponse"></a>
## func SetErrorResponse

```go
func SetErrorResponse(predictResp *PredictionResponse, respBody []byte, start time.Time)
```

SetErrorResponse sets latency and raw body on error responses

<a name="StringPtr"></a>
## func StringPtr

```go
func StringPtr(s string) *string
```

StringPtr is a helper function that returns a pointer to a string. This is commonly used across provider implementations for optional fields.

<a name="SupportsMultimodal"></a>
## func SupportsMultimodal

```go
func SupportsMultimodal(p Provider) bool
```

SupportsMultimodal checks if a provider implements multimodal support

<a name="UnmarshalJSON"></a>
## func UnmarshalJSON

```go
func UnmarshalJSON(respBody []byte, v interface{}, predictResp *PredictionResponse, start time.Time) error
```

UnmarshalJSON unmarshals JSON with error recovery that sets latency and raw response

<a name="UnmarshalResponse"></a>
## func UnmarshalResponse

```go
func UnmarshalResponse(body []byte, resp any) error
```

UnmarshalResponse unmarshals a response body from JSON with standardized error handling.

<a name="ValidateMultimodalMessage"></a>
## func ValidateMultimodalMessage

```go
func ValidateMultimodalMessage(p Provider, msg types.Message) error
```

ValidateMultimodalMessage checks if a message's multimodal content is supported by the provider

<a name="ValidateMultimodalRequest"></a>
## func ValidateMultimodalRequest

```go
func ValidateMultimodalRequest(p MultimodalSupport, req PredictionRequest) error
```

ValidateMultimodalRequest validates all messages in a predict request for multimodal compatibility This is a helper function to reduce duplication across provider implementations

<a name="AudioStreamingCapabilities"></a>
## type AudioStreamingCapabilities

AudioStreamingCapabilities describes audio streaming support.

```go
type AudioStreamingCapabilities struct {
    // SupportedEncodings lists supported audio encodings
    // Common values: "pcm", "opus", "mp3", "aac"
    SupportedEncodings []string `json:"supported_encodings"`

    // SupportedSampleRates lists supported sample rates in Hz
    // Common values: 8000, 16000, 24000, 44100, 48000
    SupportedSampleRates []int `json:"supported_sample_rates"`

    // SupportedChannels lists supported channel counts
    // Common values: 1 (mono), 2 (stereo)
    SupportedChannels []int `json:"supported_channels"`

    // SupportedBitDepths lists supported bit depths
    // Common values: 16, 24, 32
    SupportedBitDepths []int `json:"supported_bit_depths,omitempty"`

    // PreferredEncoding is the recommended encoding for best quality/latency
    PreferredEncoding string `json:"preferred_encoding"`

    // PreferredSampleRate is the recommended sample rate
    PreferredSampleRate int `json:"preferred_sample_rate"`
}
```

<a name="BaseEmbeddingProvider"></a>
## type BaseEmbeddingProvider

BaseEmbeddingProvider provides common functionality for embedding providers. Embed this struct in provider\-specific implementations to reduce duplication.

```go
type BaseEmbeddingProvider struct {
    ProviderModel string
    BaseURL       string
    APIKey        string
    HTTPClient    *http.Client
    Dimensions    int
    ProviderID    string
    BatchSize     int
}
```

<a name="NewBaseEmbeddingProvider"></a>
### func NewBaseEmbeddingProvider

```go
func NewBaseEmbeddingProvider(providerID, defaultModel, defaultBaseURL string, defaultDimensions, defaultBatchSize int, defaultTimeout time.Duration) *BaseEmbeddingProvider
```

NewBaseEmbeddingProvider creates a base embedding provider with defaults.

<a name="BaseEmbeddingProvider.DoEmbeddingRequest"></a>
### func \(\*BaseEmbeddingProvider\) DoEmbeddingRequest

```go
func (b *BaseEmbeddingProvider) DoEmbeddingRequest(ctx context.Context, cfg HTTPRequestConfig) ([]byte, error)
```

DoEmbeddingRequest performs a common HTTP POST request for embeddings. Returns the response body and any error.

<a name="BaseEmbeddingProvider.EmbedWithEmptyCheck"></a>
### func \(\*BaseEmbeddingProvider\) EmbedWithEmptyCheck

```go
func (b *BaseEmbeddingProvider) EmbedWithEmptyCheck(ctx context.Context, req EmbeddingRequest, embedFn EmbedFunc) (EmbeddingResponse, error)
```

EmbedWithEmptyCheck wraps embedding logic with empty request handling.

<a name="BaseEmbeddingProvider.EmbeddingDimensions"></a>
### func \(\*BaseEmbeddingProvider\) EmbeddingDimensions

```go
func (b *BaseEmbeddingProvider) EmbeddingDimensions() int
```

EmbeddingDimensions returns the dimensionality of embedding vectors.

<a name="BaseEmbeddingProvider.EmptyResponseForModel"></a>
### func \(\*BaseEmbeddingProvider\) EmptyResponseForModel

```go
func (b *BaseEmbeddingProvider) EmptyResponseForModel(model string) EmbeddingResponse
```

EmptyResponseForModel returns an empty EmbeddingResponse with the given model. Use this for handling empty input cases.

<a name="BaseEmbeddingProvider.HandleEmptyRequest"></a>
### func \(\*BaseEmbeddingProvider\) HandleEmptyRequest

```go
func (b *BaseEmbeddingProvider) HandleEmptyRequest(req EmbeddingRequest) (EmbeddingResponse, bool)
```

HandleEmptyRequest checks if the request has no texts and returns early if so. Returns \(response, true\) if empty, \(zero, false\) if not empty.

<a name="BaseEmbeddingProvider.ID"></a>
### func \(\*BaseEmbeddingProvider\) ID

```go
func (b *BaseEmbeddingProvider) ID() string
```

ID returns the provider identifier.

<a name="BaseEmbeddingProvider.MaxBatchSize"></a>
### func \(\*BaseEmbeddingProvider\) MaxBatchSize

```go
func (b *BaseEmbeddingProvider) MaxBatchSize() int
```

MaxBatchSize returns the maximum texts per single API request.

<a name="BaseEmbeddingProvider.Model"></a>
### func \(\*BaseEmbeddingProvider\) Model

```go
func (b *BaseEmbeddingProvider) Model() string
```

Model returns the current embedding model.

<a name="BaseEmbeddingProvider.ResolveModel"></a>
### func \(\*BaseEmbeddingProvider\) ResolveModel

```go
func (b *BaseEmbeddingProvider) ResolveModel(reqModel string) string
```

ResolveModel returns the model to use, preferring the request model over the default.

<a name="BaseProvider"></a>
## type BaseProvider

BaseProvider provides common functionality shared across all provider implementations. It should be embedded in concrete provider structs to avoid code duplication.

```go
type BaseProvider struct {
    // contains filtered or unexported fields
}
```

<a name="NewBaseProvider"></a>
### func NewBaseProvider

```go
func NewBaseProvider(id string, includeRawOutput bool, client *http.Client) BaseProvider
```

NewBaseProvider creates a new BaseProvider with common fields

<a name="NewBaseProviderWithAPIKey"></a>
### func NewBaseProviderWithAPIKey

```go
func NewBaseProviderWithAPIKey(id string, includeRawOutput bool, primaryKey, fallbackKey string) (provider BaseProvider, apiKey string)
```

NewBaseProviderWithAPIKey creates a BaseProvider and retrieves API key from environment It tries the primary key first, then falls back to the secondary key if primary is empty.

<a name="BaseProvider.Close"></a>
### func \(\*BaseProvider\) Close

```go
func (b *BaseProvider) Close() error
```

Close closes the HTTP client's idle connections

<a name="BaseProvider.GetHTTPClient"></a>
### func \(\*BaseProvider\) GetHTTPClient

```go
func (b *BaseProvider) GetHTTPClient() *http.Client
```

GetHTTPClient returns the underlying HTTP client for provider\-specific use

<a name="BaseProvider.ID"></a>
### func \(\*BaseProvider\) ID

```go
func (b *BaseProvider) ID() string
```

ID returns the provider ID

<a name="BaseProvider.ShouldIncludeRawOutput"></a>
### func \(\*BaseProvider\) ShouldIncludeRawOutput

```go
func (b *BaseProvider) ShouldIncludeRawOutput() bool
```

ShouldIncludeRawOutput returns whether to include raw API responses in output

<a name="BaseProvider.SupportsStreaming"></a>
### func \(\*BaseProvider\) SupportsStreaming

```go
func (b *BaseProvider) SupportsStreaming() bool
```

SupportsStreaming returns true by default \(can be overridden by providers that don't support streaming\)

<a name="EmbedFunc"></a>
## type EmbedFunc

EmbedFunc is the signature for provider\-specific embedding logic.

```go
type EmbedFunc func(ctx context.Context, texts []string, model string) (EmbeddingResponse, error)
```

<a name="EmbeddingProvider"></a>
## type EmbeddingProvider

EmbeddingProvider generates text embeddings for semantic similarity operations. Implementations exist for OpenAI, Gemini, and other embedding APIs.

Embeddings are dense vector representations of text that capture semantic meaning. Similar texts will have embeddings with high cosine similarity scores.

Example usage:

```
provider, _ := openai.NewEmbeddingProvider()
resp, err := provider.Embed(ctx, providers.EmbeddingRequest{
    Texts: []string{"Hello world", "Hi there"},
})
similarity := CosineSimilarity(resp.Embeddings[0], resp.Embeddings[1])
```

```go
type EmbeddingProvider interface {
    // Embed generates embeddings for the given texts.
    // The response contains one embedding vector per input text, in the same order.
    // Implementations should handle batching internally if the request exceeds MaxBatchSize.
    Embed(ctx context.Context, req EmbeddingRequest) (EmbeddingResponse, error)

    // EmbeddingDimensions returns the dimensionality of embedding vectors.
    // Common values: 1536 (OpenAI ada-002/3-small), 768 (Gemini), 3072 (OpenAI 3-large)
    EmbeddingDimensions() int

    // MaxBatchSize returns the maximum number of texts per single API request.
    // Callers should batch requests appropriately, or rely on the provider
    // to handle splitting internally.
    MaxBatchSize() int

    // ID returns the provider identifier (e.g., "openai-embedding", "gemini-embedding")
    ID() string
}
```

<a name="EmbeddingRequest"></a>
## type EmbeddingRequest

EmbeddingRequest represents a request for text embeddings.

```go
type EmbeddingRequest struct {
    // Texts to embed (batched for efficiency)
    Texts []string

    // Model override for embedding model (optional, uses provider default if empty)
    Model string
}
```

<a name="EmbeddingResponse"></a>
## type EmbeddingResponse

EmbeddingResponse contains the embedding vectors from a provider.

```go
type EmbeddingResponse struct {
    // Embeddings contains one vector per input text, in the same order
    Embeddings [][]float32

    // Model is the model that was used for embedding
    Model string

    // Usage contains token consumption information (optional)
    Usage *EmbeddingUsage
}
```

<a name="EmbeddingUsage"></a>
## type EmbeddingUsage

EmbeddingUsage tracks token consumption for embedding requests.

```go
type EmbeddingUsage struct {
    // TotalTokens is the total number of tokens processed
    TotalTokens int
}
```

<a name="ExecutionResult"></a>
## type ExecutionResult

ExecutionResult is a forward declaration to avoid circular import.

```go
type ExecutionResult interface{}
```

<a name="HTTPRequestConfig"></a>
## type HTTPRequestConfig

HTTPRequestConfig configures how to make an HTTP request.

```go
type HTTPRequestConfig struct {
    URL         string
    Body        []byte
    UseAPIKey   bool   // If true, adds Authorization: Bearer <APIKey> header
    ContentType string // Defaults to application/json
}
```

<a name="ImageDetail"></a>
## type ImageDetail

ImageDetail specifies the level of detail for image processing

```go
type ImageDetail string
```

<a name="ImageDetailLow"></a>Image detail levels for multimodal processing.

```go
const (
    ImageDetailLow  ImageDetail = "low"  // Faster, less detailed analysis
    ImageDetailHigh ImageDetail = "high" // Slower, more detailed analysis
    ImageDetailAuto ImageDetail = "auto" // Provider chooses automatically
)
```

<a name="MediaLoader"></a>
## type MediaLoader

MediaLoader handles loading media content from various sources \(inline data, files, URLs, storage\). It provides a unified interface for providers to access media regardless of the source.

```go
type MediaLoader struct {
    // contains filtered or unexported fields
}
```

<a name="NewMediaLoader"></a>
### func NewMediaLoader

```go
func NewMediaLoader(config MediaLoaderConfig) *MediaLoader
```

NewMediaLoader creates a new MediaLoader with the given configuration.

<a name="MediaLoader.GetBase64Data"></a>
### func \(\*MediaLoader\) GetBase64Data

```go
func (ml *MediaLoader) GetBase64Data(ctx context.Context, media *types.MediaContent) (string, error)
```

GetBase64Data loads media content and returns it as base64\-encoded data. It handles all media sources: inline data, file paths, URLs, and storage references.

<a name="MediaLoaderConfig"></a>
## type MediaLoaderConfig

MediaLoaderConfig configures the MediaLoader behavior.

```go
type MediaLoaderConfig struct {
    // StorageService is optional - required only for loading from storage references
    StorageService storage.MediaStorageService

    // HTTPTimeout for URL fetching (default: 30s)
    HTTPTimeout time.Duration

    // MaxURLSizeBytes is the maximum size for URL-based media (default: 50MB)
    MaxURLSizeBytes int64
}
```

<a name="MultimodalCapabilities"></a>
## type MultimodalCapabilities

MultimodalCapabilities describes what types of multimodal content a provider supports

```go
type MultimodalCapabilities struct {
    SupportsImages bool     // Provider can process image inputs
    SupportsAudio  bool     // Provider can process audio inputs
    SupportsVideo  bool     // Provider can process video inputs
    ImageFormats   []string // Supported image MIME types (e.g., "image/jpeg", "image/png")
    AudioFormats   []string // Supported audio MIME types (e.g., "audio/mpeg", "audio/wav")
    VideoFormats   []string // Supported video MIME types (e.g., "video/mp4")
    MaxImageSizeMB int      // Maximum image size in megabytes (0 = unlimited/unknown)
    MaxAudioSizeMB int      // Maximum audio size in megabytes (0 = unlimited/unknown)
    MaxVideoSizeMB int      // Maximum video size in megabytes (0 = unlimited/unknown)
}
```

<a name="MultimodalSupport"></a>
## type MultimodalSupport

MultimodalSupport interface for providers that support multimodal inputs

```go
type MultimodalSupport interface {
    Provider // Extends the base Provider interface

    // GetMultimodalCapabilities returns what types of multimodal content this provider supports
    GetMultimodalCapabilities() MultimodalCapabilities

    // PredictMultimodal performs a predict request with multimodal message content
    // Messages in the request can contain Parts with images, audio, or video
    PredictMultimodal(ctx context.Context, req PredictionRequest) (PredictionResponse, error)

    // PredictMultimodalStream performs a streaming predict request with multimodal content
    PredictMultimodalStream(ctx context.Context, req PredictionRequest) (<-chan StreamChunk, error)
}
```

<a name="GetMultimodalProvider"></a>
### func GetMultimodalProvider

```go
func GetMultimodalProvider(p Provider) MultimodalSupport
```

GetMultimodalProvider safely casts a provider to MultimodalSupport Returns nil if the provider doesn't support multimodal

<a name="MultimodalToolSupport"></a>
## type MultimodalToolSupport

MultimodalToolSupport interface for providers that support both multimodal and tools

```go
type MultimodalToolSupport interface {
    MultimodalSupport // Extends multimodal support
    ToolSupport       // Extends tool support

    // PredictMultimodalWithTools performs a predict request with both multimodal content and tools
    PredictMultimodalWithTools(ctx context.Context, req PredictionRequest, tools interface{}, toolChoice string) (PredictionResponse, []types.MessageToolCall, error)
}
```

<a name="PredictionRequest"></a>
## type PredictionRequest

PredictionRequest represents a request to a predict provider

```go
type PredictionRequest struct {
    System      string                 `json:"system"`
    Messages    []types.Message        `json:"messages"`
    Temperature float32                `json:"temperature"`
    TopP        float32                `json:"top_p"`
    MaxTokens   int                    `json:"max_tokens"`
    Seed        *int                   `json:"seed,omitempty"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"` // Optional metadata for provider-specific context
}
```

<a name="PredictionResponse"></a>
## type PredictionResponse

PredictionResponse represents a response from a predict provider

```go
type PredictionResponse struct {
    Content    string                  `json:"content"`
    Parts      []types.ContentPart     `json:"parts,omitempty"`     // Multimodal content parts (text, image, audio, video)
    CostInfo   *types.CostInfo         `json:"cost_info,omitempty"` // Cost breakdown for this response (includes token counts)
    Latency    time.Duration           `json:"latency"`
    Raw        []byte                  `json:"raw,omitempty"`
    RawRequest interface{}             `json:"raw_request,omitempty"` // Raw API request (for debugging)
    ToolCalls  []types.MessageToolCall `json:"tool_calls,omitempty"`  // Tools called in this response
}
```

<a name="Pricing"></a>
## type Pricing

Pricing defines cost per 1K tokens for input and output

```go
type Pricing struct {
    InputCostPer1K  float64
    OutputCostPer1K float64
}
```

<a name="Provider"></a>
## type Provider

Provider interface defines the contract for predict providers

```go
type Provider interface {
    ID() string

    Predict(ctx context.Context, req PredictionRequest) (PredictionResponse, error)

    // Streaming support
    PredictStream(ctx context.Context, req PredictionRequest) (<-chan StreamChunk, error)

    SupportsStreaming() bool

    ShouldIncludeRawOutput() bool

    Close() error // Close cleans up provider resources (e.g., HTTP connections)

    // CalculateCost calculates cost breakdown for given token counts
    CalculateCost(inputTokens, outputTokens, cachedTokens int) types.CostInfo
}
```

<a name="CreateProviderFromSpec"></a>
### func CreateProviderFromSpec

```go
func CreateProviderFromSpec(spec ProviderSpec) (Provider, error)
```

CreateProviderFromSpec creates a provider implementation from a spec. Returns an error if the provider type is unsupported.

<a name="ProviderDefaults"></a>
## type ProviderDefaults

ProviderDefaults holds default parameters for providers

```go
type ProviderDefaults struct {
    Temperature float32
    TopP        float32
    MaxTokens   int
    Pricing     Pricing
}
```

<a name="ProviderFactory"></a>
## type ProviderFactory

ProviderFactory is a function that creates a provider from a spec

```go
type ProviderFactory func(spec ProviderSpec) (Provider, error)
```

<a name="ProviderSpec"></a>
## type ProviderSpec

ProviderSpec holds the configuration needed to create a provider instance

```go
type ProviderSpec struct {
    ID               string
    Type             string
    Model            string
    BaseURL          string
    Defaults         ProviderDefaults
    IncludeRawOutput bool
    AdditionalConfig map[string]interface{} // Flexible key-value pairs for provider-specific configuration
}
```

<a name="Registry"></a>
## type Registry

Registry manages available providers

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new provider registry

<a name="Registry.Close"></a>
### func \(\*Registry\) Close

```go
func (r *Registry) Close() error
```

Close closes all registered providers and cleans up their resources. Returns the first error encountered, if any.

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(id string) (Provider, bool)
```

Get retrieves a provider by ID, returning the provider and a boolean indicating if it was found.

<a name="Registry.List"></a>
### func \(\*Registry\) List

```go
func (r *Registry) List() []string
```

List returns all registered provider IDs

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(provider Provider)
```

Register adds a provider to the registry using its ID as the key.

<a name="SSEScanner"></a>
## type SSEScanner

SSEScanner scans Server\-Sent Events \(SSE\) streams

```go
type SSEScanner struct {
    // contains filtered or unexported fields
}
```

<a name="NewSSEScanner"></a>
### func NewSSEScanner

```go
func NewSSEScanner(r io.Reader) *SSEScanner
```

NewSSEScanner creates a new SSE scanner

<a name="SSEScanner.Data"></a>
### func \(\*SSEScanner\) Data

```go
func (s *SSEScanner) Data() string
```

Data returns the current event data

<a name="SSEScanner.Err"></a>
### func \(\*SSEScanner\) Err

```go
func (s *SSEScanner) Err() error
```

Err returns any scanning error

<a name="SSEScanner.Scan"></a>
### func \(\*SSEScanner\) Scan

```go
func (s *SSEScanner) Scan() bool
```

Scan advances to the next SSE event

<a name="StreamChunk"></a>
## type StreamChunk

StreamChunk represents a batch of tokens with metadata

```go
type StreamChunk struct {
    // Content is the accumulated content so far
    Content string `json:"content"`

    // Delta is the new content in this chunk
    Delta string `json:"delta"`

    // MediaDelta contains new media content in this chunk (audio, video, images)
    // Uses the same MediaContent type as non-streaming messages for API consistency.
    MediaDelta *types.MediaContent `json:"media_delta,omitempty"`

    // TokenCount is the total number of tokens so far
    TokenCount int `json:"token_count"`

    // DeltaTokens is the number of tokens in this delta
    DeltaTokens int `json:"delta_tokens"`

    // ToolCalls contains accumulated tool calls (for assistant messages that invoke tools)
    ToolCalls []types.MessageToolCall `json:"tool_calls,omitempty"`

    // FinishReason is nil until stream is complete
    // Values: "stop", "length", "content_filter", "tool_calls", "error", "validation_failed", "cancelled"
    FinishReason *string `json:"finish_reason,omitempty"`

    // Interrupted indicates the response was interrupted (e.g., user started speaking)
    // When true, clients should clear any buffered audio and prepare for a new response
    Interrupted bool `json:"interrupted,omitempty"`

    // Error is set if an error occurred during streaming
    Error error `json:"error,omitempty"`

    // Metadata contains provider-specific metadata
    Metadata map[string]interface{} `json:"metadata,omitempty"`

    // FinalResult contains the complete execution result (only set in the final chunk)
    FinalResult ExecutionResult `json:"final_result,omitempty"`

    // CostInfo contains cost breakdown (only present in final chunk when FinishReason != nil)
    CostInfo *types.CostInfo `json:"cost_info,omitempty"`
}
```

<a name="StreamEvent"></a>
## type StreamEvent

StreamEvent is sent to observers for monitoring

```go
type StreamEvent struct {
    // Type is the event type: "chunk", "complete", "error"
    Type string `json:"type"`

    // Chunk contains the stream chunk data
    Chunk *StreamChunk `json:"chunk,omitempty"`

    // Error is set for error events
    Error error `json:"error,omitempty"`

    // Timestamp is when the event occurred
    Timestamp time.Time `json:"timestamp"`
}
```

<a name="StreamInputSession"></a>
## type StreamInputSession

StreamInputSession manages a bidirectional streaming session with a provider. The session allows sending media chunks \(e.g., audio from a microphone\) and receiving streaming responses from the LLM.

Example usage:

```
session, err := provider.CreateStreamSession(ctx, StreamInputRequest{
    Config: types.StreamingMediaConfig{
        Type:       types.ContentTypeAudio,
        ChunkSize:  8192,
        SampleRate: 16000,
        Encoding:   "pcm",
        Channels:   1,
    },
})
if err != nil {
    return err
}
defer session.Close()

// Send audio chunks in a goroutine
go func() {
    for chunk := range micInput {
        if err := session.SendChunk(ctx, chunk); err != nil {
            log.Printf("send error: %v", err)
            break
        }
    }
}()

// Receive responses
for chunk := range session.Response() {
    if chunk.Error != nil {
        log.Printf("response error: %v", chunk.Error)
        break
    }
    fmt.Print(chunk.Delta)
}
```

```go
type StreamInputSession interface {
    // SendChunk sends a media chunk to the provider.
    // Returns an error if the chunk cannot be sent or the session is closed.
    // This method is safe to call from multiple goroutines.
    SendChunk(ctx context.Context, chunk *types.MediaChunk) error

    // SendText sends a text message to the provider during the streaming session.
    // This is useful for sending text prompts or instructions during audio streaming.
    // Note: This marks the turn as complete, triggering a response.
    SendText(ctx context.Context, text string) error

    // SendSystemContext sends a text message as context without completing the turn.
    // Use this for system prompts that provide context but shouldn't trigger an immediate response.
    // The audio/text that follows will be processed with this context in mind.
    SendSystemContext(ctx context.Context, text string) error

    // Response returns a receive-only channel for streaming responses.
    // The channel is closed when the session ends or encounters an error.
    // Consumers should read from this channel in a separate goroutine.
    Response() <-chan StreamChunk

    // Close ends the streaming session and releases resources.
    // After calling Close, SendChunk and SendText will return errors.
    // The Response channel will be closed.
    // Close is safe to call multiple times.
    Close() error

    // Error returns any error that occurred during the session.
    // Returns nil if no error has occurred.
    Error() error

    // Done returns a channel that's closed when the session ends.
    // This is useful for select statements to detect session completion.
    Done() <-chan struct{}
}
```

<a name="StreamInputSupport"></a>
## type StreamInputSupport

StreamInputSupport extends the Provider interface for bidirectional streaming. Providers that implement this interface can handle streaming media input \(e.g., real\-time audio\) and provide streaming responses.

```go
type StreamInputSupport interface {
    Provider // Extends the base Provider interface

    // CreateStreamSession creates a new bidirectional streaming session.
    // The session remains active until Close() is called or an error occurs.
    // Returns an error if the provider doesn't support the requested media type.
    CreateStreamSession(ctx context.Context, req *StreamingInputConfig) (StreamInputSession, error)

    // SupportsStreamInput returns the media types supported for streaming input.
    // Common values: types.ContentTypeAudio, types.ContentTypeVideo
    SupportsStreamInput() []string

    // GetStreamingCapabilities returns detailed information about streaming support.
    // This includes supported codecs, sample rates, and other constraints.
    GetStreamingCapabilities() StreamingCapabilities
}
```

<a name="StreamObserver"></a>
## type StreamObserver

StreamObserver receives stream events for monitoring

```go
type StreamObserver interface {
    OnChunk(chunk StreamChunk)
    OnComplete(totalTokens int, duration time.Duration)
    OnError(err error)
}
```

<a name="StreamingCapabilities"></a>
## type StreamingCapabilities

StreamingCapabilities describes what streaming features a provider supports.

```go
type StreamingCapabilities struct {
    // SupportedMediaTypes lists the media types that can be streamed
    // Values: types.ContentTypeAudio, types.ContentTypeVideo
    SupportedMediaTypes []string `json:"supported_media_types"`

    // Audio capabilities
    Audio *AudioStreamingCapabilities `json:"audio,omitempty"`

    // Video capabilities
    Video *VideoStreamingCapabilities `json:"video,omitempty"`

    // BidirectionalSupport indicates if the provider supports full bidirectional streaming
    BidirectionalSupport bool `json:"bidirectional_support"`

    // MaxSessionDuration is the maximum duration for a streaming session (in seconds)
    // Zero means no limit
    MaxSessionDuration int `json:"max_session_duration,omitempty"`

    // MinChunkSize is the minimum chunk size in bytes
    MinChunkSize int `json:"min_chunk_size,omitempty"`

    // MaxChunkSize is the maximum chunk size in bytes
    MaxChunkSize int `json:"max_chunk_size,omitempty"`
}
```

<a name="StreamingInputConfig"></a>
## type StreamingInputConfig

StreamingInputConfig configures a new streaming input session.

```go
type StreamingInputConfig struct {
    // Config specifies the media streaming configuration (codec, sample rate, etc.)
    Config types.StreamingMediaConfig `json:"config"`

    // SystemInstruction is the system prompt to configure the model's behavior.
    // For Gemini Live API, this is included in the setup message.
    SystemInstruction string `json:"system_instruction,omitempty"`

    // Tools defines functions the model can call during the session.
    // When configured, the model returns structured tool calls instead of
    // speaking them as text. Supported by Gemini Live API.
    Tools []StreamingToolDefinition `json:"tools,omitempty"`

    // Metadata contains provider-specific session configuration
    // Example: {"response_modalities": ["TEXT", "AUDIO"]} for Gemini
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

<a name="StreamingInputConfig.Validate"></a>
### func \(\*StreamingInputConfig\) Validate

```go
func (r *StreamingInputConfig) Validate() error
```

Validate checks if the StreamInputRequest is valid

<a name="StreamingToolDefinition"></a>
## type StreamingToolDefinition

StreamingToolDefinition represents a function/tool available in streaming sessions.

```go
type StreamingToolDefinition struct {
    Name        string                 `json:"name"`
    Description string                 `json:"description,omitempty"`
    Parameters  map[string]interface{} `json:"parameters,omitempty"` // JSON Schema
}
```

<a name="ToolDescriptor"></a>
## type ToolDescriptor

ToolDescriptor represents a tool that can be used by providers

```go
type ToolDescriptor struct {
    Name         string          `json:"name"`
    Description  string          `json:"description"`
    InputSchema  json.RawMessage `json:"input_schema"`
    OutputSchema json.RawMessage `json:"output_schema"`
}
```

<a name="ToolResponse"></a>
## type ToolResponse

ToolResponse represents a single tool execution result.

```go
type ToolResponse struct {
    ToolCallID string `json:"tool_call_id"`
    Result     string `json:"result"`
    IsError    bool   `json:"is_error,omitempty"` // True if the tool execution failed
}
```

<a name="ToolResponseSupport"></a>
## type ToolResponseSupport

ToolResponseSupport is an optional interface for streaming sessions that support tool calling. When the model returns a tool call, the caller can execute the tool and send the result back using this interface. The session will then continue generating a response based on the tool result.

Use type assertion to check if a StreamInputSession supports this interface:

```
if toolSession, ok := session.(ToolResponseSupport); ok {
    err := toolSession.SendToolResponse(ctx, toolCallID, result)
}
```

```go
type ToolResponseSupport interface {
    // SendToolResponse sends the result of a tool execution back to the model.
    // The toolCallID must match the ID from the MessageToolCall.
    // The result is typically JSON-encoded but the format depends on the tool.
    // After receiving the tool response, the model will continue generating.
    SendToolResponse(ctx context.Context, toolCallID string, result string) error

    // SendToolResponses sends multiple tool results at once (for parallel tool calls).
    // This is more efficient than sending individual responses for providers that
    // support batched tool responses.
    SendToolResponses(ctx context.Context, responses []ToolResponse) error
}
```

<a name="ToolResult"></a>
## type ToolResult

ToolResult represents the result of a tool execution This is an alias to types.MessageToolResult for provider\-specific context

```go
type ToolResult = types.MessageToolResult
```

<a name="ToolSupport"></a>
## type ToolSupport

ToolSupport interface for providers that support tool/function calling

```go
type ToolSupport interface {
    Provider // Extends the base Provider interface

    // BuildTooling converts tool descriptors to provider-native format
    BuildTooling(descriptors []*ToolDescriptor) (interface{}, error)

    // PredictWithTools performs a predict request with tool support
    PredictWithTools(ctx context.Context, req PredictionRequest, tools interface{}, toolChoice string) (PredictionResponse, []types.MessageToolCall, error)

    // PredictStreamWithTools performs a streaming predict request with tool support
    PredictStreamWithTools(
        ctx context.Context,
        req PredictionRequest,
        tools interface{},
        toolChoice string,
    ) (<-chan StreamChunk, error)
}
```

<a name="UnsupportedContentError"></a>
## type UnsupportedContentError

UnsupportedContentError is returned when a provider doesn't support certain content types

```go
type UnsupportedContentError struct {
    Provider    string // Provider ID
    ContentType string // "image", "audio", "video", or "multimodal"
    Message     string // Human-readable error message
    PartIndex   int    // Index of the unsupported content part (if applicable)
    MIMEType    string // Specific MIME type that's unsupported (if applicable)
}
```

<a name="UnsupportedContentError.Error"></a>
### func \(\*UnsupportedContentError\) Error

```go
func (e *UnsupportedContentError) Error() string
```



<a name="UnsupportedProviderError"></a>
## type UnsupportedProviderError

UnsupportedProviderError is returned when a provider type is not recognized

```go
type UnsupportedProviderError struct {
    ProviderType string
}
```

<a name="UnsupportedProviderError.Error"></a>
### func \(\*UnsupportedProviderError\) Error

```go
func (e *UnsupportedProviderError) Error() string
```

Error returns the error message for this unsupported provider error.

<a name="ValidationAbortError"></a>
## type ValidationAbortError

ValidationAbortError is returned when a streaming validator aborts a stream

```go
type ValidationAbortError struct {
    Reason string
    Chunk  StreamChunk
}
```

<a name="ValidationAbortError.Error"></a>
### func \(\*ValidationAbortError\) Error

```go
func (e *ValidationAbortError) Error() string
```

Error returns the error message for this validation abort error.

<a name="VideoResolution"></a>
## type VideoResolution

VideoResolution represents a video resolution.

```go
type VideoResolution struct {
    Width  int `json:"width"`
    Height int `json:"height"`
}
```

<a name="VideoResolution.String"></a>
### func \(VideoResolution\) String

```go
func (r VideoResolution) String() string
```

String returns a string representation of the resolution \(e.g., "1920x1080"\)

<a name="VideoStreamingCapabilities"></a>
## type VideoStreamingCapabilities

VideoStreamingCapabilities describes video streaming support.

```go
type VideoStreamingCapabilities struct {
    // SupportedEncodings lists supported video encodings
    // Common values: "h264", "vp8", "vp9", "av1"
    SupportedEncodings []string `json:"supported_encodings"`

    // SupportedResolutions lists supported resolutions (width x height)
    SupportedResolutions []VideoResolution `json:"supported_resolutions"`

    // SupportedFrameRates lists supported frame rates
    // Common values: 15, 24, 30, 60
    SupportedFrameRates []int `json:"supported_frame_rates"`

    // PreferredEncoding is the recommended encoding
    PreferredEncoding string `json:"preferred_encoding"`

    // PreferredResolution is the recommended resolution
    PreferredResolution VideoResolution `json:"preferred_resolution"`

    // PreferredFrameRate is the recommended frame rate
    PreferredFrameRate int `json:"preferred_frame_rate"`
}
```

# statestore

```go
import "github.com/AltairaLabs/PromptKit/runtime/statestore"
```

Package statestore provides conversation state persistence and management.

## Index

- [Variables](<#variables>)
- [type ConversationState](<#ConversationState>)
- [type ListOptions](<#ListOptions>)
- [type MemoryStore](<#MemoryStore>)
  - [func NewMemoryStore\(\) \*MemoryStore](<#NewMemoryStore>)
  - [func \(s \*MemoryStore\) Delete\(ctx context.Context, id string\) error](<#MemoryStore.Delete>)
  - [func \(s \*MemoryStore\) Fork\(ctx context.Context, sourceID, newID string\) error](<#MemoryStore.Fork>)
  - [func \(s \*MemoryStore\) List\(ctx context.Context, opts ListOptions\) \(\[\]string, error\)](<#MemoryStore.List>)
  - [func \(s \*MemoryStore\) Load\(ctx context.Context, id string\) \(\*ConversationState, error\)](<#MemoryStore.Load>)
  - [func \(s \*MemoryStore\) Save\(ctx context.Context, state \*ConversationState\) error](<#MemoryStore.Save>)
- [type RedisOption](<#RedisOption>)
  - [func WithPrefix\(prefix string\) RedisOption](<#WithPrefix>)
  - [func WithTTL\(ttl time.Duration\) RedisOption](<#WithTTL>)
- [type RedisStore](<#RedisStore>)
  - [func NewRedisStore\(client \*redis.Client, opts ...RedisOption\) \*RedisStore](<#NewRedisStore>)
  - [func \(s \*RedisStore\) Delete\(ctx context.Context, id string\) error](<#RedisStore.Delete>)
  - [func \(s \*RedisStore\) Fork\(ctx context.Context, sourceID, newID string\) error](<#RedisStore.Fork>)
  - [func \(s \*RedisStore\) List\(ctx context.Context, opts ListOptions\) \(\[\]string, error\)](<#RedisStore.List>)
  - [func \(s \*RedisStore\) Load\(ctx context.Context, id string\) \(\*ConversationState, error\)](<#RedisStore.Load>)
  - [func \(s \*RedisStore\) Save\(ctx context.Context, state \*ConversationState\) error](<#RedisStore.Save>)
- [type Store](<#Store>)
- [type Summary](<#Summary>)


## Variables

<a name="ErrInvalidID"></a>ErrInvalidID is returned when an invalid conversation ID is provided.

```go
var ErrInvalidID = errors.New("invalid conversation ID")
```

<a name="ErrInvalidState"></a>ErrInvalidState is returned when a conversation state is invalid.

```go
var ErrInvalidState = errors.New("invalid conversation state")
```

<a name="ErrNotFound"></a>ErrNotFound is returned when a conversation doesn't exist in the store.

```go
var ErrNotFound = errors.New("conversation not found")
```

<a name="ConversationState"></a>
## type ConversationState

ConversationState represents stored conversation state in the state store. This is the primary data structure for persisting and loading conversation history.

```go
type ConversationState struct {
    ID             string                 // Unique conversation identifier
    UserID         string                 // User who owns this conversation
    Messages       []types.Message        // Message history (using unified types.Message)
    SystemPrompt   string                 // System prompt for this conversation
    Summaries      []Summary              // Compressed summaries of old turns
    TokenCount     int                    // Total tokens in messages
    LastAccessedAt time.Time              // Last time conversation was accessed
    Metadata       map[string]interface{} // Arbitrary metadata (e.g., extracted context)
}
```

<a name="ListOptions"></a>
## type ListOptions

ListOptions provides filtering and pagination options for listing conversations.

```go
type ListOptions struct {
    // UserID filters conversations by the user who owns them.
    // If empty, all conversations are returned (subject to pagination).
    UserID string

    // Limit is the maximum number of conversation IDs to return.
    // If 0, a default limit (e.g., 100) should be applied.
    Limit int

    // Offset is the number of conversations to skip (for pagination).
    Offset int

    // SortBy specifies the field to sort by (e.g., "created_at", "updated_at").
    // If empty, implementation-specific default sorting is used.
    SortBy string

    // SortOrder specifies sort direction: "asc" or "desc".
    // If empty, defaults to "desc" (newest first).
    SortOrder string
}
```

<a name="MemoryStore"></a>
## type MemoryStore

MemoryStore provides an in\-memory implementation of the Store interface. It is thread\-safe and suitable for development, testing, and single\-instance deployments. For distributed systems, use RedisStore or a database\-backed implementation.

```go
type MemoryStore struct {
    // contains filtered or unexported fields
}
```

<a name="NewMemoryStore"></a>
### func NewMemoryStore

```go
func NewMemoryStore() *MemoryStore
```

NewMemoryStore creates a new in\-memory state store.

<a name="MemoryStore.Delete"></a>
### func \(\*MemoryStore\) Delete

```go
func (s *MemoryStore) Delete(ctx context.Context, id string) error
```

Delete removes a conversation state by ID.

<a name="MemoryStore.Fork"></a>
### func \(\*MemoryStore\) Fork

```go
func (s *MemoryStore) Fork(ctx context.Context, sourceID, newID string) error
```

Fork creates a copy of an existing conversation state with a new ID.

<a name="MemoryStore.List"></a>
### func \(\*MemoryStore\) List

```go
func (s *MemoryStore) List(ctx context.Context, opts ListOptions) ([]string, error)
```

List returns conversation IDs matching the given criteria.

<a name="MemoryStore.Load"></a>
### func \(\*MemoryStore\) Load

```go
func (s *MemoryStore) Load(ctx context.Context, id string) (*ConversationState, error)
```

Load retrieves a conversation state by ID. Returns a deep copy to prevent external mutations.

<a name="MemoryStore.Save"></a>
### func \(\*MemoryStore\) Save

```go
func (s *MemoryStore) Save(ctx context.Context, state *ConversationState) error
```

Save persists a conversation state. If it already exists, it will be updated.

<a name="RedisOption"></a>
## type RedisOption

RedisOption configures a RedisStore.

```go
type RedisOption func(*RedisStore)
```

<a name="WithPrefix"></a>
### func WithPrefix

```go
func WithPrefix(prefix string) RedisOption
```

WithPrefix sets the key prefix for Redis keys. Default is "promptkit".

<a name="WithTTL"></a>
### func WithTTL

```go
func WithTTL(ttl time.Duration) RedisOption
```

WithTTL sets the time\-to\-live for conversation states. After this duration, conversations will be automatically deleted. Default is 24 hours. Set to 0 for no expiration.

<a name="RedisStore"></a>
## type RedisStore

RedisStore provides a Redis\-backed implementation of the Store interface. It uses JSON serialization for state storage and supports automatic TTL\-based cleanup. This implementation is suitable for distributed systems and production deployments.

```go
type RedisStore struct {
    // contains filtered or unexported fields
}
```

<a name="NewRedisStore"></a>
### func NewRedisStore

```go
func NewRedisStore(client *redis.Client, opts ...RedisOption) *RedisStore
```

NewRedisStore creates a new Redis\-backed state store.

Example:

```
store := NewRedisStore(
    redis.NewClient(&redis.Options{Addr: "localhost:6379"}),
    WithTTL(24 * time.Hour),
    WithPrefix("myapp"),
)
```

<a name="RedisStore.Delete"></a>
### func \(\*RedisStore\) Delete

```go
func (s *RedisStore) Delete(ctx context.Context, id string) error
```

Delete removes a conversation state from Redis.

<a name="RedisStore.Fork"></a>
### func \(\*RedisStore\) Fork

```go
func (s *RedisStore) Fork(ctx context.Context, sourceID, newID string) error
```

Fork creates a copy of an existing conversation state with a new ID.

<a name="RedisStore.List"></a>
### func \(\*RedisStore\) List

```go
func (s *RedisStore) List(ctx context.Context, opts ListOptions) ([]string, error)
```

List returns conversation IDs matching the given criteria.

<a name="RedisStore.Load"></a>
### func \(\*RedisStore\) Load

```go
func (s *RedisStore) Load(ctx context.Context, id string) (*ConversationState, error)
```

Load retrieves a conversation state by ID from Redis.

<a name="RedisStore.Save"></a>
### func \(\*RedisStore\) Save

```go
func (s *RedisStore) Save(ctx context.Context, state *ConversationState) error
```

Save persists a conversation state to Redis with TTL.

<a name="Store"></a>
## type Store

Store defines the interface for persistent conversation state storage.

```go
type Store interface {
    // Load retrieves conversation state by ID
    Load(ctx context.Context, id string) (*ConversationState, error)

    // Save persists conversation state
    Save(ctx context.Context, state *ConversationState) error

    // Fork creates a copy of an existing conversation state with a new ID
    // The original conversation is left unchanged. Returns ErrNotFound if sourceID doesn't exist.
    Fork(ctx context.Context, sourceID, newID string) error
}
```

<a name="Summary"></a>
## type Summary

Summary represents a compressed version of conversation turns. Used to maintain context while reducing token count for older conversations.

```go
type Summary struct {
    StartTurn  int       // First turn included in this summary
    EndTurn    int       // Last turn included in this summary
    Content    string    // Summarized content
    TokenCount int       // Token count of the summary
    CreatedAt  time.Time // When this summary was created
}
```

# storage

```go
import "github.com/AltairaLabs/PromptKit/runtime/storage"
```

## Index

- [type MediaMetadata](<#MediaMetadata>)
- [type MediaStorageService](<#MediaStorageService>)
- [type OrganizationMode](<#OrganizationMode>)
- [type PolicyHandler](<#PolicyHandler>)
- [type Reference](<#Reference>)


<a name="MediaMetadata"></a>
## type MediaMetadata

MediaMetadata contains metadata about stored media for organization and policy enforcement. This metadata is used to organize media files in storage and apply retention policies.

```go
type MediaMetadata struct {
    // RunID identifies the test run that generated this media
    RunID string `json:"run_id"`

    // ConversationID identifies the conversation containing this media
    ConversationID string `json:"conversation_id,omitempty"`

    // SessionID identifies the session (for streaming sessions)
    SessionID string `json:"session_id,omitempty"`

    // MessageIdx is the index of the message containing this media (0-based)
    MessageIdx int `json:"message_idx"`

    // PartIdx is the index of the content part containing this media (0-based)
    PartIdx int `json:"part_idx"`

    // MIMEType is the media MIME type (e.g., "image/jpeg", "audio/mp3")
    MIMEType string `json:"mime_type"`

    // SizeBytes is the size of the media content in bytes
    SizeBytes int64 `json:"size_bytes"`

    // ProviderID identifies the provider that generated this media
    ProviderID string `json:"provider_id,omitempty"`

    // Timestamp is when the media was stored
    Timestamp time.Time `json:"timestamp"`

    // PolicyName is the retention policy to apply to this media
    PolicyName string `json:"policy_name,omitempty"`
}
```

<a name="MediaStorageService"></a>
## type MediaStorageService

MediaStorageService defines the interface for storing and retrieving media content. Implementations may store media in local filesystem, cloud storage, or other backends.

Example usage:

```
storage := local.NewFileStore("/var/promptkit/media")
ref, err := storage.StoreMedia(ctx, mediaContent, metadata)
if err != nil {
    return err
}
// Later...
content, err := storage.RetrieveMedia(ctx, ref)
```

Implementations should be safe for concurrent use by multiple goroutines.

```go
type MediaStorageService interface {
    // StoreMedia stores media content and returns a storage reference.
    // The reference can be used to retrieve the media later.
    //
    // Parameters:
    //   - ctx: Context for cancellation and timeouts
    //   - content: The media content to store (must have Data, FilePath, or URL set)
    //   - metadata: Metadata about the media for organization and policies
    //
    // Returns:
    //   - Reference that can be used to retrieve the media
    //   - Error if storage fails
    //
    // The implementation should:
    //   - Validate the content and metadata
    //   - Store the media content durably
    //   - Apply any configured policies (e.g., retention)
    //   - Return a reference that uniquely identifies the stored media
    StoreMedia(ctx context.Context, content *types.MediaContent, metadata *MediaMetadata) (Reference, error)

    // RetrieveMedia retrieves media content by its storage reference.
    //
    // Parameters:
    //   - ctx: Context for cancellation and timeouts
    //   - reference: The storage reference returned by StoreMedia
    //
    // Returns:
    //   - MediaContent with FilePath set (Data should NOT be loaded into memory)
    //   - Error if retrieval fails or reference is invalid
    //
    // The implementation should:
    //   - Validate the reference
    //   - Return MediaContent with FilePath pointing to the stored media
    //   - NOT load the full media data into memory (caller can use GetBase64Data if needed)
    RetrieveMedia(ctx context.Context, reference Reference) (*types.MediaContent, error)

    // DeleteMedia deletes media content by its storage reference.
    //
    // Parameters:
    //   - ctx: Context for cancellation and timeouts
    //   - reference: The storage reference to delete
    //
    // Returns:
    //   - Error if deletion fails or reference is invalid
    //
    // The implementation should:
    //   - Validate the reference
    //   - Delete the media content if not referenced elsewhere (for dedup)
    //   - Clean up any associated metadata
    //   - Handle concurrent deletions safely
    DeleteMedia(ctx context.Context, reference Reference) error

    // GetURL returns a URL that can be used to access the media.
    // For local storage, this returns a file:// URL.
    // For cloud storage, this may return a signed URL with expiration.
    //
    // Parameters:
    //   - ctx: Context for cancellation and timeouts
    //   - reference: The storage reference
    //   - expiry: How long the URL should be valid (ignored for local storage)
    //
    // Returns:
    //   - URL string that can be used to access the media
    //   - Error if URL generation fails or reference is invalid
    GetURL(ctx context.Context, reference Reference, expiry time.Duration) (string, error)
}
```

<a name="OrganizationMode"></a>
## type OrganizationMode

OrganizationMode defines how media files are organized in storage.

```go
type OrganizationMode string
```

<a name="OrganizationBySession"></a>

```go
const (
    // OrganizationBySession organizes media by session ID
    OrganizationBySession OrganizationMode = "by-session"

    // OrganizationByConversation organizes media by conversation ID
    OrganizationByConversation OrganizationMode = "by-conversation"

    // OrganizationByRun organizes media by run ID
    OrganizationByRun OrganizationMode = "by-run"
)
```

<a name="PolicyHandler"></a>
## type PolicyHandler

PolicyHandler defines the interface for applying and enforcing storage policies. Policies control media retention, cleanup, and other lifecycle management.

Example usage:

```
policy := policy.NewTimeBasedPolicy()
err := policy.ApplyPolicy(ctx, "/path/to/media.jpg", "delete-after-10min")
if err != nil {
    return err
}
// Background enforcement
go func() {
    ticker := time.NewTicker(1 * time.Minute)
    for range ticker.C {
        policy.EnforcePolicy(ctx)
    }
}()
```

```go
type PolicyHandler interface {
    // ApplyPolicy applies a named policy to a media file.
    // This typically stores policy metadata alongside the media.
    //
    // Parameters:
    //   - ctx: Context for cancellation and timeouts
    //   - filePath: Path to the media file
    //   - policyName: Name of the policy to apply (e.g., "delete-after-10min", "retain-30days")
    //
    // Returns:
    //   - Error if policy application fails or policy is unknown
    ApplyPolicy(ctx context.Context, filePath string, policyName string) error

    // EnforcePolicy scans stored media and enforces policies.
    // This is typically called periodically in the background.
    //
    // Parameters:
    //   - ctx: Context for cancellation and timeouts
    //
    // Returns:
    //   - Error if enforcement fails (should log but not crash on individual file errors)
    //
    // The implementation should:
    //   - Scan media directories for policy metadata
    //   - Apply policies (e.g., delete expired files)
    //   - Log enforcement actions
    //   - Handle errors gracefully (don't stop on permission denied, etc.)
    EnforcePolicy(ctx context.Context) error
}
```

<a name="Reference"></a>
## type Reference

Reference is a reference to media stored in a backend. The format and meaning is backend\-specific.

```go
type Reference string
```

# streaming

```go
import "github.com/AltairaLabs/PromptKit/runtime/streaming"
```

Package streaming provides generic utilities for bidirectional streaming communication with LLM providers.

This package extracts common patterns used in duplex \(bidirectional\) streaming conversations, including:

- Response processing state machine for handling provider responses
- Tool execution interface for streaming tool calls
- Audio streaming utilities for sending audio chunks to providers
- Response collection patterns for managing streaming responses

The package is designed to be provider\-agnostic, working with any provider that implements the runtime/providers streaming interfaces.

### Response Processing

The response state machine \(ProcessResponseElement\) analyzes stream elements and determines appropriate actions:

- Continue: informational element, keep waiting
- Complete: turn finished with valid response
- Error: error or unexpected empty response
- ToolCalls: tool calls need execution

### Tool Execution

The ToolExecutor interface allows custom tool registry implementations to be plugged in. The package provides helpers for sending tool results back through the streaming pipeline.

### Audio Streaming

AudioStreamer provides utilities for streaming audio data in either burst mode \(all at once\) or real\-time mode \(paced to match playback speed\).

### Response Collection

ResponseCollector manages the goroutine pattern for collecting streaming responses from a provider session, with optional tool call handling.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func BuildToolResponseElement\(result \*ToolExecutionResult\) stage.StreamElement](<#BuildToolResponseElement>)
- [func DrainStaleMessages\(outputChan \<\-chan stage.StreamElement\) \(int, error\)](<#DrainStaleMessages>)
- [func ExecuteAndSend\(ctx context.Context, executor ToolExecutor, toolCalls \[\]types.MessageToolCall, inputChan chan\<\- stage.StreamElement\) error](<#ExecuteAndSend>)
- [func SendEndOfStream\(ctx context.Context, inputChan chan\<\- stage.StreamElement\) error](<#SendEndOfStream>)
- [func SendToolResults\(ctx context.Context, result \*ToolExecutionResult, inputChan chan\<\- stage.StreamElement\) error](<#SendToolResults>)
- [func WaitForResponse\(ctx context.Context, responseDone \<\-chan error\) error](<#WaitForResponse>)
- [type AudioStreamer](<#AudioStreamer>)
  - [func NewAudioStreamer\(\) \*AudioStreamer](<#NewAudioStreamer>)
  - [func \(a \*AudioStreamer\) SendChunk\(ctx context.Context, chunk \[\]byte, sampleRate int, inputChan chan\<\- stage.StreamElement\) error](<#AudioStreamer.SendChunk>)
  - [func \(a \*AudioStreamer\) StreamBurst\(ctx context.Context, audioData \[\]byte, sampleRate int, inputChan chan\<\- stage.StreamElement\) error](<#AudioStreamer.StreamBurst>)
  - [func \(a \*AudioStreamer\) StreamRealtime\(ctx context.Context, audioData \[\]byte, sampleRate int, inputChan chan\<\- stage.StreamElement\) error](<#AudioStreamer.StreamRealtime>)
- [type ResponseAction](<#ResponseAction>)
  - [func ProcessResponseElement\(elem \*stage.StreamElement, logPrefix string\) \(ResponseAction, error\)](<#ProcessResponseElement>)
  - [func \(a ResponseAction\) String\(\) string](<#ResponseAction.String>)
- [type ResponseCollector](<#ResponseCollector>)
  - [func NewResponseCollector\(config ResponseCollectorConfig\) \*ResponseCollector](<#NewResponseCollector>)
  - [func \(c \*ResponseCollector\) Start\(ctx context.Context, outputChan \<\-chan stage.StreamElement, inputChan chan\<\- stage.StreamElement\) \<\-chan error](<#ResponseCollector.Start>)
- [type ResponseCollectorConfig](<#ResponseCollectorConfig>)
- [type ToolExecutionResult](<#ToolExecutionResult>)
- [type ToolExecutor](<#ToolExecutor>)


## Constants

<a name="DefaultChunkSize"></a>Default audio configuration constants

```go
const (
    // DefaultChunkSize is the default audio chunk size in bytes.
    // 640 bytes = 20ms at 16kHz 16-bit mono (16000 * 2 * 0.02)
    DefaultChunkSize = 640

    // DefaultSampleRate is the default audio sample rate in Hz.
    // 16kHz is required by Gemini Live API.
    DefaultSampleRate = 16000

    // DefaultChunkIntervalMs is the default interval between chunks in milliseconds
    // when streaming in real-time mode.
    DefaultChunkIntervalMs = 20
)
```

## Variables

<a name="ErrEmptyResponse"></a>ErrEmptyResponse is returned when a response element has no content. This typically indicates an interrupted response that wasn't properly handled.

```go
var ErrEmptyResponse = errors.New("empty response, likely interrupted")
```

<a name="ErrSessionEnded"></a>ErrSessionEnded is returned when the streaming session has ended. This is not necessarily an error, just indicates the session is complete.

```go
var ErrSessionEnded = errors.New("session ended")
```

<a name="BuildToolResponseElement"></a>
## func BuildToolResponseElement

```go
func BuildToolResponseElement(result *ToolExecutionResult) stage.StreamElement
```

BuildToolResponseElement creates a stream element containing tool results. This element can be sent through the pipeline to: 1. Forward tool responses to the provider \(via metadata\["tool\_responses"\]\) 2. Capture tool results in the state store \(via metadata\["tool\_result\_messages"\]\)

<a name="DrainStaleMessages"></a>
## func DrainStaleMessages

```go
func DrainStaleMessages(outputChan <-chan stage.StreamElement) (int, error)
```

DrainStaleMessages removes any buffered messages from the output channel. This is useful for clearing state between turns.

Returns the number of messages drained, or an error if the session ended.

<a name="ExecuteAndSend"></a>
## func ExecuteAndSend

```go
func ExecuteAndSend(ctx context.Context, executor ToolExecutor, toolCalls []types.MessageToolCall, inputChan chan<- stage.StreamElement) error
```

ExecuteAndSend is a convenience function that executes tool calls and sends the results through the pipeline in one operation.

If the executor is nil, this function returns nil \(no\-op\).

<a name="SendEndOfStream"></a>
## func SendEndOfStream

```go
func SendEndOfStream(ctx context.Context, inputChan chan<- stage.StreamElement) error
```

SendEndOfStream signals that audio input is complete for the current turn. This triggers the provider to generate a response.

<a name="SendToolResults"></a>
## func SendToolResults

```go
func SendToolResults(ctx context.Context, result *ToolExecutionResult, inputChan chan<- stage.StreamElement) error
```

SendToolResults sends tool execution results back through the pipeline to the provider, and includes tool result messages for state store capture.

This matches the behavior of non\-streaming mode where tool results are stored as messages. The tool result messages are sent via inputChan with metadata, and DuplexProviderStage forwards them to output for state store capture.

<a name="WaitForResponse"></a>
## func WaitForResponse

```go
func WaitForResponse(ctx context.Context, responseDone <-chan error) error
```

WaitForResponse waits for the response collection to complete. This is a convenience function for blocking until a response is received.

<a name="AudioStreamer"></a>
## type AudioStreamer

AudioStreamer provides utilities for streaming audio data through a pipeline.

```go
type AudioStreamer struct {
    // ChunkSize is the number of bytes per chunk.
    ChunkSize int

    // ChunkIntervalMs is the interval between chunks in milliseconds
    // when streaming in real-time mode.
    ChunkIntervalMs int
}
```

<a name="NewAudioStreamer"></a>
### func NewAudioStreamer

```go
func NewAudioStreamer() *AudioStreamer
```

NewAudioStreamer creates a new audio streamer with default settings.

<a name="AudioStreamer.SendChunk"></a>
### func \(\*AudioStreamer\) SendChunk

```go
func (a *AudioStreamer) SendChunk(ctx context.Context, chunk []byte, sampleRate int, inputChan chan<- stage.StreamElement) error
```

SendChunk sends a single audio chunk through the pipeline.

<a name="AudioStreamer.StreamBurst"></a>
### func \(\*AudioStreamer\) StreamBurst

```go
func (a *AudioStreamer) StreamBurst(ctx context.Context, audioData []byte, sampleRate int, inputChan chan<- stage.StreamElement) error
```

StreamBurst sends all audio data as fast as possible without pacing. This is preferred for pre\-recorded audio to avoid false turn detections from natural speech pauses.

The provider receives all audio before detecting any turn boundaries, which prevents "user interrupted" signals from arriving mid\-utterance.

<a name="AudioStreamer.StreamRealtime"></a>
### func \(\*AudioStreamer\) StreamRealtime

```go
func (a *AudioStreamer) StreamRealtime(ctx context.Context, audioData []byte, sampleRate int, inputChan chan<- stage.StreamElement) error
```

StreamRealtime sends audio data paced to match real\-time playback. Each chunk is sent with a delay matching its duration.

Note: This mode can cause issues with some providers \(like Gemini\) that detect speech pauses mid\-utterance. Use StreamBurst for pre\-recorded audio.

<a name="ResponseAction"></a>
## type ResponseAction

ResponseAction indicates what action to take after processing a response element.

```go
type ResponseAction int
```

<a name="ResponseActionContinue"></a>

```go
const (
    // ResponseActionContinue means the element was informational (e.g., interruption signal),
    // and we should continue waiting for the final response.
    ResponseActionContinue ResponseAction = iota
    // ResponseActionComplete means we received a complete response.
    ResponseActionComplete
    // ResponseActionError means an error occurred or the response was empty.
    ResponseActionError
    // ResponseActionToolCalls means the response contains tool calls that need to be executed.
    ResponseActionToolCalls
)
```

<a name="ProcessResponseElement"></a>
### func ProcessResponseElement

```go
func ProcessResponseElement(elem *stage.StreamElement, logPrefix string) (ResponseAction, error)
```

ProcessResponseElement handles a response element from the pipeline, determining the appropriate action based on interruption signals, turn completion, and errors.

This is the core state machine for duplex streaming response handling. It consolidates the response handling logic needed for bidirectional streaming.

Returns:

- ResponseAction: what action to take
- error: any error to return \(only set when action is ResponseActionError\)

<a name="ResponseAction.String"></a>
### func \(ResponseAction\) String

```go
func (a ResponseAction) String() string
```

String returns a human\-readable representation of the action.

<a name="ResponseCollector"></a>
## type ResponseCollector

ResponseCollector manages response collection from a streaming session. It processes streaming elements, handles tool calls, and signals completion.

```go
type ResponseCollector struct {
    // contains filtered or unexported fields
}
```

<a name="NewResponseCollector"></a>
### func NewResponseCollector

```go
func NewResponseCollector(config ResponseCollectorConfig) *ResponseCollector
```

NewResponseCollector creates a new response collector with the given configuration.

<a name="ResponseCollector.Start"></a>
### func \(\*ResponseCollector\) Start

```go
func (c *ResponseCollector) Start(ctx context.Context, outputChan <-chan stage.StreamElement, inputChan chan<- stage.StreamElement) <-chan error
```

Start begins collecting responses in a goroutine. Returns a channel that receives nil on success or an error on failure.

The collector will: 1. Process incoming stream elements 2. Execute tool calls via the ToolExecutor \(if configured\) 3. Send tool results back through inputChan 4. Signal completion or error through the returned channel

<a name="ResponseCollectorConfig"></a>
## type ResponseCollectorConfig

ResponseCollectorConfig configures response collection behavior.

```go
type ResponseCollectorConfig struct {
    // ToolExecutor is called when tool calls are received.
    // If nil, tool calls will result in an error.
    ToolExecutor ToolExecutor

    // LogPrefix is prepended to log messages for identification.
    LogPrefix string
}
```

<a name="ToolExecutionResult"></a>
## type ToolExecutionResult

ToolExecutionResult contains the results of executing tool calls.

```go
type ToolExecutionResult struct {
    // ProviderResponses are formatted for sending back to the streaming provider.
    ProviderResponses []providers.ToolResponse

    // ResultMessages are formatted for state store capture,
    // matching the behavior of non-streaming tool execution.
    ResultMessages []types.Message
}
```

<a name="ToolExecutor"></a>
## type ToolExecutor

ToolExecutor executes tool calls and returns results. Implementations provide the actual tool registry integration.

```go
type ToolExecutor interface {
    // Execute runs the given tool calls and returns their results.
    // The implementation is responsible for handling execution errors
    // and formatting them appropriately in the result.
    Execute(ctx context.Context, toolCalls []types.MessageToolCall) (*ToolExecutionResult, error)
}
```

# stt

```go
import "github.com/AltairaLabs/PromptKit/runtime/stt"
```

Package stt provides speech\-to\-text services for converting audio to text.

The package defines a common Service interface that abstracts STT providers, enabling voice AI applications to transcribe speech from users.

### Architecture

The package provides:

- Service interface for STT providers
- TranscriptionConfig for audio format configuration
- Multiple provider implementations \(OpenAI Whisper, etc.\)

### Usage

Basic usage with OpenAI Whisper:

```
service := stt.NewOpenAI(os.Getenv("OPENAI_API_KEY"))
text, err := service.Transcribe(ctx, audioData, stt.TranscriptionConfig{
    Format:     "pcm",
    SampleRate: 16000,
    Channels:   1,
    Language:   "en",
})
if err != nil {
    log.Fatal(err)
}
fmt.Println("User said:", text)
```

### Available Providers

The package includes implementations for:

- OpenAI Whisper \(whisper\-1 model\)
- More providers can be added following the Service interface

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func WrapPCMAsWAV\(pcmData \[\]byte, sampleRate, channels, bitsPerSample int\) \[\]byte](<#WrapPCMAsWAV>)
- [type OpenAIOption](<#OpenAIOption>)
  - [func WithOpenAIBaseURL\(url string\) OpenAIOption](<#WithOpenAIBaseURL>)
  - [func WithOpenAIClient\(client \*http.Client\) OpenAIOption](<#WithOpenAIClient>)
  - [func WithOpenAIModel\(model string\) OpenAIOption](<#WithOpenAIModel>)
- [type OpenAIService](<#OpenAIService>)
  - [func NewOpenAI\(apiKey string, opts ...OpenAIOption\) \*OpenAIService](<#NewOpenAI>)
  - [func \(s \*OpenAIService\) Name\(\) string](<#OpenAIService.Name>)
  - [func \(s \*OpenAIService\) SupportedFormats\(\) \[\]string](<#OpenAIService.SupportedFormats>)
  - [func \(s \*OpenAIService\) Transcribe\(ctx context.Context, audio \[\]byte, config TranscriptionConfig\) \(string, error\)](<#OpenAIService.Transcribe>)
- [type Service](<#Service>)
- [type TranscriptionConfig](<#TranscriptionConfig>)
  - [func DefaultTranscriptionConfig\(\) TranscriptionConfig](<#DefaultTranscriptionConfig>)
- [type TranscriptionError](<#TranscriptionError>)
  - [func NewTranscriptionError\(provider, code, message string, cause error, retryable bool\) \*TranscriptionError](<#NewTranscriptionError>)
  - [func \(e \*TranscriptionError\) Error\(\) string](<#TranscriptionError.Error>)
  - [func \(e \*TranscriptionError\) Is\(target error\) bool](<#TranscriptionError.Is>)
  - [func \(e \*TranscriptionError\) Unwrap\(\) error](<#TranscriptionError.Unwrap>)


## Constants

<a name="DefaultSampleRate"></a>

```go
const (
    // Default audio settings.
    DefaultSampleRate = 16000
    DefaultChannels   = 1
    DefaultBitDepth   = 16

    // Common audio formats.
    FormatPCM = "pcm"
    FormatWAV = "wav"
    FormatMP3 = "mp3"
)
```

<a name="ModelWhisper1"></a>

```go
const (

    // ModelWhisper1 is the OpenAI Whisper model for transcription.
    ModelWhisper1 = "whisper-1"
)
```

## Variables

<a name="ErrEmptyAudio"></a>Common errors for STT services.

```go
var (
    // ErrEmptyAudio is returned when audio data is empty.
    ErrEmptyAudio = errors.New("audio data is empty")

    // ErrRateLimited is returned when the provider rate limits requests.
    ErrRateLimited = errors.New("rate limited by provider")

    // ErrInvalidFormat is returned when the audio format is not supported.
    ErrInvalidFormat = errors.New("unsupported audio format")

    // ErrAudioTooShort is returned when audio is too short to transcribe.
    ErrAudioTooShort = errors.New("audio too short to transcribe")
)
```

<a name="WrapPCMAsWAV"></a>
## func WrapPCMAsWAV

```go
func WrapPCMAsWAV(pcmData []byte, sampleRate, channels, bitsPerSample int) []byte
```

WrapPCMAsWAV wraps raw PCM audio data in a WAV header. This is necessary for APIs like OpenAI Whisper that expect file uploads.

Parameters:

- pcmData: Raw PCM audio bytes \(little\-endian, signed\)
- sampleRate: Sample rate in Hz \(e.g., 16000\)
- channels: Number of channels \(1=mono, 2=stereo\)
- bitsPerSample: Bits per sample \(typically 16\)

Returns a byte slice containing WAV\-formatted audio.

<a name="OpenAIOption"></a>
## type OpenAIOption

OpenAIOption configures the OpenAI STT service.

```go
type OpenAIOption func(*OpenAIService)
```

<a name="WithOpenAIBaseURL"></a>
### func WithOpenAIBaseURL

```go
func WithOpenAIBaseURL(url string) OpenAIOption
```

WithOpenAIBaseURL sets a custom base URL \(for testing or proxies\).

<a name="WithOpenAIClient"></a>
### func WithOpenAIClient

```go
func WithOpenAIClient(client *http.Client) OpenAIOption
```

WithOpenAIClient sets a custom HTTP client.

<a name="WithOpenAIModel"></a>
### func WithOpenAIModel

```go
func WithOpenAIModel(model string) OpenAIOption
```

WithOpenAIModel sets the STT model to use.

<a name="OpenAIService"></a>
## type OpenAIService

OpenAIService implements STT using OpenAI's Whisper API.

```go
type OpenAIService struct {
    // contains filtered or unexported fields
}
```

<a name="NewOpenAI"></a>
### func NewOpenAI

```go
func NewOpenAI(apiKey string, opts ...OpenAIOption) *OpenAIService
```

NewOpenAI creates an OpenAI STT service using Whisper.

<a name="OpenAIService.Name"></a>
### func \(\*OpenAIService\) Name

```go
func (s *OpenAIService) Name() string
```

Name returns the provider identifier.

<a name="OpenAIService.SupportedFormats"></a>
### func \(\*OpenAIService\) SupportedFormats

```go
func (s *OpenAIService) SupportedFormats() []string
```

SupportedFormats returns audio formats supported by OpenAI Whisper.

<a name="OpenAIService.Transcribe"></a>
### func \(\*OpenAIService\) Transcribe

```go
func (s *OpenAIService) Transcribe(ctx context.Context, audio []byte, config TranscriptionConfig) (string, error)
```

Transcribe converts audio to text using OpenAI's Whisper API.

<a name="Service"></a>
## type Service

Service transcribes audio to text. This interface abstracts different STT providers \(OpenAI Whisper, Google, etc.\) enabling voice AI applications to use any provider interchangeably.

```go
type Service interface {
    // Name returns the provider identifier (for logging/debugging).
    Name() string

    // Transcribe converts audio to text.
    // Returns the transcribed text or an error if transcription fails.
    Transcribe(ctx context.Context, audio []byte, config TranscriptionConfig) (string, error)

    // SupportedFormats returns supported audio input formats.
    // Common values: "pcm", "wav", "mp3", "m4a", "webm"
    SupportedFormats() []string
}
```

<a name="TranscriptionConfig"></a>
## type TranscriptionConfig

TranscriptionConfig configures speech\-to\-text transcription.

```go
type TranscriptionConfig struct {
    // Format is the audio format ("pcm", "wav", "mp3").
    // Default: "pcm"
    Format string

    // SampleRate is the audio sample rate in Hz.
    // Default: 16000
    SampleRate int

    // Channels is the number of audio channels (1=mono, 2=stereo).
    // Default: 1
    Channels int

    // BitDepth is the bits per sample for PCM audio.
    // Default: 16
    BitDepth int

    // Language is a hint for the transcription language (e.g., "en", "es").
    // Optional - improves accuracy if provided.
    Language string

    // Model is the STT model to use (provider-specific).
    // For OpenAI: "whisper-1"
    Model string

    // Prompt is a text prompt to guide transcription (provider-specific).
    // Can improve accuracy for domain-specific vocabulary.
    Prompt string
}
```

<a name="DefaultTranscriptionConfig"></a>
### func DefaultTranscriptionConfig

```go
func DefaultTranscriptionConfig() TranscriptionConfig
```

DefaultTranscriptionConfig returns sensible defaults for transcription.

<a name="TranscriptionError"></a>
## type TranscriptionError

TranscriptionError represents an error during transcription.

```go
type TranscriptionError struct {
    // Provider is the STT provider name.
    Provider string

    // Code is the provider-specific error code.
    Code string

    // Message is a human-readable error message.
    Message string

    // Cause is the underlying error, if any.
    Cause error

    // Retryable indicates whether the request can be retried.
    Retryable bool
}
```

<a name="NewTranscriptionError"></a>
### func NewTranscriptionError

```go
func NewTranscriptionError(provider, code, message string, cause error, retryable bool) *TranscriptionError
```

NewTranscriptionError creates a new TranscriptionError.

<a name="TranscriptionError.Error"></a>
### func \(\*TranscriptionError\) Error

```go
func (e *TranscriptionError) Error() string
```

Error implements the error interface.

<a name="TranscriptionError.Is"></a>
### func \(\*TranscriptionError\) Is

```go
func (e *TranscriptionError) Is(target error) bool
```

Is implements error matching for errors.Is.

<a name="TranscriptionError.Unwrap"></a>
### func \(\*TranscriptionError\) Unwrap

```go
func (e *TranscriptionError) Unwrap() error
```

Unwrap returns the underlying error.

# template

```go
import "github.com/AltairaLabs/PromptKit/runtime/template"
```

Package template provides template rendering and variable substitution.

This package implements a flexible template system that can be used by both prompts and personas. It supports:

- Variable substitution with \{\{variable\}\} syntax
- Recursive template resolution \(variables can contain other variables\)
- Validation of required variables
- Detection of unresolved placeholders

Future versions may support more advanced templating engines like Go templates \(similar to Helm charts\) for conditional logic, loops, and functions.

## Index

- [func GetUsedVars\(vars map\[string\]string\) \[\]string](<#GetUsedVars>)
- [type Renderer](<#Renderer>)
  - [func NewRenderer\(\) \*Renderer](<#NewRenderer>)
  - [func \(r \*Renderer\) MergeVars\(varMaps ...map\[string\]string\) map\[string\]string](<#Renderer.MergeVars>)
  - [func \(r \*Renderer\) Render\(templateText string, vars map\[string\]string\) \(string, error\)](<#Renderer.Render>)
  - [func \(r \*Renderer\) ValidateRequiredVars\(requiredVars \[\]string, vars map\[string\]string\) error](<#Renderer.ValidateRequiredVars>)


<a name="GetUsedVars"></a>
## func GetUsedVars

```go
func GetUsedVars(vars map[string]string) []string
```

GetUsedVars returns a list of variable names that had non\-empty values. This is useful for debugging and logging which variables were actually used.

<a name="Renderer"></a>
## type Renderer

Renderer handles variable substitution in templates

```go
type Renderer struct {
}
```

<a name="NewRenderer"></a>
### func NewRenderer

```go
func NewRenderer() *Renderer
```

NewRenderer creates a new template renderer

<a name="Renderer.MergeVars"></a>
### func \(\*Renderer\) MergeVars

```go
func (r *Renderer) MergeVars(varMaps ...map[string]string) map[string]string
```

MergeVars merges multiple variable maps with later maps taking precedence. This is useful for combining default values, context variables, and overrides.

Example:

```
defaults := map[string]string{"color": "blue", "size": "medium"}
overrides := map[string]string{"color": "red"}
result := MergeVars(defaults, overrides)
// result = {"color": "red", "size": "medium"}
```

<a name="Renderer.Render"></a>
### func \(\*Renderer\) Render

```go
func (r *Renderer) Render(templateText string, vars map[string]string) (string, error)
```

Render applies variable substitution to the template with recursive resolution.

The renderer performs multiple passes \(up to maxPasses\) to handle nested variable substitution. For example, if var1="\{\{var2\}\}" and var2="value", the final result will correctly resolve to "value".

Returns an error if any placeholders remain unresolved after all passes.

<a name="Renderer.ValidateRequiredVars"></a>
### func \(\*Renderer\) ValidateRequiredVars

```go
func (r *Renderer) ValidateRequiredVars(requiredVars []string, vars map[string]string) error
```

ValidateRequiredVars checks that all required variables are provided and non\-empty. Returns an error listing any missing variables.

# tools

```go
import "github.com/AltairaLabs/PromptKit/runtime/tools"
```

Package tools provides tool/function calling infrastructure for LLM testing.

This package implements a flexible tool execution system with:

- Tool descriptor registry with JSON Schema validation
- Mock executors for testing \(static and template\-based\)
- HTTP executor for live API calls
- Type coercion and result validation
- Adapter for prompt registry integration

Tools can be loaded from YAML/JSON files and executed with argument validation, result schema checking, and automatic type coercion for common mismatches.

## Index

- [type AsyncToolExecutor](<#AsyncToolExecutor>)
- [type Coercion](<#Coercion>)
- [type Executor](<#Executor>)
- [type FileToolResponseRepository](<#FileToolResponseRepository>)
  - [func NewFileToolResponseRepository\(scenarioID string, toolResponses map\[string\]\[\]MockToolResponseConfig\) \*FileToolResponseRepository](<#NewFileToolResponseRepository>)
  - [func \(r \*FileToolResponseRepository\) GetToolResponse\(toolName string, args map\[string\]interface\{\}, contextKey string\) \(\*ToolResponseData, error\)](<#FileToolResponseRepository.GetToolResponse>)
- [type HTTPConfig](<#HTTPConfig>)
- [type InMemoryToolResponseRepository](<#InMemoryToolResponseRepository>)
  - [func NewInMemoryToolResponseRepository\(\) \*InMemoryToolResponseRepository](<#NewInMemoryToolResponseRepository>)
  - [func \(r \*InMemoryToolResponseRepository\) AddResponse\(contextKey, toolName string, response \*ToolResponseData\)](<#InMemoryToolResponseRepository.AddResponse>)
  - [func \(r \*InMemoryToolResponseRepository\) GetToolResponse\(toolName string, args map\[string\]interface\{\}, contextKey string\) \(\*ToolResponseData, error\)](<#InMemoryToolResponseRepository.GetToolResponse>)
- [type MCPExecutor](<#MCPExecutor>)
  - [func NewMCPExecutor\(registry mcp.Registry\) \*MCPExecutor](<#NewMCPExecutor>)
  - [func \(e \*MCPExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MCPExecutor.Execute>)
  - [func \(e \*MCPExecutor\) Name\(\) string](<#MCPExecutor.Name>)
- [type MockScriptedExecutor](<#MockScriptedExecutor>)
  - [func NewMockScriptedExecutor\(\) \*MockScriptedExecutor](<#NewMockScriptedExecutor>)
  - [func \(e \*MockScriptedExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MockScriptedExecutor.Execute>)
  - [func \(e \*MockScriptedExecutor\) Name\(\) string](<#MockScriptedExecutor.Name>)
- [type MockStaticExecutor](<#MockStaticExecutor>)
  - [func NewMockStaticExecutor\(\) \*MockStaticExecutor](<#NewMockStaticExecutor>)
  - [func \(e \*MockStaticExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MockStaticExecutor.Execute>)
  - [func \(e \*MockStaticExecutor\) Name\(\) string](<#MockStaticExecutor.Name>)
- [type MockToolErrorConfig](<#MockToolErrorConfig>)
- [type MockToolResponseConfig](<#MockToolResponseConfig>)
- [type PendingToolInfo](<#PendingToolInfo>)
- [type PredictMessage](<#PredictMessage>)
- [type PredictionRequest](<#PredictionRequest>)
- [type PredictionResponse](<#PredictionResponse>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func NewRegistryWithRepository\(repository ToolRepository\) \*Registry](<#NewRegistryWithRepository>)
  - [func \(r \*Registry\) Execute\(toolName string, args json.RawMessage\) \(\*ToolResult, error\)](<#Registry.Execute>)
  - [func \(r \*Registry\) ExecuteAsync\(toolName string, args json.RawMessage\) \(\*ToolExecutionResult, error\)](<#Registry.ExecuteAsync>)
  - [func \(r \*Registry\) Get\(name string\) \*ToolDescriptor](<#Registry.Get>)
  - [func \(r \*Registry\) GetTool\(name string\) \(\*ToolDescriptor, error\)](<#Registry.GetTool>)
  - [func \(r \*Registry\) GetTools\(\) map\[string\]\*ToolDescriptor](<#Registry.GetTools>)
  - [func \(r \*Registry\) GetToolsByNames\(names \[\]string\) \(\[\]\*ToolDescriptor, error\)](<#Registry.GetToolsByNames>)
  - [func \(r \*Registry\) List\(\) \[\]string](<#Registry.List>)
  - [func \(r \*Registry\) LoadToolFromBytes\(filename string, data \[\]byte\) error](<#Registry.LoadToolFromBytes>)
  - [func \(r \*Registry\) Register\(descriptor \*ToolDescriptor\) error](<#Registry.Register>)
  - [func \(r \*Registry\) RegisterExecutor\(executor Executor\)](<#Registry.RegisterExecutor>)
- [type RepositoryToolExecutor](<#RepositoryToolExecutor>)
  - [func NewRepositoryToolExecutor\(baseExecutor Executor, repo ToolResponseRepository, contextKey string\) \*RepositoryToolExecutor](<#NewRepositoryToolExecutor>)
  - [func \(e \*RepositoryToolExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#RepositoryToolExecutor.Execute>)
  - [func \(e \*RepositoryToolExecutor\) Name\(\) string](<#RepositoryToolExecutor.Name>)
- [type SchemaValidator](<#SchemaValidator>)
  - [func NewSchemaValidator\(\) \*SchemaValidator](<#NewSchemaValidator>)
  - [func \(sv \*SchemaValidator\) CoerceResult\(descriptor \*ToolDescriptor, result json.RawMessage\) \(json.RawMessage, \[\]Coercion, error\)](<#SchemaValidator.CoerceResult>)
  - [func \(sv \*SchemaValidator\) ValidateArgs\(descriptor \*ToolDescriptor, args json.RawMessage\) error](<#SchemaValidator.ValidateArgs>)
  - [func \(sv \*SchemaValidator\) ValidateResult\(descriptor \*ToolDescriptor, result json.RawMessage\) error](<#SchemaValidator.ValidateResult>)
- [type ToolCall](<#ToolCall>)
- [type ToolConfig](<#ToolConfig>)
- [type ToolDescriptor](<#ToolDescriptor>)
- [type ToolErrorData](<#ToolErrorData>)
- [type ToolExecutionResult](<#ToolExecutionResult>)
- [type ToolExecutionStatus](<#ToolExecutionStatus>)
- [type ToolGuidance](<#ToolGuidance>)
- [type ToolPolicy](<#ToolPolicy>)
- [type ToolRepository](<#ToolRepository>)
- [type ToolResponseData](<#ToolResponseData>)
- [type ToolResponseRepository](<#ToolResponseRepository>)
- [type ToolResult](<#ToolResult>)
- [type ToolStats](<#ToolStats>)
- [type ValidationError](<#ValidationError>)
  - [func \(e \*ValidationError\) Error\(\) string](<#ValidationError.Error>)


<a name="AsyncToolExecutor"></a>
## type AsyncToolExecutor

AsyncToolExecutor is a tool that can return pending status instead of blocking. Tools that require human approval or external async operations should implement this.

```go
type AsyncToolExecutor interface {
    Executor // Still implements the basic Executor interface

    // ExecuteAsync may return immediately with a pending status
    ExecuteAsync(descriptor *ToolDescriptor, args json.RawMessage) (*ToolExecutionResult, error)
}
```

<a name="Coercion"></a>
## type Coercion

Coercion represents a type coercion that was performed

```go
type Coercion struct {
    Path string      `json:"path"`
    From interface{} `json:"from"`
    To   interface{} `json:"to"`
}
```

<a name="Executor"></a>
## type Executor

Executor interface defines how tools are executed

```go
type Executor interface {
    Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
    Name() string
}
```

<a name="FileToolResponseRepository"></a>
## type FileToolResponseRepository

FileToolResponseRepository implements ToolResponseRepository using the provider's MockConfig YAML structure. This allows Arena scenarios to define tool responses alongside LLM responses.

```go
type FileToolResponseRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewFileToolResponseRepository"></a>
### func NewFileToolResponseRepository

```go
func NewFileToolResponseRepository(scenarioID string, toolResponses map[string][]MockToolResponseConfig) *FileToolResponseRepository
```

NewFileToolResponseRepository creates a repository from scenario tool responses. This is typically used by Arena to provide tool mocking from YAML scenarios.

<a name="FileToolResponseRepository.GetToolResponse"></a>
### func \(\*FileToolResponseRepository\) GetToolResponse

```go
func (r *FileToolResponseRepository) GetToolResponse(toolName string, args map[string]interface{}, contextKey string) (*ToolResponseData, error)
```

GetToolResponse implements ToolResponseRepository. It finds the first matching response based on argument comparison.

<a name="HTTPConfig"></a>
## type HTTPConfig

HTTPConfig defines configuration for live HTTP tool execution

```go
type HTTPConfig struct {
    URL            string            `json:"url" yaml:"url"`
    Method         string            `json:"method" yaml:"method"`
    HeadersFromEnv []string          `json:"headers_from_env,omitempty" yaml:"headers_from_env,omitempty"`
    TimeoutMs      int               `json:"timeout_ms" yaml:"timeout_ms"`
    Redact         []string          `json:"redact,omitempty" yaml:"redact,omitempty"`
    Headers        map[string]string `json:"headers,omitempty" yaml:"headers,omitempty"`
}
```

<a name="InMemoryToolResponseRepository"></a>
## type InMemoryToolResponseRepository

InMemoryToolResponseRepository implements ToolResponseRepository using in\-memory storage. This is useful for SDK unit tests and programmatic configuration of tool responses.

```go
type InMemoryToolResponseRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewInMemoryToolResponseRepository"></a>
### func NewInMemoryToolResponseRepository

```go
func NewInMemoryToolResponseRepository() *InMemoryToolResponseRepository
```

NewInMemoryToolResponseRepository creates a new in\-memory tool response repository.

<a name="InMemoryToolResponseRepository.AddResponse"></a>
### func \(\*InMemoryToolResponseRepository\) AddResponse

```go
func (r *InMemoryToolResponseRepository) AddResponse(contextKey, toolName string, response *ToolResponseData)
```

AddResponse adds a tool response for a specific context and tool name. This method supports simple responses where argument matching is not needed.

<a name="InMemoryToolResponseRepository.GetToolResponse"></a>
### func \(\*InMemoryToolResponseRepository\) GetToolResponse

```go
func (r *InMemoryToolResponseRepository) GetToolResponse(toolName string, args map[string]interface{}, contextKey string) (*ToolResponseData, error)
```

GetToolResponse implements ToolResponseRepository. For simplicity, this implementation only matches by tool name and context, not by arguments. For argument\-based matching, use FileToolResponseRepository or implement a custom repository.

<a name="MCPExecutor"></a>
## type MCPExecutor

MCPExecutor executes tools using MCP \(Model Context Protocol\) servers

```go
type MCPExecutor struct {
    // contains filtered or unexported fields
}
```

<a name="NewMCPExecutor"></a>
### func NewMCPExecutor

```go
func NewMCPExecutor(registry mcp.Registry) *MCPExecutor
```

NewMCPExecutor creates a new MCP executor

<a name="MCPExecutor.Execute"></a>
### func \(\*MCPExecutor\) Execute

```go
func (e *MCPExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using an MCP server

<a name="MCPExecutor.Name"></a>
### func \(\*MCPExecutor\) Name

```go
func (e *MCPExecutor) Name() string
```

Name returns the executor name

<a name="MockScriptedExecutor"></a>
## type MockScriptedExecutor

MockScriptedExecutor executes tools using templated mock data

```go
type MockScriptedExecutor struct{}
```

<a name="NewMockScriptedExecutor"></a>
### func NewMockScriptedExecutor

```go
func NewMockScriptedExecutor() *MockScriptedExecutor
```

NewMockScriptedExecutor creates a new scripted mock executor

<a name="MockScriptedExecutor.Execute"></a>
### func \(\*MockScriptedExecutor\) Execute

```go
func (e *MockScriptedExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using templated mock data

<a name="MockScriptedExecutor.Name"></a>
### func \(\*MockScriptedExecutor\) Name

```go
func (e *MockScriptedExecutor) Name() string
```

Name returns the executor name

<a name="MockStaticExecutor"></a>
## type MockStaticExecutor

MockStaticExecutor executes tools using static mock data

```go
type MockStaticExecutor struct{}
```

<a name="NewMockStaticExecutor"></a>
### func NewMockStaticExecutor

```go
func NewMockStaticExecutor() *MockStaticExecutor
```

NewMockStaticExecutor creates a new static mock executor

<a name="MockStaticExecutor.Execute"></a>
### func \(\*MockStaticExecutor\) Execute

```go
func (e *MockStaticExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using static mock data

<a name="MockStaticExecutor.Name"></a>
### func \(\*MockStaticExecutor\) Name

```go
func (e *MockStaticExecutor) Name() string
```

Name returns the executor name

<a name="MockToolErrorConfig"></a>
## type MockToolErrorConfig

MockToolErrorConfig represents an error configuration.

```go
type MockToolErrorConfig struct {
    Type    string `yaml:"type"`
    Message string `yaml:"message"`
}
```

<a name="MockToolResponseConfig"></a>
## type MockToolResponseConfig

MockToolResponseConfig represents a single tool response configuration.

```go
type MockToolResponseConfig struct {
    CallArgs map[string]interface{} `yaml:"call_args"`
    Result   interface{}            `yaml:"result,omitempty"`
    Error    *MockToolErrorConfig   `yaml:"error,omitempty"`
}
```

<a name="PendingToolInfo"></a>
## type PendingToolInfo

PendingToolInfo provides context for middleware \(email templates, notifications\)

```go
type PendingToolInfo struct {
    // Reason for pending (e.g., "requires_approval", "waiting_external_api")
    Reason string `json:"reason"`

    // Human-readable description
    Message string `json:"message"`

    // Tool details (for middleware to use in notifications)
    ToolName string          `json:"tool_name"`
    Args     json.RawMessage `json:"args"`

    // Optional: expiration, callback URL, etc.
    ExpiresAt   *time.Time `json:"expires_at,omitempty"`
    CallbackURL string     `json:"callback_url,omitempty"`

    // Arbitrary metadata for custom middleware
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

<a name="PredictMessage"></a>
## type PredictMessage

PredictMessage represents a predict message \(simplified version for tool context\)

```go
type PredictMessage struct {
    Role               string     `json:"role"`
    Content            string     `json:"content"`
    ToolCalls          []ToolCall `json:"tool_calls,omitempty"`
    ToolCallResponseID string     `json:"tool_call_id,omitempty"` // For tool result messages
}
```

<a name="PredictionRequest"></a>
## type PredictionRequest

PredictionRequest represents a predict request \(extending existing type\)

```go
type PredictionRequest struct {
    System      string           `json:"system"`
    Messages    []PredictMessage `json:"messages"`
    Temperature float32          `json:"temperature"`
    TopP        float32          `json:"top_p"`
    MaxTokens   int              `json:"max_tokens"`
    Seed        *int             `json:"seed,omitempty"`
}
```

<a name="PredictionResponse"></a>
## type PredictionResponse

PredictionResponse represents a predict response \(extending existing type\)

```go
type PredictionResponse struct {
    Content   string        `json:"content"`
    TokensIn  int           `json:"tokens_in"`
    TokensOut int           `json:"tokens_out"`
    Latency   time.Duration `json:"latency"`
    Raw       []byte        `json:"raw,omitempty"`
    ToolCalls []ToolCall    `json:"tool_calls,omitempty"` // Tools called in this response
}
```

<a name="Registry"></a>
## type Registry

Registry manages tool descriptors and provides access to executors

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new tool registry without a repository backend \(legacy mode\)

<a name="NewRegistryWithRepository"></a>
### func NewRegistryWithRepository

```go
func NewRegistryWithRepository(repository ToolRepository) *Registry
```

NewRegistryWithRepository creates a new tool registry with a repository backend

<a name="Registry.Execute"></a>
### func \(\*Registry\) Execute

```go
func (r *Registry) Execute(toolName string, args json.RawMessage) (*ToolResult, error)
```

Execute executes a tool with the given arguments

<a name="Registry.ExecuteAsync"></a>
### func \(\*Registry\) ExecuteAsync

```go
func (r *Registry) ExecuteAsync(toolName string, args json.RawMessage) (*ToolExecutionResult, error)
```

ExecuteAsync executes a tool with async support, checking if it implements AsyncToolExecutor. Returns ToolExecutionResult with status \(complete/pending/failed\).

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(name string) *ToolDescriptor
```

Get retrieves a tool descriptor by name with repository fallback

<a name="Registry.GetTool"></a>
### func \(\*Registry\) GetTool

```go
func (r *Registry) GetTool(name string) (*ToolDescriptor, error)
```

GetTool retrieves a tool descriptor by name

<a name="Registry.GetTools"></a>
### func \(\*Registry\) GetTools

```go
func (r *Registry) GetTools() map[string]*ToolDescriptor
```

GetTools returns all loaded tool descriptors

<a name="Registry.GetToolsByNames"></a>
### func \(\*Registry\) GetToolsByNames

```go
func (r *Registry) GetToolsByNames(names []string) ([]*ToolDescriptor, error)
```

GetToolsByNames returns tool descriptors for the specified names

<a name="Registry.List"></a>
### func \(\*Registry\) List

```go
func (r *Registry) List() []string
```

List returns all tool names from repository or cache

<a name="Registry.LoadToolFromBytes"></a>
### func \(\*Registry\) LoadToolFromBytes

```go
func (r *Registry) LoadToolFromBytes(filename string, data []byte) error
```

LoadToolFromBytes loads a tool descriptor from raw bytes data. This is useful when tool data has already been read from a file or received from another source, avoiding redundant file I/O. The filename parameter is used only for error reporting.

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(descriptor *ToolDescriptor) error
```

Register adds a tool descriptor to the registry with validation

<a name="Registry.RegisterExecutor"></a>
### func \(\*Registry\) RegisterExecutor

```go
func (r *Registry) RegisterExecutor(executor Executor)
```

RegisterExecutor registers a tool executor

<a name="RepositoryToolExecutor"></a>
## type RepositoryToolExecutor

RepositoryToolExecutor wraps existing tool executors to provide repository\-backed mock responses with fallback to real execution. This enables deterministic tool testing while maintaining the ability to fall back to real tool execution when needed.

```go
type RepositoryToolExecutor struct {
    // contains filtered or unexported fields
}
```

<a name="NewRepositoryToolExecutor"></a>
### func NewRepositoryToolExecutor

```go
func NewRepositoryToolExecutor(baseExecutor Executor, repo ToolResponseRepository, contextKey string) *RepositoryToolExecutor
```

NewRepositoryToolExecutor creates a new repository\-backed tool executor. The executor will first check the repository for configured responses, and fall back to the base executor if no match is found.

<a name="RepositoryToolExecutor.Execute"></a>
### func \(\*RepositoryToolExecutor\) Execute

```go
func (e *RepositoryToolExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool, first checking the repository for mock responses. If a matching response is found in the repository, it returns that response. Otherwise, it falls back to the base executor for real execution.

<a name="RepositoryToolExecutor.Name"></a>
### func \(\*RepositoryToolExecutor\) Name

```go
func (e *RepositoryToolExecutor) Name() string
```

Name returns the executor name with repository suffix.

<a name="SchemaValidator"></a>
## type SchemaValidator

SchemaValidator handles JSON schema validation for tool inputs and outputs

```go
type SchemaValidator struct {
    // contains filtered or unexported fields
}
```

<a name="NewSchemaValidator"></a>
### func NewSchemaValidator

```go
func NewSchemaValidator() *SchemaValidator
```

NewSchemaValidator creates a new schema validator

<a name="SchemaValidator.CoerceResult"></a>
### func \(\*SchemaValidator\) CoerceResult

```go
func (sv *SchemaValidator) CoerceResult(descriptor *ToolDescriptor, result json.RawMessage) (json.RawMessage, []Coercion, error)
```

CoerceResult attempts to coerce simple type mismatches in tool results

<a name="SchemaValidator.ValidateArgs"></a>
### func \(\*SchemaValidator\) ValidateArgs

```go
func (sv *SchemaValidator) ValidateArgs(descriptor *ToolDescriptor, args json.RawMessage) error
```

ValidateArgs validates tool arguments against the input schema

<a name="SchemaValidator.ValidateResult"></a>
### func \(\*SchemaValidator\) ValidateResult

```go
func (sv *SchemaValidator) ValidateResult(descriptor *ToolDescriptor, result json.RawMessage) error
```

ValidateResult validates tool result against the output schema

<a name="ToolCall"></a>
## type ToolCall

ToolCall represents a tool invocation request

```go
type ToolCall struct {
    Name string          `json:"name"`
    Args json.RawMessage `json:"args"`
    ID   string          `json:"id"` // Provider-specific call ID
}
```

<a name="ToolConfig"></a>
## type ToolConfig

ToolConfig represents a K8s\-style tool configuration manifest

```go
type ToolConfig struct {
    APIVersion string            `yaml:"apiVersion"`
    Kind       string            `yaml:"kind"`
    Metadata   metav1.ObjectMeta `yaml:"metadata,omitempty"`
    Spec       ToolDescriptor    `yaml:"spec"`
}
```

<a name="ToolDescriptor"></a>
## type ToolDescriptor

ToolDescriptor represents a normalized tool definition

```go
type ToolDescriptor struct {
    Name         string          `json:"name" yaml:"name"`
    Description  string          `json:"description" yaml:"description"`
    InputSchema  json.RawMessage `json:"input_schema" yaml:"input_schema"`   // JSON Schema Draft-07
    OutputSchema json.RawMessage `json:"output_schema" yaml:"output_schema"` // JSON Schema Draft-07
    Mode         string          `json:"mode" yaml:"mode"`                   // "mock" | "live"
    TimeoutMs    int             `json:"timeout_ms" yaml:"timeout_ms"`

    // Static mock data (in-memory)
    MockResult json.RawMessage `json:"mock_result,omitempty" yaml:"mock_result,omitempty"`
    // Template for dynamic mocks (inline or file)
    MockTemplate     string `json:"mock_template,omitempty" yaml:"mock_template,omitempty"`
    MockResultFile   string `json:"mock_result_file,omitempty" yaml:"mock_result_file,omitempty"`
    MockTemplateFile string `json:"mock_template_file,omitempty" yaml:"mock_template_file,omitempty"`

    HTTPConfig *HTTPConfig `json:"http,omitempty" yaml:"http,omitempty"` // Live HTTP configuration
}
```

<a name="ToolErrorData"></a>
## type ToolErrorData

ToolErrorData represents an error response for tool execution.

```go
type ToolErrorData struct {
    Type    string `json:"type"`    // Error type/category
    Message string `json:"message"` // Error message
}
```

<a name="ToolExecutionResult"></a>
## type ToolExecutionResult

ToolExecutionResult includes status and optional pending information

```go
type ToolExecutionResult struct {
    Status  ToolExecutionStatus `json:"status"`
    Content json.RawMessage     `json:"content,omitempty"`
    Error   string              `json:"error,omitempty"`

    // Present when Status == ToolStatusPending
    PendingInfo *PendingToolInfo `json:"pending_info,omitempty"`
}
```

<a name="ToolExecutionStatus"></a>
## type ToolExecutionStatus

ToolExecutionStatus represents whether a tool completed or needs external input

```go
type ToolExecutionStatus string
```

<a name="ToolStatusComplete"></a>

```go
const (
    // ToolStatusComplete indicates the tool finished executing
    ToolStatusComplete ToolExecutionStatus = "complete"
    // ToolStatusPending indicates the tool is waiting for external input (e.g., human approval)
    ToolStatusPending ToolExecutionStatus = "pending"
    // ToolStatusFailed indicates the tool execution failed
    ToolStatusFailed ToolExecutionStatus = "failed"
)
```

<a name="ToolGuidance"></a>
## type ToolGuidance

ToolGuidance provides hints for different interaction modes This is a flexible structure that can be extended with task\-specific guidance

```go
type ToolGuidance struct {
    Support   string `json:"support,omitempty"`
    Assistant string `json:"assistant,omitempty"`
    Generic   string `json:"generic,omitempty"`
}
```

<a name="ToolPolicy"></a>
## type ToolPolicy

ToolPolicy defines constraints for tool usage in scenarios

```go
type ToolPolicy struct {
    ToolChoice          string   `json:"tool_choice"` // "auto" | "required" | "none"
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn"`
    MaxTotalToolCalls   int      `json:"max_total_tool_calls"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="ToolRepository"></a>
## type ToolRepository

ToolRepository provides abstract access to tool descriptors \(local interface to avoid import cycles\)

```go
type ToolRepository interface {
    LoadTool(name string) (*ToolDescriptor, error)
    ListTools() ([]string, error)
    SaveTool(descriptor *ToolDescriptor) error
}
```

<a name="ToolResponseData"></a>
## type ToolResponseData

ToolResponseData represents a configured tool response with optional error.

```go
type ToolResponseData struct {
    Result interface{}    `json:"result,omitempty"` // Successful response data
    Error  *ToolErrorData `json:"error,omitempty"`  // Error response
}
```

<a name="ToolResponseRepository"></a>
## type ToolResponseRepository

ToolResponseRepository defines the interface for repositories that can provide mock tool responses based on tool name, arguments, and context.

```go
type ToolResponseRepository interface {
    // GetToolResponse retrieves a mock response for a tool execution.
    // Returns nil if no matching response is configured (not an error).
    GetToolResponse(toolName string, args map[string]interface{}, contextKey string) (*ToolResponseData, error)
}
```

<a name="ToolResult"></a>
## type ToolResult

ToolResult represents the result of a tool execution

```go
type ToolResult struct {
    Name      string          `json:"name"`
    ID        string          `json:"id"` // Matches ToolCall.ID
    Result    json.RawMessage `json:"result"`
    LatencyMs int64           `json:"latency_ms"`
    Error     string          `json:"error,omitempty"`
}
```

<a name="ToolStats"></a>
## type ToolStats

ToolStats tracks tool usage statistics

```go
type ToolStats struct {
    TotalCalls int            `json:"total_calls"`
    ByTool     map[string]int `json:"by_tool"`
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a tool validation failure

```go
type ValidationError struct {
    Type   string `json:"type"` // "args_invalid" | "result_invalid" | "policy_violation"
    Tool   string `json:"tool"`
    Detail string `json:"detail"`
    Path   string `json:"path,omitempty"`
}
```

<a name="ValidationError.Error"></a>
### func \(\*ValidationError\) Error

```go
func (e *ValidationError) Error() string
```

Error implements the error interface

# tts

```go
import "github.com/AltairaLabs/PromptKit/runtime/tts"
```

Package tts provides text\-to\-speech services. This file contains WebSocket streaming implementation for Cartesia TTS. It is excluded from coverage testing due to the difficulty of mocking WebSocket connections.

Package tts provides text\-to\-speech services for converting text responses to audio.

The package defines a common Service interface that abstracts TTS providers, enabling voice AI applications to convert text\-only LLM responses to speech.

### Architecture

The package provides:

- Service interface for TTS providers
- SynthesisConfig for voice/format configuration
- Voice and AudioFormat types for provider capabilities
- Multiple provider implementations \(OpenAI, ElevenLabs, etc.\)

### Usage

Basic usage with OpenAI TTS:

```
service := tts.NewOpenAI(os.Getenv("OPENAI_API_KEY"))
reader, err := service.Synthesize(ctx, "Hello world", tts.SynthesisConfig{
    Voice:  "alloy",
    Format: tts.FormatMP3,
})
if err != nil {
    log.Fatal(err)
}
defer reader.Close()

// Stream audio to speaker or save to file
io.Copy(audioOutput, reader)
```

### Streaming TTS

For low\-latency applications, use StreamingService:

```
streamer := tts.NewCartesia(os.Getenv("CARTESIA_API_KEY"))
chunks, err := streamer.SynthesizeStream(ctx, "Hello world", config)
for chunk := range chunks {
    // Play audio chunk immediately
    speaker.Write(chunk)
}
```

### Available Providers

The package includes implementations for:

- OpenAI TTS \(tts\-1, tts\-1\-hd models\)
- ElevenLabs \(high\-quality voice cloning\)
- Cartesia \(ultra\-low latency streaming\)
- Google Cloud Text\-to\-Speech \(multi\-language\)

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [type AudioChunk](<#AudioChunk>)
- [type AudioFormat](<#AudioFormat>)
  - [func \(f AudioFormat\) String\(\) string](<#AudioFormat.String>)
- [type CartesiaOption](<#CartesiaOption>)
  - [func WithCartesiaBaseURL\(url string\) CartesiaOption](<#WithCartesiaBaseURL>)
  - [func WithCartesiaClient\(client \*http.Client\) CartesiaOption](<#WithCartesiaClient>)
  - [func WithCartesiaModel\(model string\) CartesiaOption](<#WithCartesiaModel>)
  - [func WithCartesiaWSURL\(url string\) CartesiaOption](<#WithCartesiaWSURL>)
- [type CartesiaService](<#CartesiaService>)
  - [func NewCartesia\(apiKey string, opts ...CartesiaOption\) \*CartesiaService](<#NewCartesia>)
  - [func \(s \*CartesiaService\) Name\(\) string](<#CartesiaService.Name>)
  - [func \(s \*CartesiaService\) SupportedFormats\(\) \[\]AudioFormat](<#CartesiaService.SupportedFormats>)
  - [func \(s \*CartesiaService\) SupportedVoices\(\) \[\]Voice](<#CartesiaService.SupportedVoices>)
  - [func \(s \*CartesiaService\) Synthesize\(ctx context.Context, text string, config SynthesisConfig\) \(io.ReadCloser, error\)](<#CartesiaService.Synthesize>)
  - [func \(s \*CartesiaService\) SynthesizeStream\(ctx context.Context, text string, config SynthesisConfig\) \(\<\-chan AudioChunk, error\)](<#CartesiaService.SynthesizeStream>)
- [type ElevenLabsOption](<#ElevenLabsOption>)
  - [func WithElevenLabsBaseURL\(url string\) ElevenLabsOption](<#WithElevenLabsBaseURL>)
  - [func WithElevenLabsClient\(client \*http.Client\) ElevenLabsOption](<#WithElevenLabsClient>)
  - [func WithElevenLabsModel\(model string\) ElevenLabsOption](<#WithElevenLabsModel>)
- [type ElevenLabsService](<#ElevenLabsService>)
  - [func NewElevenLabs\(apiKey string, opts ...ElevenLabsOption\) \*ElevenLabsService](<#NewElevenLabs>)
  - [func \(s \*ElevenLabsService\) Name\(\) string](<#ElevenLabsService.Name>)
  - [func \(s \*ElevenLabsService\) SupportedFormats\(\) \[\]AudioFormat](<#ElevenLabsService.SupportedFormats>)
  - [func \(s \*ElevenLabsService\) SupportedVoices\(\) \[\]Voice](<#ElevenLabsService.SupportedVoices>)
  - [func \(s \*ElevenLabsService\) Synthesize\(ctx context.Context, text string, config SynthesisConfig\) \(io.ReadCloser, error\)](<#ElevenLabsService.Synthesize>)
- [type OpenAIOption](<#OpenAIOption>)
  - [func WithOpenAIBaseURL\(url string\) OpenAIOption](<#WithOpenAIBaseURL>)
  - [func WithOpenAIClient\(client \*http.Client\) OpenAIOption](<#WithOpenAIClient>)
  - [func WithOpenAIModel\(model string\) OpenAIOption](<#WithOpenAIModel>)
- [type OpenAIService](<#OpenAIService>)
  - [func NewOpenAI\(apiKey string, opts ...OpenAIOption\) \*OpenAIService](<#NewOpenAI>)
  - [func \(s \*OpenAIService\) Name\(\) string](<#OpenAIService.Name>)
  - [func \(s \*OpenAIService\) SupportedFormats\(\) \[\]AudioFormat](<#OpenAIService.SupportedFormats>)
  - [func \(s \*OpenAIService\) SupportedVoices\(\) \[\]Voice](<#OpenAIService.SupportedVoices>)
  - [func \(s \*OpenAIService\) Synthesize\(ctx context.Context, text string, config SynthesisConfig\) \(io.ReadCloser, error\)](<#OpenAIService.Synthesize>)
- [type Service](<#Service>)
- [type StreamingService](<#StreamingService>)
- [type SynthesisConfig](<#SynthesisConfig>)
  - [func DefaultSynthesisConfig\(\) SynthesisConfig](<#DefaultSynthesisConfig>)
- [type SynthesisError](<#SynthesisError>)
  - [func NewSynthesisError\(provider, code, message string, cause error, retryable bool\) \*SynthesisError](<#NewSynthesisError>)
  - [func \(e \*SynthesisError\) Error\(\) string](<#SynthesisError.Error>)
  - [func \(e \*SynthesisError\) Unwrap\(\) error](<#SynthesisError.Unwrap>)
- [type Voice](<#Voice>)


## Constants

<a name="ElevenLabsModelMultilingual"></a>

```go
const (

    // ElevenLabsModelMultilingual is the multilingual v2 model.
    ElevenLabsModelMultilingual = "eleven_multilingual_v2"
    // ElevenLabsModelTurbo is the fast turbo v2.5 model.
    ElevenLabsModelTurbo = "eleven_turbo_v2_5"
    // ElevenLabsModelEnglish is the English monolingual v1 model.
    ElevenLabsModelEnglish = "eleven_monolingual_v1"
    // ElevenLabsModelMultilingualV1 is the older multilingual v1 model.
    ElevenLabsModelMultilingualV1 = "eleven_multilingual_v1"
)
```

<a name="ModelTTS1"></a>

```go
const (

    // ModelTTS1 is the OpenAI TTS model optimized for speed.
    ModelTTS1 = "tts-1"
    // ModelTTS1HD is the OpenAI TTS model optimized for quality.
    ModelTTS1HD = "tts-1-hd"
)
```

<a name="VoiceAlloy"></a>OpenAI voices.

```go
const (
    VoiceAlloy   = "alloy"   // Neutral voice.
    VoiceEcho    = "echo"    // Male voice.
    VoiceFable   = "fable"   // British accent.
    VoiceOnyx    = "onyx"    // Deep male voice.
    VoiceNova    = "nova"    // Female voice.
    VoiceShimmer = "shimmer" // Soft female voice.
)
```

<a name="CartesiaModelSonic"></a>

```go
const (

    // CartesiaModelSonic is the latest Sonic model for Cartesia TTS.
    CartesiaModelSonic = "sonic-2024-10-01"
)
```

## Variables

<a name="ErrInvalidVoice"></a>Common TTS errors.

```go
var (
    // ErrInvalidVoice is returned when the requested voice is not available.
    ErrInvalidVoice = errors.New("invalid or unsupported voice")

    // ErrInvalidFormat is returned when the requested format is not supported.
    ErrInvalidFormat = errors.New("invalid or unsupported audio format")

    // ErrEmptyText is returned when attempting to synthesize empty text.
    ErrEmptyText = errors.New("text cannot be empty")

    // ErrSynthesisFailed is returned when TTS synthesis fails.
    ErrSynthesisFailed = errors.New("speech synthesis failed")

    // ErrRateLimited is returned when API rate limits are exceeded.
    ErrRateLimited = errors.New("rate limit exceeded")

    // ErrQuotaExceeded is returned when account quota is exceeded.
    ErrQuotaExceeded = errors.New("quota exceeded")

    // ErrServiceUnavailable is returned when the TTS service is unavailable.
    ErrServiceUnavailable = errors.New("TTS service unavailable")
)
```

<a name="FormatMP3"></a>Common audio formats.

```go
var (
    // FormatMP3 is MP3 format (most compatible).
    FormatMP3 = AudioFormat{
        Name:       "mp3",
        MIMEType:   "audio/mpeg",
        SampleRate: sampleRateDefault,
        BitDepth:   0,
        Channels:   1,
    }

    // FormatOpus is Opus format (best for streaming).
    FormatOpus = AudioFormat{
        Name:       "opus",
        MIMEType:   "audio/opus",
        SampleRate: sampleRateDefault,
        BitDepth:   0,
        Channels:   1,
    }

    // FormatAAC is AAC format.
    FormatAAC = AudioFormat{
        Name:       "aac",
        MIMEType:   "audio/aac",
        SampleRate: sampleRateDefault,
        BitDepth:   0,
        Channels:   1,
    }

    // FormatFLAC is FLAC format (lossless).
    FormatFLAC = AudioFormat{
        Name:       "flac",
        MIMEType:   "audio/flac",
        SampleRate: sampleRateDefault,
        BitDepth:   bitDepthDefault,
        Channels:   1,
    }

    // FormatPCM16 is raw 16-bit PCM (for processing).
    FormatPCM16 = AudioFormat{
        Name:       "pcm",
        MIMEType:   "audio/pcm",
        SampleRate: sampleRateDefault,
        BitDepth:   bitDepthDefault,
        Channels:   1,
    }

    // FormatWAV is WAV format (PCM with header).
    FormatWAV = AudioFormat{
        Name:       "wav",
        MIMEType:   "audio/wav",
        SampleRate: sampleRateDefault,
        BitDepth:   bitDepthDefault,
        Channels:   1,
    }
)
```

<a name="AudioChunk"></a>
## type AudioChunk

AudioChunk represents a chunk of synthesized audio data.

```go
type AudioChunk struct {
    // Data is the raw audio bytes.
    Data []byte

    // Index is the chunk sequence number (0-indexed).
    Index int

    // Final indicates this is the last chunk.
    Final bool

    // Error is set if an error occurred during synthesis.
    Error error
}
```

<a name="AudioFormat"></a>
## type AudioFormat

AudioFormat describes an audio output format.

```go
type AudioFormat struct {
    // Name is the format identifier ("mp3", "opus", "pcm", "aac", "flac").
    Name string

    // MIMEType is the content type (e.g., "audio/mpeg").
    MIMEType string

    // SampleRate is the audio sample rate in Hz.
    SampleRate int

    // BitDepth is the bits per sample (for PCM formats).
    BitDepth int

    // Channels is the number of audio channels (1=mono, 2=stereo).
    Channels int
}
```

<a name="AudioFormat.String"></a>
### func \(AudioFormat\) String

```go
func (f AudioFormat) String() string
```

String returns the format name.

<a name="CartesiaOption"></a>
## type CartesiaOption

CartesiaOption configures the Cartesia TTS service.

```go
type CartesiaOption func(*CartesiaService)
```

<a name="WithCartesiaBaseURL"></a>
### func WithCartesiaBaseURL

```go
func WithCartesiaBaseURL(url string) CartesiaOption
```

WithCartesiaBaseURL sets a custom base URL.

<a name="WithCartesiaClient"></a>
### func WithCartesiaClient

```go
func WithCartesiaClient(client *http.Client) CartesiaOption
```

WithCartesiaClient sets a custom HTTP client.

<a name="WithCartesiaModel"></a>
### func WithCartesiaModel

```go
func WithCartesiaModel(model string) CartesiaOption
```

WithCartesiaModel sets the TTS model.

<a name="WithCartesiaWSURL"></a>
### func WithCartesiaWSURL

```go
func WithCartesiaWSURL(url string) CartesiaOption
```

WithCartesiaWSURL sets a custom WebSocket URL.

<a name="CartesiaService"></a>
## type CartesiaService

CartesiaService implements TTS using Cartesia's ultra\-low latency API. Cartesia specializes in real\-time streaming TTS with \<100ms first\-byte latency.

```go
type CartesiaService struct {
    // contains filtered or unexported fields
}
```

<a name="NewCartesia"></a>
### func NewCartesia

```go
func NewCartesia(apiKey string, opts ...CartesiaOption) *CartesiaService
```

NewCartesia creates a Cartesia TTS service.

<a name="CartesiaService.Name"></a>
### func \(\*CartesiaService\) Name

```go
func (s *CartesiaService) Name() string
```

Name returns the provider identifier.

<a name="CartesiaService.SupportedFormats"></a>
### func \(\*CartesiaService\) SupportedFormats

```go
func (s *CartesiaService) SupportedFormats() []AudioFormat
```

SupportedFormats returns audio formats supported by Cartesia.

<a name="CartesiaService.SupportedVoices"></a>
### func \(\*CartesiaService\) SupportedVoices

```go
func (s *CartesiaService) SupportedVoices() []Voice
```

SupportedVoices returns a sample of available Cartesia voices.

<a name="CartesiaService.Synthesize"></a>
### func \(\*CartesiaService\) Synthesize

```go
func (s *CartesiaService) Synthesize(ctx context.Context, text string, config SynthesisConfig) (io.ReadCloser, error)
```

Synthesize converts text to audio using Cartesia's REST API. For streaming output, use SynthesizeStream instead.

<a name="CartesiaService.SynthesizeStream"></a>
### func \(\*CartesiaService\) SynthesizeStream

```go
func (s *CartesiaService) SynthesizeStream(ctx context.Context, text string, config SynthesisConfig) (<-chan AudioChunk, error)
```

SynthesizeStream converts text to audio with streaming output via WebSocket. This provides ultra\-low latency \(\<100ms first\-byte\) for real\-time applications.

<a name="ElevenLabsOption"></a>
## type ElevenLabsOption

ElevenLabsOption configures the ElevenLabs TTS service.

```go
type ElevenLabsOption func(*ElevenLabsService)
```

<a name="WithElevenLabsBaseURL"></a>
### func WithElevenLabsBaseURL

```go
func WithElevenLabsBaseURL(url string) ElevenLabsOption
```

WithElevenLabsBaseURL sets a custom base URL.

<a name="WithElevenLabsClient"></a>
### func WithElevenLabsClient

```go
func WithElevenLabsClient(client *http.Client) ElevenLabsOption
```

WithElevenLabsClient sets a custom HTTP client.

<a name="WithElevenLabsModel"></a>
### func WithElevenLabsModel

```go
func WithElevenLabsModel(model string) ElevenLabsOption
```

WithElevenLabsModel sets the TTS model.

<a name="ElevenLabsService"></a>
## type ElevenLabsService

ElevenLabsService implements TTS using ElevenLabs' API. ElevenLabs specializes in high\-quality voice cloning and natural\-sounding speech.

```go
type ElevenLabsService struct {
    // contains filtered or unexported fields
}
```

<a name="NewElevenLabs"></a>
### func NewElevenLabs

```go
func NewElevenLabs(apiKey string, opts ...ElevenLabsOption) *ElevenLabsService
```

NewElevenLabs creates an ElevenLabs TTS service.

<a name="ElevenLabsService.Name"></a>
### func \(\*ElevenLabsService\) Name

```go
func (s *ElevenLabsService) Name() string
```

Name returns the provider identifier.

<a name="ElevenLabsService.SupportedFormats"></a>
### func \(\*ElevenLabsService\) SupportedFormats

```go
func (s *ElevenLabsService) SupportedFormats() []AudioFormat
```

SupportedFormats returns audio formats supported by ElevenLabs.

<a name="ElevenLabsService.SupportedVoices"></a>
### func \(\*ElevenLabsService\) SupportedVoices

```go
func (s *ElevenLabsService) SupportedVoices() []Voice
```

SupportedVoices returns a sample of available ElevenLabs voices. Note: ElevenLabs has many more voices including custom cloned voices. Use the ElevenLabs API to get a complete list of available voices.

<a name="ElevenLabsService.Synthesize"></a>
### func \(\*ElevenLabsService\) Synthesize

```go
func (s *ElevenLabsService) Synthesize(ctx context.Context, text string, config SynthesisConfig) (io.ReadCloser, error)
```

Synthesize converts text to audio using ElevenLabs' TTS API.

<a name="OpenAIOption"></a>
## type OpenAIOption

OpenAIOption configures the OpenAI TTS service.

```go
type OpenAIOption func(*OpenAIService)
```

<a name="WithOpenAIBaseURL"></a>
### func WithOpenAIBaseURL

```go
func WithOpenAIBaseURL(url string) OpenAIOption
```

WithOpenAIBaseURL sets a custom base URL \(for testing or proxies\).

<a name="WithOpenAIClient"></a>
### func WithOpenAIClient

```go
func WithOpenAIClient(client *http.Client) OpenAIOption
```

WithOpenAIClient sets a custom HTTP client.

<a name="WithOpenAIModel"></a>
### func WithOpenAIModel

```go
func WithOpenAIModel(model string) OpenAIOption
```

WithOpenAIModel sets the TTS model to use.

<a name="OpenAIService"></a>
## type OpenAIService

OpenAIService implements TTS using OpenAI's text\-to\-speech API.

```go
type OpenAIService struct {
    // contains filtered or unexported fields
}
```

<a name="NewOpenAI"></a>
### func NewOpenAI

```go
func NewOpenAI(apiKey string, opts ...OpenAIOption) *OpenAIService
```

NewOpenAI creates an OpenAI TTS service.

<a name="OpenAIService.Name"></a>
### func \(\*OpenAIService\) Name

```go
func (s *OpenAIService) Name() string
```

Name returns the provider identifier.

<a name="OpenAIService.SupportedFormats"></a>
### func \(\*OpenAIService\) SupportedFormats

```go
func (s *OpenAIService) SupportedFormats() []AudioFormat
```

SupportedFormats returns audio formats supported by OpenAI TTS.

<a name="OpenAIService.SupportedVoices"></a>
### func \(\*OpenAIService\) SupportedVoices

```go
func (s *OpenAIService) SupportedVoices() []Voice
```

SupportedVoices returns available OpenAI voices.

<a name="OpenAIService.Synthesize"></a>
### func \(\*OpenAIService\) Synthesize

```go
func (s *OpenAIService) Synthesize(ctx context.Context, text string, config SynthesisConfig) (io.ReadCloser, error)
```

Synthesize converts text to audio using OpenAI's TTS API.

<a name="Service"></a>
## type Service

Service converts text to speech audio. This interface abstracts different TTS providers \(OpenAI, ElevenLabs, etc.\) enabling voice AI applications to use any provider interchangeably.

```go
type Service interface {
    // Name returns the provider identifier (for logging/debugging).
    Name() string

    // Synthesize converts text to audio.
    // Returns a reader for streaming audio data.
    // The caller is responsible for closing the reader.
    Synthesize(ctx context.Context, text string, config SynthesisConfig) (io.ReadCloser, error)

    // SupportedVoices returns available voices for this provider.
    SupportedVoices() []Voice

    // SupportedFormats returns supported audio output formats.
    SupportedFormats() []AudioFormat
}
```

<a name="StreamingService"></a>
## type StreamingService

StreamingService extends Service with streaming synthesis capabilities. Streaming TTS provides lower latency by returning audio chunks as they're generated.

```go
type StreamingService interface {
    Service

    // SynthesizeStream converts text to audio with streaming output.
    // Returns a channel that receives audio chunks as they're generated.
    // The channel is closed when synthesis completes or an error occurs.
    SynthesizeStream(ctx context.Context, text string, config SynthesisConfig) (<-chan AudioChunk, error)
}
```

<a name="SynthesisConfig"></a>
## type SynthesisConfig

SynthesisConfig configures text\-to\-speech synthesis.

```go
type SynthesisConfig struct {
    // Voice is the voice ID to use for synthesis.
    // Available voices vary by provider - use SupportedVoices() to list options.
    Voice string

    // Format is the output audio format.
    // Default is MP3 for most providers.
    Format AudioFormat

    // Speed is the speech rate multiplier (0.25-4.0, default 1.0).
    // Not all providers support speed adjustment.
    Speed float64

    // Pitch adjusts the voice pitch (-20 to 20 semitones, default 0).
    // Not all providers support pitch adjustment.
    Pitch float64

    // Language is the language code for synthesis (e.g., "en-US").
    // Required for some providers, optional for others.
    Language string

    // Model is the TTS model to use (provider-specific).
    // For OpenAI: "tts-1" (fast) or "tts-1-hd" (high quality).
    Model string
}
```

<a name="DefaultSynthesisConfig"></a>
### func DefaultSynthesisConfig

```go
func DefaultSynthesisConfig() SynthesisConfig
```

DefaultSynthesisConfig returns sensible defaults for synthesis.

<a name="SynthesisError"></a>
## type SynthesisError

SynthesisError provides detailed error information from TTS providers.

```go
type SynthesisError struct {
    // Provider is the TTS provider that returned the error.
    Provider string

    // Code is the provider-specific error code.
    Code string

    // Message is the error message.
    Message string

    // Cause is the underlying error (if any).
    Cause error

    // Retryable indicates if the error is transient and retry may succeed.
    Retryable bool
}
```

<a name="NewSynthesisError"></a>
### func NewSynthesisError

```go
func NewSynthesisError(provider, code, message string, cause error, retryable bool) *SynthesisError
```

NewSynthesisError creates a new SynthesisError.

<a name="SynthesisError.Error"></a>
### func \(\*SynthesisError\) Error

```go
func (e *SynthesisError) Error() string
```

Error implements the error interface.

<a name="SynthesisError.Unwrap"></a>
### func \(\*SynthesisError\) Unwrap

```go
func (e *SynthesisError) Unwrap() error
```

Unwrap returns the underlying error.

<a name="Voice"></a>
## type Voice

Voice describes a TTS voice available from a provider.

```go
type Voice struct {
    // ID is the provider-specific voice identifier.
    ID  string

    // Name is a human-readable voice name.
    Name string

    // Language is the primary language code (e.g., "en", "es", "fr").
    Language string

    // Gender is the voice gender ("male", "female", "neutral").
    Gender string

    // Description provides additional voice characteristics.
    Description string

    // Preview is a URL to a voice sample (if available).
    Preview string
}
```

# types

```go
import "github.com/AltairaLabs/PromptKit/runtime/types"
```

## Index

- [Constants](<#constants>)
- [func CountMediaParts\(msg Message\) int](<#CountMediaParts>)
- [func CountPartsByType\(msg Message, contentType string\) int](<#CountPartsByType>)
- [func ExtractTextContent\(msg Message\) string](<#ExtractTextContent>)
- [func HasOnlyTextContent\(msg Message\) bool](<#HasOnlyTextContent>)
- [func MigrateMessagesToLegacy\(messages \[\]Message\) error](<#MigrateMessagesToLegacy>)
- [func MigrateMessagesToMultimodal\(messages \[\]Message\)](<#MigrateMessagesToMultimodal>)
- [func MigrateToLegacy\(msg \*Message\) error](<#MigrateToLegacy>)
- [func MigrateToMultimodal\(msg \*Message\)](<#MigrateToMultimodal>)
- [type ChunkReader](<#ChunkReader>)
  - [func NewChunkReader\(r io.Reader, config StreamingMediaConfig\) \*ChunkReader](<#NewChunkReader>)
  - [func \(cr \*ChunkReader\) NextChunk\(ctx context.Context\) \(\*MediaChunk, error\)](<#ChunkReader.NextChunk>)
- [type ChunkWriter](<#ChunkWriter>)
  - [func NewChunkWriter\(w io.Writer\) \*ChunkWriter](<#NewChunkWriter>)
  - [func \(cw \*ChunkWriter\) Flush\(\) error](<#ChunkWriter.Flush>)
  - [func \(cw \*ChunkWriter\) WriteChunk\(chunk \*MediaChunk\) \(int, error\)](<#ChunkWriter.WriteChunk>)
- [type ContentPart](<#ContentPart>)
  - [func NewAudioPart\(filePath string\) \(ContentPart, error\)](<#NewAudioPart>)
  - [func NewAudioPartFromData\(base64Data, mimeType string\) ContentPart](<#NewAudioPartFromData>)
  - [func NewImagePart\(filePath string, detail \*string\) \(ContentPart, error\)](<#NewImagePart>)
  - [func NewImagePartFromData\(base64Data, mimeType string, detail \*string\) ContentPart](<#NewImagePartFromData>)
  - [func NewImagePartFromURL\(url string, detail \*string\) ContentPart](<#NewImagePartFromURL>)
  - [func NewTextPart\(text string\) ContentPart](<#NewTextPart>)
  - [func NewVideoPart\(filePath string\) \(ContentPart, error\)](<#NewVideoPart>)
  - [func NewVideoPartFromData\(base64Data, mimeType string\) ContentPart](<#NewVideoPartFromData>)
  - [func SplitMultimodalMessage\(msg Message\) \(text string, mediaParts \[\]ContentPart\)](<#SplitMultimodalMessage>)
  - [func \(cp \*ContentPart\) Validate\(\) error](<#ContentPart.Validate>)
- [type CostInfo](<#CostInfo>)
- [type MediaChunk](<#MediaChunk>)
- [type MediaContent](<#MediaContent>)
  - [func \(mc \*MediaContent\) GetBase64Data\(\) \(string, error\)](<#MediaContent.GetBase64Data>)
  - [func \(mc \*MediaContent\) ReadData\(\) \(io.ReadCloser, error\)](<#MediaContent.ReadData>)
  - [func \(mc \*MediaContent\) Validate\(\) error](<#MediaContent.Validate>)
- [type MediaItemSummary](<#MediaItemSummary>)
- [type MediaSummary](<#MediaSummary>)
- [type Message](<#Message>)
  - [func CloneMessage\(msg Message\) Message](<#CloneMessage>)
  - [func CombineTextAndMedia\(role, text string, mediaParts \[\]ContentPart\) Message](<#CombineTextAndMedia>)
  - [func ConvertTextToMultimodal\(role, content string\) Message](<#ConvertTextToMultimodal>)
  - [func \(m \*Message\) AddAudioPart\(filePath string\) error](<#Message.AddAudioPart>)
  - [func \(m \*Message\) AddImagePart\(filePath string, detail \*string\) error](<#Message.AddImagePart>)
  - [func \(m \*Message\) AddImagePartFromURL\(url string, detail \*string\)](<#Message.AddImagePartFromURL>)
  - [func \(m \*Message\) AddPart\(part ContentPart\)](<#Message.AddPart>)
  - [func \(m \*Message\) AddTextPart\(text string\)](<#Message.AddTextPart>)
  - [func \(m \*Message\) AddVideoPart\(filePath string\) error](<#Message.AddVideoPart>)
  - [func \(m \*Message\) GetContent\(\) string](<#Message.GetContent>)
  - [func \(m \*Message\) HasMediaContent\(\) bool](<#Message.HasMediaContent>)
  - [func \(m \*Message\) IsMultimodal\(\) bool](<#Message.IsMultimodal>)
  - [func \(m Message\) MarshalJSON\(\) \(\[\]byte, error\)](<#Message.MarshalJSON>)
  - [func \(m \*Message\) SetMultimodalContent\(parts \[\]ContentPart\)](<#Message.SetMultimodalContent>)
  - [func \(m \*Message\) SetTextContent\(text string\)](<#Message.SetTextContent>)
  - [func \(m \*Message\) UnmarshalJSON\(data \[\]byte\) error](<#Message.UnmarshalJSON>)
- [type MessageToolCall](<#MessageToolCall>)
- [type MessageToolResult](<#MessageToolResult>)
- [type StreamingMediaConfig](<#StreamingMediaConfig>)
  - [func \(c \*StreamingMediaConfig\) Validate\(\) error](<#StreamingMediaConfig.Validate>)
- [type ToolDef](<#ToolDef>)
- [type ToolStats](<#ToolStats>)
- [type ValidationError](<#ValidationError>)
- [type ValidationResult](<#ValidationResult>)


## Constants

<a name="ContentTypeText"></a>ContentType constants for different content part types

```go
const (
    ContentTypeText  = "text"
    ContentTypeImage = "image"
    ContentTypeAudio = "audio"
    ContentTypeVideo = "video"
)
```

<a name="MIMETypeImageJPEG"></a>Common MIME types

```go
const (
    MIMETypeImageJPEG = "image/jpeg"
    MIMETypeImagePNG  = "image/png"
    MIMETypeImageGIF  = "image/gif"
    MIMETypeImageWebP = "image/webp"

    MIMETypeAudioMP3  = "audio/mpeg"
    MIMETypeAudioWAV  = "audio/wav"
    MIMETypeAudioOgg  = "audio/ogg"
    MIMETypeAudioWebM = "audio/webm"

    MIMETypeVideoMP4  = "video/mp4"
    MIMETypeVideoWebM = "video/webm"
    MIMETypeVideoOgg  = "video/ogg"
)
```

<a name="CountMediaParts"></a>
## func CountMediaParts

```go
func CountMediaParts(msg Message) int
```

CountMediaParts returns the number of media parts \(image, audio, video\) in a message

<a name="CountPartsByType"></a>
## func CountPartsByType

```go
func CountPartsByType(msg Message, contentType string) int
```

CountPartsByType returns the number of parts of a specific type in a message

<a name="ExtractTextContent"></a>
## func ExtractTextContent

```go
func ExtractTextContent(msg Message) string
```

ExtractTextContent extracts all text content from a message, regardless of format. This is useful for backward compatibility when you need just the text.

<a name="HasOnlyTextContent"></a>
## func HasOnlyTextContent

```go
func HasOnlyTextContent(msg Message) bool
```

HasOnlyTextContent returns true if the message contains only text \(no media\)

<a name="MigrateMessagesToLegacy"></a>
## func MigrateMessagesToLegacy

```go
func MigrateMessagesToLegacy(messages []Message) error
```

MigrateMessagesToLegacy converts a slice of multimodal messages to legacy format in\-place. Returns an error if any message contains media content.

<a name="MigrateMessagesToMultimodal"></a>
## func MigrateMessagesToMultimodal

```go
func MigrateMessagesToMultimodal(messages []Message)
```

MigrateMessagesToMultimodal converts a slice of legacy messages to multimodal format in\-place

<a name="MigrateToLegacy"></a>
## func MigrateToLegacy

```go
func MigrateToLegacy(msg *Message) error
```

MigrateToLegacy converts a multimodal message back to legacy text\-only format. This is useful for backward compatibility with systems that don't support multimodal. Returns an error if the message contains non\-text content.

<a name="MigrateToMultimodal"></a>
## func MigrateToMultimodal

```go
func MigrateToMultimodal(msg *Message)
```

MigrateToMultimodal converts a legacy text\-only message to use the Parts structure. This is useful when transitioning existing code to the new multimodal API.

<a name="ChunkReader"></a>
## type ChunkReader

ChunkReader reads from an io.Reader and produces MediaChunks. Useful for converting continuous streams \(e.g., microphone input\) into chunks.

Example usage:

```
reader := NewChunkReader(micInput, config)
for {
    chunk, err := reader.NextChunk(ctx)
    if err == io.EOF {
        break
    }
    if err != nil {
        return err
    }
    session.SendChunk(ctx, chunk)
}
```

```go
type ChunkReader struct {
    // contains filtered or unexported fields
}
```

<a name="NewChunkReader"></a>
### func NewChunkReader

```go
func NewChunkReader(r io.Reader, config StreamingMediaConfig) *ChunkReader
```

NewChunkReader creates a new ChunkReader that reads from the given reader and produces MediaChunks according to the config.

<a name="ChunkReader.NextChunk"></a>
### func \(\*ChunkReader\) NextChunk

```go
func (cr *ChunkReader) NextChunk(ctx context.Context) (*MediaChunk, error)
```

NextChunk reads the next chunk from the reader. Returns io.EOF when the stream is complete. The returned chunk's IsLast field will be true on the final chunk.

<a name="ChunkWriter"></a>
## type ChunkWriter

ChunkWriter writes MediaChunks to an io.Writer. Useful for converting chunks back into continuous streams \(e.g., speaker output\).

Example usage:

```
writer := NewChunkWriter(speakerOutput)
for chunk := range session.Response() {
    if chunk.MediaDelta != nil {
        err := writer.WriteChunk(chunk.MediaDelta)
        if err != nil {
            return err
        }
    }
}
```

```go
type ChunkWriter struct {
    // contains filtered or unexported fields
}
```

<a name="NewChunkWriter"></a>
### func NewChunkWriter

```go
func NewChunkWriter(w io.Writer) *ChunkWriter
```

NewChunkWriter creates a new ChunkWriter that writes to the given writer.

<a name="ChunkWriter.Flush"></a>
### func \(\*ChunkWriter\) Flush

```go
func (cw *ChunkWriter) Flush() error
```

Flush flushes any buffered data to the underlying writer \(if it supports flushing\).

<a name="ChunkWriter.WriteChunk"></a>
### func \(\*ChunkWriter\) WriteChunk

```go
func (cw *ChunkWriter) WriteChunk(chunk *MediaChunk) (int, error)
```

WriteChunk writes a MediaChunk to the underlying writer. Returns the number of bytes written and any error encountered.

<a name="ContentPart"></a>
## type ContentPart

ContentPart represents a single piece of content in a multimodal message. A message can contain multiple parts: text, images, audio, video, etc.

```go
type ContentPart struct {
    Type string `json:"type"` // "text", "image", "audio", "video"

    // For text content
    Text *string `json:"text,omitempty"`

    // For media content (image, audio, video)
    Media *MediaContent `json:"media,omitempty"`
}
```

<a name="NewAudioPart"></a>
### func NewAudioPart

```go
func NewAudioPart(filePath string) (ContentPart, error)
```

NewAudioPart creates a ContentPart with audio content from a file path

<a name="NewAudioPartFromData"></a>
### func NewAudioPartFromData

```go
func NewAudioPartFromData(base64Data, mimeType string) ContentPart
```

NewAudioPartFromData creates a ContentPart with base64\-encoded audio data

<a name="NewImagePart"></a>
### func NewImagePart

```go
func NewImagePart(filePath string, detail *string) (ContentPart, error)
```

NewImagePart creates a ContentPart with image content from a file path

<a name="NewImagePartFromData"></a>
### func NewImagePartFromData

```go
func NewImagePartFromData(base64Data, mimeType string, detail *string) ContentPart
```

NewImagePartFromData creates a ContentPart with base64\-encoded image data

<a name="NewImagePartFromURL"></a>
### func NewImagePartFromURL

```go
func NewImagePartFromURL(url string, detail *string) ContentPart
```

NewImagePartFromURL creates a ContentPart with image content from a URL

<a name="NewTextPart"></a>
### func NewTextPart

```go
func NewTextPart(text string) ContentPart
```

NewTextPart creates a ContentPart with text content

<a name="NewVideoPart"></a>
### func NewVideoPart

```go
func NewVideoPart(filePath string) (ContentPart, error)
```

NewVideoPart creates a ContentPart with video content from a file path

<a name="NewVideoPartFromData"></a>
### func NewVideoPartFromData

```go
func NewVideoPartFromData(base64Data, mimeType string) ContentPart
```

NewVideoPartFromData creates a ContentPart with base64\-encoded video data

<a name="SplitMultimodalMessage"></a>
### func SplitMultimodalMessage

```go
func SplitMultimodalMessage(msg Message) (text string, mediaParts []ContentPart)
```

SplitMultimodalMessage splits a multimodal message into separate text and media parts. Returns the text content and a slice of media content parts.

<a name="ContentPart.Validate"></a>
### func \(\*ContentPart\) Validate

```go
func (cp *ContentPart) Validate() error
```

Validate checks if the ContentPart is valid

<a name="CostInfo"></a>
## type CostInfo

CostInfo tracks token usage and associated costs for LLM operations. All cost values are in USD. Used for both individual messages and aggregated tracking.

```go
type CostInfo struct {
    InputTokens   int     `json:"input_tokens"`              // Number of input tokens consumed
    OutputTokens  int     `json:"output_tokens"`             // Number of output tokens generated
    CachedTokens  int     `json:"cached_tokens,omitempty"`   // Number of cached tokens used (reduces cost)
    InputCostUSD  float64 `json:"input_cost_usd"`            // Cost of input tokens in USD
    OutputCostUSD float64 `json:"output_cost_usd"`           // Cost of output tokens in USD
    CachedCostUSD float64 `json:"cached_cost_usd,omitempty"` // Cost savings from cached tokens
    TotalCost     float64 `json:"total_cost_usd"`            // Total cost in USD
}
```

<a name="MediaChunk"></a>
## type MediaChunk

MediaChunk represents a chunk of streaming media data. Used for bidirectional streaming where media is sent or received in chunks.

Example usage:

```
chunk := &MediaChunk{
    Data:        audioData,
    SequenceNum: 1,
    Timestamp:   time.Now(),
    IsLast:      false,
    Metadata:    map[string]string{"mime_type": "audio/pcm"},
}
```

```go
type MediaChunk struct {
    // Data contains the raw media bytes for this chunk
    Data []byte `json:"data"`

    // SequenceNum is the sequence number for ordering chunks (starts at 0)
    SequenceNum int64 `json:"sequence_num"`

    // Timestamp indicates when this chunk was created
    Timestamp time.Time `json:"timestamp"`

    // IsLast indicates if this is the final chunk in the stream
    IsLast bool `json:"is_last"`

    // Metadata contains chunk-specific metadata (MIME type, encoding, etc.)
    Metadata map[string]string `json:"metadata,omitempty"`
}
```

<a name="MediaContent"></a>
## type MediaContent

MediaContent represents media data \(image, audio, video\) in a message. Supports both inline base64 data and external file/URL references.

```go
type MediaContent struct {
    // Data source - exactly one should be set
    Data     *string `json:"data,omitempty"`      // Base64-encoded media data
    FilePath *string `json:"file_path,omitempty"` // Local file path
    URL      *string `json:"url,omitempty"`       // External URL (http/https)

    // Storage backend reference (used when media is externalized)
    StorageReference *string `json:"storage_reference,omitempty"` // Backend-specific storage reference

    // Media metadata
    MIMEType   string  `json:"mime_type"`             // e.g., "image/jpeg", "audio/mp3", "video/mp4"
    Format     *string `json:"format,omitempty"`      // Optional format hint (e.g., "png", "mp3", "mp4")
    SizeKB     *int64  `json:"size_kb,omitempty"`     // Optional size in kilobytes
    Detail     *string `json:"detail,omitempty"`      // Optional detail level for images: "low", "high", "auto"
    Caption    *string `json:"caption,omitempty"`     // Optional caption/description
    Duration   *int    `json:"duration,omitempty"`    // Optional duration in seconds (for audio/video)
    BitRate    *int    `json:"bit_rate,omitempty"`    // Optional bit rate in kbps (for audio/video)
    Channels   *int    `json:"channels,omitempty"`    // Optional number of channels (for audio)
    Width      *int    `json:"width,omitempty"`       // Optional width in pixels (for image/video)
    Height     *int    `json:"height,omitempty"`      // Optional height in pixels (for image/video)
    FPS        *int    `json:"fps,omitempty"`         // Optional frames per second (for video)
    PolicyName *string `json:"policy_name,omitempty"` // Retention policy name
}
```

<a name="MediaContent.GetBase64Data"></a>
### func \(\*MediaContent\) GetBase64Data

```go
func (mc *MediaContent) GetBase64Data() (string, error)
```

GetBase64Data returns the base64\-encoded data for this media content. If the data is already base64\-encoded, it returns it directly. If the data is from a file, it reads and encodes the file. If the data is from a URL or StorageReference, it returns an error \(caller should use MediaLoader\).

Deprecated: For new code, use providers.MediaLoader.GetBase64Data which supports all sources including storage references and URLs with proper context handling.

<a name="MediaContent.ReadData"></a>
### func \(\*MediaContent\) ReadData

```go
func (mc *MediaContent) ReadData() (io.ReadCloser, error)
```

ReadData returns an io.Reader for the media content. For base64 data, it decodes and returns a reader. For file paths, it opens and returns the file. For URLs, it returns an error \(caller should fetch separately\).

<a name="MediaContent.Validate"></a>
### func \(\*MediaContent\) Validate

```go
func (mc *MediaContent) Validate() error
```

Validate checks if the MediaContent is valid

<a name="MediaItemSummary"></a>
## type MediaItemSummary

MediaItemSummary provides details about a single media item in a message.

```go
type MediaItemSummary struct {
    Type      string `json:"type"`             // Content type: "image", "audio", "video"
    Source    string `json:"source"`           // Source description (file path, URL, or "inline data")
    MIMEType  string `json:"mime_type"`        // MIME type
    SizeBytes int    `json:"size_bytes"`       // Size in bytes (0 if unknown)
    Detail    string `json:"detail,omitempty"` // Detail level for images
    Loaded    bool   `json:"loaded"`           // Whether media was successfully loaded
    Error     string `json:"error,omitempty"`  // Error message if loading failed
}
```

<a name="MediaSummary"></a>
## type MediaSummary

MediaSummary provides a high\-level overview of media content in a message. This is included in JSON output to make multimodal messages more observable.

```go
type MediaSummary struct {
    TotalParts int                `json:"total_parts"`           // Total number of content parts
    TextParts  int                `json:"text_parts"`            // Number of text parts
    ImageParts int                `json:"image_parts"`           // Number of image parts
    AudioParts int                `json:"audio_parts"`           // Number of audio parts
    VideoParts int                `json:"video_parts"`           // Number of video parts
    MediaItems []MediaItemSummary `json:"media_items,omitempty"` // Details of each media item
}
```

<a name="Message"></a>
## type Message

Message represents a single message in a conversation. This is the canonical message type used throughout the system.

```go
type Message struct {
    Role    string `json:"role"`    // "system", "user", "assistant", "tool"
    Content string `json:"content"` // Message content (legacy text-only, maintained for backward compatibility)

    // Multimodal content parts (text, images, audio, video)
    // If Parts is non-empty, it takes precedence over Content.
    // For backward compatibility, if Parts is empty, Content will be used.
    Parts []ContentPart `json:"parts,omitempty"`

    // Tool invocations (for assistant messages that call tools)
    ToolCalls []MessageToolCall `json:"tool_calls,omitempty"`

    // Tool result (for tool role messages)
    // When Role="tool", this contains the tool execution result
    ToolResult *MessageToolResult `json:"tool_result,omitempty"`

    // Source indicates where this message originated (runtime-only, not persisted in JSON)
    // Values: "statestore" (loaded from StateStore), "pipeline" (created during execution), "" (user input)
    Source string `json:"-"`

    // Metadata for observability and tracking
    Timestamp time.Time              `json:"timestamp,omitempty"`  // When the message was created
    LatencyMs int64                  `json:"latency_ms,omitempty"` // Time taken to generate (for assistant messages)
    CostInfo  *CostInfo              `json:"cost_info,omitempty"`  // Token usage and cost tracking
    Meta      map[string]interface{} `json:"meta,omitempty"`       // Custom metadata

    // Validation results (for assistant messages)
    Validations []ValidationResult `json:"validations,omitempty"`
}
```

<a name="CloneMessage"></a>
### func CloneMessage

```go
func CloneMessage(msg Message) Message
```

CloneMessage creates a deep copy of a message

<a name="CombineTextAndMedia"></a>
### func CombineTextAndMedia

```go
func CombineTextAndMedia(role, text string, mediaParts []ContentPart) Message
```

CombineTextAndMedia creates a multimodal message from separate text and media parts. This is the inverse of SplitMultimodalMessage.

<a name="ConvertTextToMultimodal"></a>
### func ConvertTextToMultimodal

```go
func ConvertTextToMultimodal(role, content string) Message
```

ConvertTextToMultimodal is a convenience function that creates a multimodal message from a role and text content. This helps with code migration.

<a name="Message.AddAudioPart"></a>
### func \(\*Message\) AddAudioPart

```go
func (m *Message) AddAudioPart(filePath string) error
```

AddAudioPart adds an audio content part from a file path

<a name="Message.AddImagePart"></a>
### func \(\*Message\) AddImagePart

```go
func (m *Message) AddImagePart(filePath string, detail *string) error
```

AddImagePart adds an image content part from a file path

<a name="Message.AddImagePartFromURL"></a>
### func \(\*Message\) AddImagePartFromURL

```go
func (m *Message) AddImagePartFromURL(url string, detail *string)
```

AddImagePartFromURL adds an image content part from a URL

<a name="Message.AddPart"></a>
### func \(\*Message\) AddPart

```go
func (m *Message) AddPart(part ContentPart)
```

AddPart adds a content part to the message. If this is the first part added, it clears the legacy Content field.

<a name="Message.AddTextPart"></a>
### func \(\*Message\) AddTextPart

```go
func (m *Message) AddTextPart(text string)
```

AddTextPart adds a text content part to the message

<a name="Message.AddVideoPart"></a>
### func \(\*Message\) AddVideoPart

```go
func (m *Message) AddVideoPart(filePath string) error
```

AddVideoPart adds a video content part from a file path

<a name="Message.GetContent"></a>
### func \(\*Message\) GetContent

```go
func (m *Message) GetContent() string
```

GetContent returns the content of the message. If Parts is non\-empty, it returns only the text parts concatenated. Otherwise, it returns the legacy Content field.

<a name="Message.HasMediaContent"></a>
### func \(\*Message\) HasMediaContent

```go
func (m *Message) HasMediaContent() bool
```

HasMediaContent returns true if the message contains any media \(image, audio, video\)

<a name="Message.IsMultimodal"></a>
### func \(\*Message\) IsMultimodal

```go
func (m *Message) IsMultimodal() bool
```

IsMultimodal returns true if the message contains multimodal content \(Parts\)

<a name="Message.MarshalJSON"></a>
### func \(Message\) MarshalJSON

```go
func (m Message) MarshalJSON() ([]byte, error)
```

MarshalJSON implements custom JSON marshaling for Message. This enhances the output by: 1. Populating the Content field with a human\-readable summary when Parts exist 2. Adding a MediaSummary field for observability of multimodal content 3. Omitting Content field when ToolResult is present to avoid duplication

<a name="Message.SetMultimodalContent"></a>
### func \(\*Message\) SetMultimodalContent

```go
func (m *Message) SetMultimodalContent(parts []ContentPart)
```

SetMultimodalContent sets the message content to multimodal parts. This clears the legacy Content field.

<a name="Message.SetTextContent"></a>
### func \(\*Message\) SetTextContent

```go
func (m *Message) SetTextContent(text string)
```

SetTextContent sets the message content to simple text. This clears any existing Parts and sets the legacy Content field.

<a name="Message.UnmarshalJSON"></a>
### func \(\*Message\) UnmarshalJSON

```go
func (m *Message) UnmarshalJSON(data []byte) error
```

UnmarshalJSON implements custom JSON unmarshaling for Message. After unmarshaling, if ToolResult is present, copy its Content to Message.Content for provider compatibility \(providers expect Content field to be populated\).

<a name="MessageToolCall"></a>
## type MessageToolCall

MessageToolCall represents a request to call a tool within a Message. The Args field contains the JSON\-encoded arguments for the tool.

```go
type MessageToolCall struct {
    ID   string          `json:"id"`   // Unique identifier for this tool call
    Name string          `json:"name"` // Name of the tool to invoke
    Args json.RawMessage `json:"args"` // JSON-encoded tool arguments
}
```

<a name="MessageToolResult"></a>
## type MessageToolResult

MessageToolResult represents the result of a tool execution in a Message. When embedded in Message, the Message.Role should be "tool".

```go
type MessageToolResult struct {
    ID        string `json:"id"`              // References the MessageToolCall.ID that triggered this result
    Name      string `json:"name"`            // Tool name that was executed
    Content   string `json:"content"`         // Result content or error message
    Error     string `json:"error,omitempty"` // Error message if tool execution failed
    LatencyMs int64  `json:"latency_ms"`      // Tool execution latency in milliseconds
}
```

<a name="StreamingMediaConfig"></a>
## type StreamingMediaConfig

StreamingMediaConfig configures streaming media input parameters. Used to configure audio/video streaming sessions with providers.

Example usage for audio streaming:

```
config := &StreamingMediaConfig{
    Type:       ContentTypeAudio,
    ChunkSize:  8192,    // 8KB chunks
    SampleRate: 16000,   // 16kHz audio
    Encoding:   "pcm",   // Raw PCM audio
    Channels:   1,       // Mono
    BufferSize: 10,      // Buffer 10 chunks
}
```

```go
type StreamingMediaConfig struct {
    // Type specifies the media type being streamed
    // Values: ContentTypeAudio, ContentTypeVideo
    Type string `json:"type"`

    // ChunkSize is the target size in bytes for each chunk
    // Typical values: 4096-8192 for audio, 32768-65536 for video
    ChunkSize int `json:"chunk_size"`

    // SampleRate is the audio sample rate in Hz
    // Common values: 8000 (phone quality), 16000 (wideband), 44100 (CD quality), 48000 (pro audio)
    SampleRate int `json:"sample_rate,omitempty"`

    // Encoding specifies the audio encoding format
    // Values: "pcm" (raw), "opus", "mp3", "aac"
    Encoding string `json:"encoding,omitempty"`

    // Channels is the number of audio channels
    // Values: 1 (mono), 2 (stereo)
    Channels int `json:"channels,omitempty"`

    // BitDepth is the audio bit depth in bits
    // Common values: 16, 24, 32
    BitDepth int `json:"bit_depth,omitempty"`

    // Width is the video width in pixels
    Width int `json:"width,omitempty"`

    // Height is the video height in pixels
    Height int `json:"height,omitempty"`

    // FrameRate is the video frame rate (FPS)
    // Common values: 24, 30, 60
    FrameRate int `json:"frame_rate,omitempty"`

    // BufferSize is the maximum number of chunks to buffer
    // Larger values increase latency but provide more stability
    // Typical values: 5-20
    BufferSize int `json:"buffer_size,omitempty"`

    // FlushInterval is how often to flush buffered data (if applicable)
    FlushInterval time.Duration `json:"flush_interval,omitempty"`

    // Metadata contains additional provider-specific configuration
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

<a name="StreamingMediaConfig.Validate"></a>
### func \(\*StreamingMediaConfig\) Validate

```go
func (c *StreamingMediaConfig) Validate() error
```

Validate checks if the StreamingMediaConfig is valid

<a name="ToolDef"></a>
## type ToolDef

ToolDef represents a tool definition that can be provided to an LLM. The InputSchema and OutputSchema use JSON Schema format for validation.

```go
type ToolDef struct {
    Name         string          `json:"name"`                    // Unique tool name
    Description  string          `json:"description"`             // Human-readable description of what the tool does
    InputSchema  json.RawMessage `json:"input_schema"`            // JSON Schema for input validation
    OutputSchema json.RawMessage `json:"output_schema,omitempty"` // Optional JSON Schema for output validation
}
```

<a name="ToolStats"></a>
## type ToolStats

ToolStats tracks tool usage statistics across a conversation or run. Useful for monitoring which tools are being used and how frequently.

```go
type ToolStats struct {
    TotalCalls int            `json:"total_calls"` // Total number of tool calls
    ByTool     map[string]int `json:"by_tool"`     // Count of calls per tool name
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a validation failure in tool usage or message content. Used to provide structured error information when validation fails.

```go
type ValidationError struct {
    Type   string `json:"type"`   // Error type: "args_invalid" | "result_invalid" | "policy_violation"
    Tool   string `json:"tool"`   // Name of the tool that failed validation
    Detail string `json:"detail"` // Human-readable error details
}
```

<a name="ValidationResult"></a>
## type ValidationResult

ValidationResult represents the outcome of a validator check on a message. These are attached to assistant messages to show which validations passed or failed.

```go
type ValidationResult struct {
    ValidatorType string                 `json:"validator_type"`      // Type of validator
    Passed        bool                   `json:"passed"`              // Whether the validation passed
    Details       map[string]interface{} `json:"details,omitempty"`   // Validator-specific details
    Timestamp     time.Time              `json:"timestamp,omitempty"` // When validation was performed
}
```

# validators

```go
import "github.com/AltairaLabs/PromptKit/runtime/validators"
```

Package validators provides content validation for LLM responses and user inputs.

This package implements various validators to ensure conversation quality:

- Length and sentence count limits
- Banned word detection
- Role integrity \(preventing role confusion\)
- Required field presence
- Question and commit block validation

Validators are used during test execution to catch policy violations and ensure LLM responses meet quality standards.

## Index

- [Variables](<#variables>)
- [type BannedWordsValidator](<#BannedWordsValidator>)
  - [func NewBannedWordsValidator\(bannedWords \[\]string\) \*BannedWordsValidator](<#NewBannedWordsValidator>)
  - [func \(v \*BannedWordsValidator\) SupportsStreaming\(\) bool](<#BannedWordsValidator.SupportsStreaming>)
  - [func \(v \*BannedWordsValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#BannedWordsValidator.Validate>)
  - [func \(v \*BannedWordsValidator\) ValidateChunk\(chunk providers.StreamChunk, params ...map\[string\]interface\{\}\) error](<#BannedWordsValidator.ValidateChunk>)
- [type CommitValidator](<#CommitValidator>)
  - [func NewCommitValidator\(\) \*CommitValidator](<#NewCommitValidator>)
  - [func \(v \*CommitValidator\) SupportsStreaming\(\) bool](<#CommitValidator.SupportsStreaming>)
  - [func \(v \*CommitValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#CommitValidator.Validate>)
- [type LengthValidator](<#LengthValidator>)
  - [func NewLengthValidator\(\) \*LengthValidator](<#NewLengthValidator>)
  - [func \(v \*LengthValidator\) SupportsStreaming\(\) bool](<#LengthValidator.SupportsStreaming>)
  - [func \(v \*LengthValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#LengthValidator.Validate>)
  - [func \(v \*LengthValidator\) ValidateChunk\(chunk providers.StreamChunk, params ...map\[string\]interface\{\}\) error](<#LengthValidator.ValidateChunk>)
- [type MaxSentencesValidator](<#MaxSentencesValidator>)
  - [func NewMaxSentencesValidator\(\) \*MaxSentencesValidator](<#NewMaxSentencesValidator>)
  - [func \(v \*MaxSentencesValidator\) SupportsStreaming\(\) bool](<#MaxSentencesValidator.SupportsStreaming>)
  - [func \(v \*MaxSentencesValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#MaxSentencesValidator.Validate>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func \(r \*Registry\) Get\(validatorType string\) \(ValidatorFactory, bool\)](<#Registry.Get>)
  - [func \(r \*Registry\) HasValidator\(validatorType string\) bool](<#Registry.HasValidator>)
  - [func \(r \*Registry\) Register\(validatorType string, factory ValidatorFactory\)](<#Registry.Register>)
- [type RequiredFieldsValidator](<#RequiredFieldsValidator>)
  - [func NewRequiredFieldsValidator\(\) \*RequiredFieldsValidator](<#NewRequiredFieldsValidator>)
  - [func \(v \*RequiredFieldsValidator\) SupportsStreaming\(\) bool](<#RequiredFieldsValidator.SupportsStreaming>)
  - [func \(v \*RequiredFieldsValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#RequiredFieldsValidator.Validate>)
- [type StreamingValidator](<#StreamingValidator>)
- [type ValidationResult](<#ValidationResult>)
- [type Validator](<#Validator>)
- [type ValidatorConfig](<#ValidatorConfig>)
- [type ValidatorFactory](<#ValidatorFactory>)


## Variables

<a name="DefaultRegistry"></a>DefaultRegistry is the global validator registry.

```go
var DefaultRegistry = NewRegistry()
```

<a name="BannedWordsValidator"></a>
## type BannedWordsValidator

BannedWordsValidator checks for banned words

```go
type BannedWordsValidator struct {
    // contains filtered or unexported fields
}
```

<a name="NewBannedWordsValidator"></a>
### func NewBannedWordsValidator

```go
func NewBannedWordsValidator(bannedWords []string) *BannedWordsValidator
```

NewBannedWordsValidator creates a new banned words validator

<a name="BannedWordsValidator.SupportsStreaming"></a>
### func \(\*BannedWordsValidator\) SupportsStreaming

```go
func (v *BannedWordsValidator) SupportsStreaming() bool
```

SupportsStreaming returns true as banned words can be detected incrementally

<a name="BannedWordsValidator.Validate"></a>
### func \(\*BannedWordsValidator\) Validate

```go
func (v *BannedWordsValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for banned words in content

<a name="BannedWordsValidator.ValidateChunk"></a>
### func \(\*BannedWordsValidator\) ValidateChunk

```go
func (v *BannedWordsValidator) ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error
```

ValidateChunk validates a stream chunk for banned words and aborts if found

<a name="CommitValidator"></a>
## type CommitValidator

CommitValidator checks for commit/decision blocks in conversation responses

```go
type CommitValidator struct{}
```

<a name="NewCommitValidator"></a>
### func NewCommitValidator

```go
func NewCommitValidator() *CommitValidator
```

NewCommitValidator creates a new commit validator

<a name="CommitValidator.SupportsStreaming"></a>
### func \(\*CommitValidator\) SupportsStreaming

```go
func (v *CommitValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as commit validation requires complete content

<a name="CommitValidator.Validate"></a>
### func \(\*CommitValidator\) Validate

```go
func (v *CommitValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for commit block with required fields

<a name="LengthValidator"></a>
## type LengthValidator

LengthValidator checks content length limits

```go
type LengthValidator struct{}
```

<a name="NewLengthValidator"></a>
### func NewLengthValidator

```go
func NewLengthValidator() *LengthValidator
```

NewLengthValidator creates a new length validator

<a name="LengthValidator.SupportsStreaming"></a>
### func \(\*LengthValidator\) SupportsStreaming

```go
func (v *LengthValidator) SupportsStreaming() bool
```

SupportsStreaming returns true as length can be checked incrementally

<a name="LengthValidator.Validate"></a>
### func \(\*LengthValidator\) Validate

```go
func (v *LengthValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks content length against limits

<a name="LengthValidator.ValidateChunk"></a>
### func \(\*LengthValidator\) ValidateChunk

```go
func (v *LengthValidator) ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error
```

ValidateChunk validates stream chunk against length limits and aborts if exceeded

<a name="MaxSentencesValidator"></a>
## type MaxSentencesValidator

MaxSentencesValidator checks sentence count limits

```go
type MaxSentencesValidator struct{}
```

<a name="NewMaxSentencesValidator"></a>
### func NewMaxSentencesValidator

```go
func NewMaxSentencesValidator() *MaxSentencesValidator
```

NewMaxSentencesValidator creates a new sentence count validator

<a name="MaxSentencesValidator.SupportsStreaming"></a>
### func \(\*MaxSentencesValidator\) SupportsStreaming

```go
func (v *MaxSentencesValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as sentence counting requires complete content

<a name="MaxSentencesValidator.Validate"></a>
### func \(\*MaxSentencesValidator\) Validate

```go
func (v *MaxSentencesValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks sentence count against max limit

<a name="Registry"></a>
## type Registry

Registry maps validator type names to factory functions. This allows dynamic instantiation of validators from configuration.

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new validator registry with built\-in validators.

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(validatorType string) (ValidatorFactory, bool)
```

Get retrieves a validator factory by type.

<a name="Registry.HasValidator"></a>
### func \(\*Registry\) HasValidator

```go
func (r *Registry) HasValidator(validatorType string) bool
```

HasValidator returns true if a validator type is registered.

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(validatorType string, factory ValidatorFactory)
```

Register adds a validator factory to the registry.

<a name="RequiredFieldsValidator"></a>
## type RequiredFieldsValidator

RequiredFieldsValidator checks for required fields in content

```go
type RequiredFieldsValidator struct{}
```

<a name="NewRequiredFieldsValidator"></a>
### func NewRequiredFieldsValidator

```go
func NewRequiredFieldsValidator() *RequiredFieldsValidator
```

NewRequiredFieldsValidator creates a new required fields validator

<a name="RequiredFieldsValidator.SupportsStreaming"></a>
### func \(\*RequiredFieldsValidator\) SupportsStreaming

```go
func (v *RequiredFieldsValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as required fields must be in complete content

<a name="RequiredFieldsValidator.Validate"></a>
### func \(\*RequiredFieldsValidator\) Validate

```go
func (v *RequiredFieldsValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for required fields in content

<a name="StreamingValidator"></a>
## type StreamingValidator

StreamingValidator interface for validators that can check content incrementally and abort streaming early if validation fails

```go
type StreamingValidator interface {
    Validator

    // ValidateChunk validates a stream chunk and returns error to abort stream
    // Returns nil to continue, ValidationAbortError to abort stream
    ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error

    // SupportsStreaming returns true if this validator can validate incrementally
    SupportsStreaming() bool
}
```

<a name="ValidationResult"></a>
## type ValidationResult

ValidationResult holds the result of a validation check

```go
type ValidationResult struct {
    Passed  bool        `json:"passed"`
    Details interface{} `json:"details,omitempty"`
}
```

<a name="Validator"></a>
## type Validator

Validator interface for all validation checks

```go
type Validator interface {
    Validate(content string, params map[string]interface{}) ValidationResult
}
```

<a name="ValidatorConfig"></a>
## type ValidatorConfig

ValidatorConfig defines a validator configuration from a prompt pack. This is just configuration data \- validators are instantiated by the registry.

```go
type ValidatorConfig struct {
    Type   string                 `json:"type" yaml:"type"`
    Params map[string]interface{} `json:"params" yaml:"params"`
}
```

<a name="ValidatorFactory"></a>
## type ValidatorFactory

ValidatorFactory creates a validator instance from configuration params. Params from the config are passed at construction time to allow validators to pre\-compile patterns, build state, etc.

```go
type ValidatorFactory func(params map[string]interface{}) Validator
```

# variables

```go
import "github.com/AltairaLabs/PromptKit/runtime/variables"
```

Package variables provides dynamic variable resolution for prompt templates. Variable providers can inject context from external sources \(databases, APIs, conversation state\) before template rendering.

## Index

- [type ChainProvider](<#ChainProvider>)
  - [func Chain\(providers ...Provider\) \*ChainProvider](<#Chain>)
  - [func \(c \*ChainProvider\) Add\(p Provider\) \*ChainProvider](<#ChainProvider.Add>)
  - [func \(c \*ChainProvider\) Name\(\) string](<#ChainProvider.Name>)
  - [func \(c \*ChainProvider\) Provide\(ctx context.Context\) \(map\[string\]string, error\)](<#ChainProvider.Provide>)
  - [func \(c \*ChainProvider\) Providers\(\) \[\]Provider](<#ChainProvider.Providers>)
- [type Provider](<#Provider>)
- [type StateProvider](<#StateProvider>)
  - [func NewStatePrefixProvider\(store statestore.Store, conversationID, prefix string, stripPrefix bool\) \*StateProvider](<#NewStatePrefixProvider>)
  - [func NewStateProvider\(store statestore.Store, conversationID string\) \*StateProvider](<#NewStateProvider>)
  - [func \(p \*StateProvider\) Name\(\) string](<#StateProvider.Name>)
  - [func \(p \*StateProvider\) Provide\(ctx context.Context\) \(map\[string\]string, error\)](<#StateProvider.Provide>)
- [type TimeProvider](<#TimeProvider>)
  - [func NewTimeProvider\(\) \*TimeProvider](<#NewTimeProvider>)
  - [func NewTimeProviderWithFormat\(format string\) \*TimeProvider](<#NewTimeProviderWithFormat>)
  - [func NewTimeProviderWithLocation\(loc \*time.Location\) \*TimeProvider](<#NewTimeProviderWithLocation>)
  - [func \(p \*TimeProvider\) Name\(\) string](<#TimeProvider.Name>)
  - [func \(p \*TimeProvider\) Provide\(ctx context.Context\) \(map\[string\]string, error\)](<#TimeProvider.Provide>)
  - [func \(p \*TimeProvider\) WithNowFunc\(fn func\(\) time.Time\) \*TimeProvider](<#TimeProvider.WithNowFunc>)


<a name="ChainProvider"></a>
## type ChainProvider

ChainProvider composes multiple providers into a single provider. Providers are called in order, with later providers overriding variables from earlier providers when keys conflict.

```go
type ChainProvider struct {
    // contains filtered or unexported fields
}
```

<a name="Chain"></a>
### func Chain

```go
func Chain(providers ...Provider) *ChainProvider
```

Chain creates a ChainProvider from multiple providers. Providers are called in the order given. Later providers override variables from earlier providers.

<a name="ChainProvider.Add"></a>
### func \(\*ChainProvider\) Add

```go
func (c *ChainProvider) Add(p Provider) *ChainProvider
```

Add appends a provider to the chain.

<a name="ChainProvider.Name"></a>
### func \(\*ChainProvider\) Name

```go
func (c *ChainProvider) Name() string
```

Name returns the provider identifier.

<a name="ChainProvider.Provide"></a>
### func \(\*ChainProvider\) Provide

```go
func (c *ChainProvider) Provide(ctx context.Context) (map[string]string, error)
```

Provide calls all chained providers and merges their results. Returns an error if any provider fails.

<a name="ChainProvider.Providers"></a>
### func \(\*ChainProvider\) Providers

```go
func (c *ChainProvider) Providers() []Provider
```

Providers returns the list of providers in the chain.

<a name="Provider"></a>
## type Provider

Provider resolves variables dynamically at runtime. Variables returned override static variables with the same key. Providers are called before template rendering to inject dynamic context.

Providers that need access to conversation state \(like StateProvider\) should receive it via constructor injection rather than through Provide\(\).

```go
type Provider interface {
    // Name returns the provider identifier (for logging/debugging)
    Name() string

    // Provide returns variables to inject into template context.
    // Called before each template render.
    Provide(ctx context.Context) (map[string]string, error)
}
```

<a name="StateProvider"></a>
## type StateProvider

StateProvider resolves variables from conversation state metadata. It extracts key\-value pairs from the state's Metadata field and converts them to string variables for template substitution.

The StateStore is injected via constructor, allowing the provider to look up state for the current conversation.

```go
type StateProvider struct {

    // KeyPrefix filters metadata keys. Only keys with this prefix are included.
    // If empty, all metadata keys are included.
    KeyPrefix string

    // StripPrefix removes the KeyPrefix from variable names when true.
    // For example, if KeyPrefix="user_" and StripPrefix=true,
    // metadata key "user_name" becomes variable "name".
    StripPrefix bool
    // contains filtered or unexported fields
}
```

<a name="NewStatePrefixProvider"></a>
### func NewStatePrefixProvider

```go
func NewStatePrefixProvider(store statestore.Store, conversationID, prefix string, stripPrefix bool) *StateProvider
```

NewStatePrefixProvider creates a StateProvider that only extracts metadata keys with the given prefix. If stripPrefix is true, the prefix is removed from the resulting variable names.

<a name="NewStateProvider"></a>
### func NewStateProvider

```go
func NewStateProvider(store statestore.Store, conversationID string) *StateProvider
```

NewStateProvider creates a StateProvider that extracts all metadata as variables from the given conversation's state.

<a name="StateProvider.Name"></a>
### func \(\*StateProvider\) Name

```go
func (p *StateProvider) Name() string
```

Name returns the provider identifier.

<a name="StateProvider.Provide"></a>
### func \(\*StateProvider\) Provide

```go
func (p *StateProvider) Provide(ctx context.Context) (map[string]string, error)
```

Provide extracts variables from conversation state metadata. Returns nil if store is nil, conversation not found, or has no metadata.

<a name="TimeProvider"></a>
## type TimeProvider

TimeProvider provides current time and date variables. Useful for prompts that need temporal context like "What day is it?" or time\-sensitive instructions.

```go
type TimeProvider struct {
    // Format is the time format string for current_time variable.
    // Defaults to time.RFC3339 if empty.
    Format string

    // Location specifies the timezone. Defaults to UTC if nil.
    Location *time.Location
    // contains filtered or unexported fields
}
```

<a name="NewTimeProvider"></a>
### func NewTimeProvider

```go
func NewTimeProvider() *TimeProvider
```

NewTimeProvider creates a TimeProvider with default settings \(UTC, RFC3339 format\).

<a name="NewTimeProviderWithFormat"></a>
### func NewTimeProviderWithFormat

```go
func NewTimeProviderWithFormat(format string) *TimeProvider
```

NewTimeProviderWithFormat creates a TimeProvider with a custom time format.

<a name="NewTimeProviderWithLocation"></a>
### func NewTimeProviderWithLocation

```go
func NewTimeProviderWithLocation(loc *time.Location) *TimeProvider
```

NewTimeProviderWithLocation creates a TimeProvider for a specific timezone.

<a name="TimeProvider.Name"></a>
### func \(\*TimeProvider\) Name

```go
func (p *TimeProvider) Name() string
```

Name returns the provider identifier.

<a name="TimeProvider.Provide"></a>
### func \(\*TimeProvider\) Provide

```go
func (p *TimeProvider) Provide(ctx context.Context) (map[string]string, error)
```

Provide returns time\-related variables. Variables provided:

- current\_time: Full timestamp in configured format
- current\_date: Date in YYYY\-MM\-DD format
- current\_year: Four\-digit year
- current\_month: Full month name \(e.g., "January"\)
- current\_weekday: Full weekday name \(e.g., "Monday"\)
- current\_hour: Hour in 24\-hour format \(00\-23\)

<a name="TimeProvider.WithNowFunc"></a>
### func \(\*TimeProvider\) WithNowFunc

```go
func (p *TimeProvider) WithNowFunc(fn func() time.Time) *TimeProvider
```

WithNowFunc sets a custom time source \(primarily for testing\).

# common

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/common"
```

Package common provides shared functionality for persistence repositories.

## Index

- [func ValidatePromptConfig\(config \*prompt.Config\) error](<#ValidatePromptConfig>)
- [type BasePromptRepository](<#BasePromptRepository>)
  - [func NewBasePromptRepository\(basePath string, taskTypeToFile map\[string\]string, extensions \[\]string, unmarshal UnmarshalFunc\) \*BasePromptRepository](<#NewBasePromptRepository>)
  - [func \(r \*BasePromptRepository\) HasMatchingTaskType\(path, taskType string\) bool](<#BasePromptRepository.HasMatchingTaskType>)
  - [func \(r \*BasePromptRepository\) HasValidExtension\(path string\) bool](<#BasePromptRepository.HasValidExtension>)
  - [func \(r \*BasePromptRepository\) ListPrompts\(\) \(\[\]string, error\)](<#BasePromptRepository.ListPrompts>)
  - [func \(r \*BasePromptRepository\) LoadPrompt\(taskType string\) \(\*prompt.Config, error\)](<#BasePromptRepository.LoadPrompt>)
  - [func \(r \*BasePromptRepository\) ResolveFilePath\(taskType string\) \(string, error\)](<#BasePromptRepository.ResolveFilePath>)
  - [func \(r \*BasePromptRepository\) SearchByContent\(taskType string\) string](<#BasePromptRepository.SearchByContent>)
  - [func \(r \*BasePromptRepository\) SearchByFilename\(taskType string\) string](<#BasePromptRepository.SearchByFilename>)
  - [func \(r \*BasePromptRepository\) SearchForPrompt\(taskType string\) \(string, error\)](<#BasePromptRepository.SearchForPrompt>)
- [type UnmarshalFunc](<#UnmarshalFunc>)


<a name="ValidatePromptConfig"></a>
## func ValidatePromptConfig

```go
func ValidatePromptConfig(config *prompt.Config) error
```

ValidatePromptConfig validates the prompt configuration structure

<a name="BasePromptRepository"></a>
## type BasePromptRepository

BasePromptRepository provides common prompt repository functionality

```go
type BasePromptRepository struct {
    BasePath       string
    TaskTypeToFile map[string]string
    Cache          map[string]*prompt.Config
    Extensions     []string
    Unmarshal      UnmarshalFunc
}
```

<a name="NewBasePromptRepository"></a>
### func NewBasePromptRepository

```go
func NewBasePromptRepository(basePath string, taskTypeToFile map[string]string, extensions []string, unmarshal UnmarshalFunc) *BasePromptRepository
```

NewBasePromptRepository creates a new base repository

<a name="BasePromptRepository.HasMatchingTaskType"></a>
### func \(\*BasePromptRepository\) HasMatchingTaskType

```go
func (r *BasePromptRepository) HasMatchingTaskType(path, taskType string) bool
```

HasMatchingTaskType checks if a file contains the specified task type

<a name="BasePromptRepository.HasValidExtension"></a>
### func \(\*BasePromptRepository\) HasValidExtension

```go
func (r *BasePromptRepository) HasValidExtension(path string) bool
```

HasValidExtension checks if a file has a valid extension

<a name="BasePromptRepository.ListPrompts"></a>
### func \(\*BasePromptRepository\) ListPrompts

```go
func (r *BasePromptRepository) ListPrompts() ([]string, error)
```

ListPrompts returns all available prompt task types

<a name="BasePromptRepository.LoadPrompt"></a>
### func \(\*BasePromptRepository\) LoadPrompt

```go
func (r *BasePromptRepository) LoadPrompt(taskType string) (*prompt.Config, error)
```

LoadPrompt loads a prompt configuration by task type

<a name="BasePromptRepository.ResolveFilePath"></a>
### func \(\*BasePromptRepository\) ResolveFilePath

```go
func (r *BasePromptRepository) ResolveFilePath(taskType string) (string, error)
```

ResolveFilePath finds the file path for a given task type

<a name="BasePromptRepository.SearchByContent"></a>
### func \(\*BasePromptRepository\) SearchByContent

```go
func (r *BasePromptRepository) SearchByContent(taskType string) string
```

SearchByContent searches for files by parsing and checking task type

<a name="BasePromptRepository.SearchByFilename"></a>
### func \(\*BasePromptRepository\) SearchByFilename

```go
func (r *BasePromptRepository) SearchByFilename(taskType string) string
```

SearchByFilename searches for files by filename patterns

<a name="BasePromptRepository.SearchForPrompt"></a>
### func \(\*BasePromptRepository\) SearchForPrompt

```go
func (r *BasePromptRepository) SearchForPrompt(taskType string) (string, error)
```

SearchForPrompt searches for a file matching the task type

<a name="UnmarshalFunc"></a>
## type UnmarshalFunc

UnmarshalFunc is a function that unmarshals data into a prompt config

```go
type UnmarshalFunc func([]byte, interface{}) error
```

# json

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/json"
```

Package json provides JSON file\-based implementations of persistence repositories.

This package can be used for production environments where JSON is preferred over YAML.

## Index

- [type PromptRepository](<#PromptRepository>)
  - [func NewJSONPromptRepository\(basePath string, taskTypeToFile map\[string\]string\) \*PromptRepository](<#NewJSONPromptRepository>)
  - [func \(r \*PromptRepository\) LoadFragment\(name, relativePath, baseDir string\) \(\*prompt.Fragment, error\)](<#PromptRepository.LoadFragment>)
  - [func \(r \*PromptRepository\) SavePrompt\(config \*prompt.Config\) error](<#PromptRepository.SavePrompt>)
- [type ToolRepository](<#ToolRepository>)
  - [func NewJSONToolRepository\(basePath string\) \*ToolRepository](<#NewJSONToolRepository>)
  - [func \(r \*ToolRepository\) ListTools\(\) \(\[\]string, error\)](<#ToolRepository.ListTools>)
  - [func \(r \*ToolRepository\) LoadDirectory\(dirPath string\) error](<#ToolRepository.LoadDirectory>)
  - [func \(r \*ToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#ToolRepository.LoadTool>)
  - [func \(r \*ToolRepository\) LoadToolFromFile\(filename string\) error](<#ToolRepository.LoadToolFromFile>)
  - [func \(r \*ToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#ToolRepository.RegisterTool>)
  - [func \(r \*ToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#ToolRepository.SaveTool>)


<a name="PromptRepository"></a>
## type PromptRepository

JSONPromptRepository loads prompts from JSON files on disk

```go
type PromptRepository struct {
    *common.BasePromptRepository
}
```

<a name="NewJSONPromptRepository"></a>
### func NewJSONPromptRepository

```go
func NewJSONPromptRepository(basePath string, taskTypeToFile map[string]string) *PromptRepository
```

NewJSONPromptRepository creates a JSON file\-based prompt repository

<a name="PromptRepository.LoadFragment"></a>
### func \(\*PromptRepository\) LoadFragment

```go
func (r *PromptRepository) LoadFragment(name, relativePath, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name

<a name="PromptRepository.SavePrompt"></a>
### func \(\*PromptRepository\) SavePrompt

```go
func (r *PromptRepository) SavePrompt(config *prompt.Config) error
```

SavePrompt saves a prompt configuration \(not yet implemented\)

<a name="ToolRepository"></a>
## type ToolRepository

JSONToolRepository loads tools from JSON files on disk

```go
type ToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewJSONToolRepository"></a>
### func NewJSONToolRepository

```go
func NewJSONToolRepository(basePath string) *ToolRepository
```

NewJSONToolRepository creates a JSON file\-based tool repository

<a name="ToolRepository.ListTools"></a>
### func \(\*ToolRepository\) ListTools

```go
func (r *ToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="ToolRepository.LoadDirectory"></a>
### func \(\*ToolRepository\) LoadDirectory

```go
func (r *ToolRepository) LoadDirectory(dirPath string) error
```

LoadDirectory recursively loads all JSON tool files from a directory

<a name="ToolRepository.LoadTool"></a>
### func \(\*ToolRepository\) LoadTool

```go
func (r *ToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="ToolRepository.LoadToolFromFile"></a>
### func \(\*ToolRepository\) LoadToolFromFile

```go
func (r *ToolRepository) LoadToolFromFile(filename string) error
```

LoadToolFromFile loads a tool from a JSON file

<a name="ToolRepository.RegisterTool"></a>
### func \(\*ToolRepository\) RegisterTool

```go
func (r *ToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool descriptor directly

<a name="ToolRepository.SaveTool"></a>
### func \(\*ToolRepository\) SaveTool

```go
func (r *ToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor \(not yet implemented\)

# memory

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/memory"
```

Package memory provides in\-memory implementations of persistence repositories.

This package is primarily for testing and SDK use, allowing prompts and tools to be registered programmatically without file system dependencies.

## Index

- [type PromptRepository](<#PromptRepository>)
  - [func NewPromptRepository\(\) \*PromptRepository](<#NewPromptRepository>)
  - [func \(r \*PromptRepository\) ListPrompts\(\) \(\[\]string, error\)](<#PromptRepository.ListPrompts>)
  - [func \(r \*PromptRepository\) LoadFragment\(name, relativePath, baseDir string\) \(\*prompt.Fragment, error\)](<#PromptRepository.LoadFragment>)
  - [func \(r \*PromptRepository\) LoadPrompt\(taskType string\) \(\*prompt.Config, error\)](<#PromptRepository.LoadPrompt>)
  - [func \(r \*PromptRepository\) RegisterFragment\(name string, fragment \*prompt.Fragment\)](<#PromptRepository.RegisterFragment>)
  - [func \(r \*PromptRepository\) RegisterPrompt\(taskType string, config \*prompt.Config\)](<#PromptRepository.RegisterPrompt>)
  - [func \(r \*PromptRepository\) SavePrompt\(config \*prompt.Config\) error](<#PromptRepository.SavePrompt>)
- [type ToolRepository](<#ToolRepository>)
  - [func NewToolRepository\(\) \*ToolRepository](<#NewToolRepository>)
  - [func \(r \*ToolRepository\) ListTools\(\) \(\[\]string, error\)](<#ToolRepository.ListTools>)
  - [func \(r \*ToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#ToolRepository.LoadTool>)
  - [func \(r \*ToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#ToolRepository.RegisterTool>)
  - [func \(r \*ToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#ToolRepository.SaveTool>)


<a name="PromptRepository"></a>
## type PromptRepository

PromptRepository stores prompts in memory \(for testing/SDK\)

```go
type PromptRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewPromptRepository"></a>
### func NewPromptRepository

```go
func NewPromptRepository() *PromptRepository
```

NewPromptRepository creates a new in\-memory prompt repository

<a name="PromptRepository.ListPrompts"></a>
### func \(\*PromptRepository\) ListPrompts

```go
func (r *PromptRepository) ListPrompts() ([]string, error)
```

ListPrompts returns all available prompt task types

<a name="PromptRepository.LoadFragment"></a>
### func \(\*PromptRepository\) LoadFragment

```go
func (r *PromptRepository) LoadFragment(name, relativePath, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name

<a name="PromptRepository.LoadPrompt"></a>
### func \(\*PromptRepository\) LoadPrompt

```go
func (r *PromptRepository) LoadPrompt(taskType string) (*prompt.Config, error)
```

LoadPrompt loads a prompt configuration by task type

<a name="PromptRepository.RegisterFragment"></a>
### func \(\*PromptRepository\) RegisterFragment

```go
func (r *PromptRepository) RegisterFragment(name string, fragment *prompt.Fragment)
```

RegisterFragment adds a fragment to the in\-memory store

<a name="PromptRepository.RegisterPrompt"></a>
### func \(\*PromptRepository\) RegisterPrompt

```go
func (r *PromptRepository) RegisterPrompt(taskType string, config *prompt.Config)
```

RegisterPrompt adds a prompt to the in\-memory store

<a name="PromptRepository.SavePrompt"></a>
### func \(\*PromptRepository\) SavePrompt

```go
func (r *PromptRepository) SavePrompt(config *prompt.Config) error
```

SavePrompt saves a prompt configuration

<a name="ToolRepository"></a>
## type ToolRepository

ToolRepository stores tools in memory \(for testing/SDK\)

```go
type ToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewToolRepository"></a>
### func NewToolRepository

```go
func NewToolRepository() *ToolRepository
```

NewToolRepository creates a new in\-memory tool repository

<a name="ToolRepository.ListTools"></a>
### func \(\*ToolRepository\) ListTools

```go
func (r *ToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="ToolRepository.LoadTool"></a>
### func \(\*ToolRepository\) LoadTool

```go
func (r *ToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="ToolRepository.RegisterTool"></a>
### func \(\*ToolRepository\) RegisterTool

```go
func (r *ToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool to the in\-memory store

<a name="ToolRepository.SaveTool"></a>
### func \(\*ToolRepository\) SaveTool

```go
func (r *ToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor

# yaml

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/yaml"
```

Package yaml provides YAML file\-based implementations of persistence repositories.

This package is primarily for Arena and development use, loading prompts and tools from YAML configuration files on disk.

## Index

- [type PromptRepository](<#PromptRepository>)
  - [func NewYAMLPromptRepository\(basePath string, taskTypeToFile map\[string\]string\) \*PromptRepository](<#NewYAMLPromptRepository>)
  - [func \(r \*PromptRepository\) LoadFragment\(name, relativePath, baseDir string\) \(\*prompt.Fragment, error\)](<#PromptRepository.LoadFragment>)
  - [func \(r \*PromptRepository\) SavePrompt\(config \*prompt.Config\) error](<#PromptRepository.SavePrompt>)
- [type ToolRepository](<#ToolRepository>)
  - [func NewYAMLToolRepository\(basePath string\) \*ToolRepository](<#NewYAMLToolRepository>)
  - [func \(r \*ToolRepository\) ListTools\(\) \(\[\]string, error\)](<#ToolRepository.ListTools>)
  - [func \(r \*ToolRepository\) LoadDirectory\(dirPath string\) error](<#ToolRepository.LoadDirectory>)
  - [func \(r \*ToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#ToolRepository.LoadTool>)
  - [func \(r \*ToolRepository\) LoadToolFromFile\(filename string\) error](<#ToolRepository.LoadToolFromFile>)
  - [func \(r \*ToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#ToolRepository.RegisterTool>)
  - [func \(r \*ToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#ToolRepository.SaveTool>)


<a name="PromptRepository"></a>
## type PromptRepository

YAMLPromptRepository loads prompts from YAML files on disk

```go
type PromptRepository struct {
    *common.BasePromptRepository
}
```

<a name="NewYAMLPromptRepository"></a>
### func NewYAMLPromptRepository

```go
func NewYAMLPromptRepository(basePath string, taskTypeToFile map[string]string) *PromptRepository
```

NewYAMLPromptRepository creates a YAML file\-based prompt repository If taskTypeToFile mappings are provided, they will be used for lookups. Otherwise, the repository will search the basePath directory.

<a name="PromptRepository.LoadFragment"></a>
### func \(\*PromptRepository\) LoadFragment

```go
func (r *PromptRepository) LoadFragment(name, relativePath, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name and optional path

<a name="PromptRepository.SavePrompt"></a>
### func \(\*PromptRepository\) SavePrompt

```go
func (r *PromptRepository) SavePrompt(config *prompt.Config) error
```

SavePrompt saves a prompt configuration \(not yet implemented\)

<a name="ToolRepository"></a>
## type ToolRepository

YAMLToolRepository loads tools from YAML files on disk

```go
type ToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewYAMLToolRepository"></a>
### func NewYAMLToolRepository

```go
func NewYAMLToolRepository(basePath string) *ToolRepository
```

NewYAMLToolRepository creates a YAML file\-based tool repository

<a name="ToolRepository.ListTools"></a>
### func \(\*ToolRepository\) ListTools

```go
func (r *ToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="ToolRepository.LoadDirectory"></a>
### func \(\*ToolRepository\) LoadDirectory

```go
func (r *ToolRepository) LoadDirectory(dirPath string) error
```

LoadDirectory recursively loads all YAML tool files from a directory

<a name="ToolRepository.LoadTool"></a>
### func \(\*ToolRepository\) LoadTool

```go
func (r *ToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="ToolRepository.LoadToolFromFile"></a>
### func \(\*ToolRepository\) LoadToolFromFile

```go
func (r *ToolRepository) LoadToolFromFile(filename string) error
```

LoadToolFromFile loads a tool from a YAML file and registers it

<a name="ToolRepository.RegisterTool"></a>
### func \(\*ToolRepository\) RegisterTool

```go
func (r *ToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool descriptor directly to the repository

<a name="ToolRepository.SaveTool"></a>
### func \(\*ToolRepository\) SaveTool

```go
func (r *ToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor \(not yet implemented\)

# stage

```go
import "github.com/AltairaLabs/PromptKit/runtime/pipeline/stage"
```

Package stage provides the reactive streams architecture for pipeline execution.

Package stage provides the reactive streams architecture for pipeline execution.

Package stage provides the reactive streams architecture for pipeline execution.

Package stage provides the reactive streams architecture for pipeline execution.

Package stage provides the reactive streams architecture for pipeline execution.

Package stage provides pipeline stages for audio processing.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func BatchEmbeddingTexts\(texts \[\]string, batchSize int\) \[\]\[\]string](<#BatchEmbeddingTexts>)
- [func CosineSimilarity\(a, b \[\]float32\) float64](<#CosineSimilarity>)
- [func DescribeCapabilities\(stage Stage\) string](<#DescribeCapabilities>)
- [func GetTraceInfo\(elem \*StreamElement\) \(traceID string, stageTimes map\[string\]time.Time\)](<#GetTraceInfo>)
- [func NormalizeEmbedding\(embedding \[\]float32\) \[\]float32](<#NormalizeEmbedding>)
- [func PutElement\(elem \*StreamElement\)](<#PutElement>)
- [func ValidateCapabilities\(stages \[\]Stage, edges map\[string\]\[\]string\)](<#ValidateCapabilities>)
- [type AudioCapability](<#AudioCapability>)
  - [func \(ac \*AudioCapability\) AcceptsAudio\(audio \*AudioData\) bool](<#AudioCapability.AcceptsAudio>)
  - [func \(ac \*AudioCapability\) AcceptsChannels\(channels int\) bool](<#AudioCapability.AcceptsChannels>)
  - [func \(ac \*AudioCapability\) AcceptsFormat\(format AudioFormat\) bool](<#AudioCapability.AcceptsFormat>)
  - [func \(ac \*AudioCapability\) AcceptsSampleRate\(rate int\) bool](<#AudioCapability.AcceptsSampleRate>)
- [type AudioData](<#AudioData>)
- [type AudioFormat](<#AudioFormat>)
  - [func \(af AudioFormat\) String\(\) string](<#AudioFormat.String>)
- [type AudioResampleConfig](<#AudioResampleConfig>)
  - [func DefaultAudioResampleConfig\(\) AudioResampleConfig](<#DefaultAudioResampleConfig>)
- [type AudioResampleStage](<#AudioResampleStage>)
  - [func NewAudioResampleStage\(config AudioResampleConfig\) \*AudioResampleStage](<#NewAudioResampleStage>)
  - [func \(s \*AudioResampleStage\) GetConfig\(\) AudioResampleConfig](<#AudioResampleStage.GetConfig>)
  - [func \(s \*AudioResampleStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#AudioResampleStage.Process>)
- [type AudioTurnConfig](<#AudioTurnConfig>)
  - [func DefaultAudioTurnConfig\(\) AudioTurnConfig](<#DefaultAudioTurnConfig>)
- [type AudioTurnStage](<#AudioTurnStage>)
  - [func NewAudioTurnStage\(config AudioTurnConfig\) \(\*AudioTurnStage, error\)](<#NewAudioTurnStage>)
  - [func \(s \*AudioTurnStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#AudioTurnStage.Process>)
- [type BaseStage](<#BaseStage>)
  - [func NewBaseStage\(name string, stageType StageType\) BaseStage](<#NewBaseStage>)
  - [func \(b \*BaseStage\) Name\(\) string](<#BaseStage.Name>)
  - [func \(b \*BaseStage\) Type\(\) StageType](<#BaseStage.Type>)
- [type BroadcastRouter](<#BroadcastRouter>)
  - [func NewBroadcastRouter\(name string\) \*BroadcastRouter](<#NewBroadcastRouter>)
  - [func \(r \*BroadcastRouter\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#BroadcastRouter.Process>)
  - [func \(r \*BroadcastRouter\) RegisterOutput\(name string, output chan\<\- StreamElement\)](<#BroadcastRouter.RegisterOutput>)
- [type ByOriginalIndex](<#ByOriginalIndex>)
  - [func \(s ByOriginalIndex\) Len\(\) int](<#ByOriginalIndex.Len>)
  - [func \(s ByOriginalIndex\) Less\(i, j int\) bool](<#ByOriginalIndex.Less>)
  - [func \(s ByOriginalIndex\) Swap\(i, j int\)](<#ByOriginalIndex.Swap>)
- [type Capabilities](<#Capabilities>)
  - [func AnyCapabilities\(\) Capabilities](<#AnyCapabilities>)
  - [func AudioCapabilities\(formats \[\]AudioFormat, sampleRates, channels \[\]int\) Capabilities](<#AudioCapabilities>)
  - [func MessageCapabilities\(\) Capabilities](<#MessageCapabilities>)
  - [func TextCapabilities\(\) Capabilities](<#TextCapabilities>)
  - [func \(c \*Capabilities\) AcceptsContentType\(ct ContentType\) bool](<#Capabilities.AcceptsContentType>)
  - [func \(c \*Capabilities\) AcceptsElement\(elem \*StreamElement\) bool](<#Capabilities.AcceptsElement>)
- [type ContentRouter](<#ContentRouter>)
  - [func NewContentRouter\(name string, rules ...RoutingRule\) \*ContentRouter](<#NewContentRouter>)
  - [func \(r \*ContentRouter\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#ContentRouter.Process>)
  - [func \(r \*ContentRouter\) RegisterOutput\(name string, output chan\<\- StreamElement\)](<#ContentRouter.RegisterOutput>)
- [type ContentType](<#ContentType>)
  - [func \(ct ContentType\) String\(\) string](<#ContentType.String>)
- [type ContextBuilderPolicy](<#ContextBuilderPolicy>)
- [type ContextBuilderStage](<#ContextBuilderStage>)
  - [func NewContextBuilderStage\(policy \*ContextBuilderPolicy\) \*ContextBuilderStage](<#NewContextBuilderStage>)
  - [func \(s \*ContextBuilderStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#ContextBuilderStage.Process>)
- [type DebugStage](<#DebugStage>)
  - [func NewDebugStage\(stageName string\) \*DebugStage](<#NewDebugStage>)
  - [func \(s \*DebugStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#DebugStage.Process>)
- [type DuplexProviderStage](<#DuplexProviderStage>)
  - [func NewDuplexProviderStage\(provider providers.StreamInputSupport, baseConfig \*providers.StreamingInputConfig\) \*DuplexProviderStage](<#NewDuplexProviderStage>)
  - [func \(s \*DuplexProviderStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#DuplexProviderStage.Process>)
- [type EndInputter](<#EndInputter>)
- [type ExecutionResult](<#ExecutionResult>)
- [type ExecutionTrace](<#ExecutionTrace>)
- [type FilterStage](<#FilterStage>)
  - [func NewFilterStage\(name string, predicate func\(StreamElement\) bool\) \*FilterStage](<#NewFilterStage>)
  - [func \(fs \*FilterStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#FilterStage.Process>)
- [type FormatCapable](<#FormatCapable>)
- [type HashRouter](<#HashRouter>)
  - [func NewHashRouter\(name string, outputNames \[\]string, keyFunc func\(StreamElement\) string\) \*HashRouter](<#NewHashRouter>)
  - [func \(r \*HashRouter\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#HashRouter.Process>)
  - [func \(r \*HashRouter\) RegisterOutput\(name string, output chan\<\- StreamElement\)](<#HashRouter.RegisterOutput>)
- [type ImageData](<#ImageData>)
- [type MapStage](<#MapStage>)
  - [func NewMapStage\(name string, mapFunc func\(StreamElement\) \(StreamElement, error\)\) \*MapStage](<#NewMapStage>)
  - [func \(ms \*MapStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#MapStage.Process>)
- [type MediaExternalizerConfig](<#MediaExternalizerConfig>)
- [type MediaExternalizerStage](<#MediaExternalizerStage>)
  - [func NewMediaExternalizerStage\(config \*MediaExternalizerConfig\) \*MediaExternalizerStage](<#NewMediaExternalizerStage>)
  - [func \(s \*MediaExternalizerStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#MediaExternalizerStage.Process>)
- [type MergeStage](<#MergeStage>)
  - [func NewMergeStage\(name string, inputCount int\) \*MergeStage](<#NewMergeStage>)
  - [func \(s \*MergeStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#MergeStage.Process>)
  - [func \(s \*MergeStage\) ProcessMultiple\(ctx context.Context, inputs \[\]\<\-chan StreamElement, output chan\<\- StreamElement\) error](<#MergeStage.ProcessMultiple>)
- [type MetricsStage](<#MetricsStage>)
  - [func NewMetricsStage\(wrappedStage Stage\) \*MetricsStage](<#NewMetricsStage>)
  - [func \(s \*MetricsStage\) GetMetrics\(\) StageMetrics](<#MetricsStage.GetMetrics>)
  - [func \(s \*MetricsStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#MetricsStage.Process>)
- [type PassthroughStage](<#PassthroughStage>)
  - [func NewPassthroughStage\(name string\) \*PassthroughStage](<#NewPassthroughStage>)
  - [func \(ps \*PassthroughStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#PassthroughStage.Process>)
- [type PipelineBuilder](<#PipelineBuilder>)
  - [func NewPipelineBuilder\(\) \*PipelineBuilder](<#NewPipelineBuilder>)
  - [func NewPipelineBuilderWithConfig\(config \*PipelineConfig\) \*PipelineBuilder](<#NewPipelineBuilderWithConfig>)
  - [func \(b \*PipelineBuilder\) AddStage\(stage Stage\) \*PipelineBuilder](<#PipelineBuilder.AddStage>)
  - [func \(b \*PipelineBuilder\) Branch\(fromStage string, toStages ...string\) \*PipelineBuilder](<#PipelineBuilder.Branch>)
  - [func \(b \*PipelineBuilder\) Build\(\) \(\*StreamPipeline, error\)](<#PipelineBuilder.Build>)
  - [func \(b \*PipelineBuilder\) Chain\(stages ...Stage\) \*PipelineBuilder](<#PipelineBuilder.Chain>)
  - [func \(b \*PipelineBuilder\) Clone\(\) \*PipelineBuilder](<#PipelineBuilder.Clone>)
  - [func \(b \*PipelineBuilder\) Connect\(fromStage, toStage string\) \*PipelineBuilder](<#PipelineBuilder.Connect>)
  - [func \(b \*PipelineBuilder\) WithConfig\(config \*PipelineConfig\) \*PipelineBuilder](<#PipelineBuilder.WithConfig>)
  - [func \(b \*PipelineBuilder\) WithEventEmitter\(emitter \*events.Emitter\) \*PipelineBuilder](<#PipelineBuilder.WithEventEmitter>)
- [type PipelineConfig](<#PipelineConfig>)
  - [func DefaultPipelineConfig\(\) \*PipelineConfig](<#DefaultPipelineConfig>)
  - [func \(c \*PipelineConfig\) Validate\(\) error](<#PipelineConfig.Validate>)
  - [func \(c \*PipelineConfig\) WithChannelBufferSize\(size int\) \*PipelineConfig](<#PipelineConfig.WithChannelBufferSize>)
  - [func \(c \*PipelineConfig\) WithExecutionTimeout\(timeout time.Duration\) \*PipelineConfig](<#PipelineConfig.WithExecutionTimeout>)
  - [func \(c \*PipelineConfig\) WithGracefulShutdownTimeout\(timeout time.Duration\) \*PipelineConfig](<#PipelineConfig.WithGracefulShutdownTimeout>)
  - [func \(c \*PipelineConfig\) WithMaxConcurrentPipelines\(maxPipelines int\) \*PipelineConfig](<#PipelineConfig.WithMaxConcurrentPipelines>)
  - [func \(c \*PipelineConfig\) WithMetrics\(enabled bool\) \*PipelineConfig](<#PipelineConfig.WithMetrics>)
  - [func \(c \*PipelineConfig\) WithPriorityQueue\(enabled bool\) \*PipelineConfig](<#PipelineConfig.WithPriorityQueue>)
  - [func \(c \*PipelineConfig\) WithTracing\(enabled bool\) \*PipelineConfig](<#PipelineConfig.WithTracing>)
- [type Priority](<#Priority>)
- [type PriorityChannel](<#PriorityChannel>)
  - [func NewPriorityChannel\(capacity int\) \*PriorityChannel](<#NewPriorityChannel>)
  - [func \(pc \*PriorityChannel\) Close\(\)](<#PriorityChannel.Close>)
  - [func \(pc \*PriorityChannel\) Len\(\) int](<#PriorityChannel.Len>)
  - [func \(pc \*PriorityChannel\) Receive\(ctx context.Context\) \(StreamElement, bool, error\)](<#PriorityChannel.Receive>)
  - [func \(pc \*PriorityChannel\) Send\(ctx context.Context, elem StreamElement\) error](<#PriorityChannel.Send>)
- [type PromptAssemblyStage](<#PromptAssemblyStage>)
  - [func NewPromptAssemblyStage\(promptRegistry \*prompt.Registry, taskType string, baseVariables map\[string\]string\) \*PromptAssemblyStage](<#NewPromptAssemblyStage>)
  - [func \(s \*PromptAssemblyStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#PromptAssemblyStage.Process>)
- [type ProviderConfig](<#ProviderConfig>)
- [type ProviderStage](<#ProviderStage>)
  - [func NewProviderStage\(provider providers.Provider, toolRegistry \*tools.Registry, toolPolicy \*pipeline.ToolPolicy, config \*ProviderConfig\) \*ProviderStage](<#NewProviderStage>)
  - [func \(s \*ProviderStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#ProviderStage.Process>)
- [type QuerySourceType](<#QuerySourceType>)
- [type RandomRouter](<#RandomRouter>)
  - [func NewRandomRouter\(name string, outputNames \[\]string\) \*RandomRouter](<#NewRandomRouter>)
  - [func \(r \*RandomRouter\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#RandomRouter.Process>)
  - [func \(r \*RandomRouter\) RegisterOutput\(name string, output chan\<\- StreamElement\)](<#RandomRouter.RegisterOutput>)
- [type RelevanceConfig](<#RelevanceConfig>)
- [type Response](<#Response>)
- [type ResponseVADConfig](<#ResponseVADConfig>)
  - [func DefaultResponseVADConfig\(\) ResponseVADConfig](<#DefaultResponseVADConfig>)
- [type ResponseVADStage](<#ResponseVADStage>)
  - [func NewResponseVADStage\(config ResponseVADConfig\) \(\*ResponseVADStage, error\)](<#NewResponseVADStage>)
  - [func \(s \*ResponseVADStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#ResponseVADStage.Process>)
- [type RoundRobinRouter](<#RoundRobinRouter>)
  - [func NewRoundRobinRouter\(name string, outputNames \[\]string\) \*RoundRobinRouter](<#NewRoundRobinRouter>)
  - [func \(r \*RoundRobinRouter\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#RoundRobinRouter.Process>)
  - [func \(r \*RoundRobinRouter\) RegisterOutput\(name string, output chan\<\- StreamElement\)](<#RoundRobinRouter.RegisterOutput>)
- [type RouterFunc](<#RouterFunc>)
- [type RouterStage](<#RouterStage>)
  - [func NewRouterStage\(name string, routerFunc RouterFunc\) \*RouterStage](<#NewRouterStage>)
  - [func \(s \*RouterStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#RouterStage.Process>)
  - [func \(s \*RouterStage\) RegisterOutput\(name string, output chan\<\- StreamElement\)](<#RouterStage.RegisterOutput>)
- [type RoutingRule](<#RoutingRule>)
  - [func RouteAudio\(output string, format AudioFormat\) RoutingRule](<#RouteAudio>)
  - [func RouteContentType\(output string, ct ContentType\) RoutingRule](<#RouteContentType>)
  - [func RouteWhen\(output string, predicate func\(StreamElement\) bool\) RoutingRule](<#RouteWhen>)
- [type STTStage](<#STTStage>)
  - [func NewSTTStage\(service stt.Service, config STTStageConfig\) \*STTStage](<#NewSTTStage>)
  - [func \(s \*STTStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#STTStage.Process>)
- [type STTStageConfig](<#STTStageConfig>)
  - [func DefaultSTTStageConfig\(\) STTStageConfig](<#DefaultSTTStageConfig>)
- [type ScoredMessage](<#ScoredMessage>)
- [type ScoredMessages](<#ScoredMessages>)
  - [func \(s ScoredMessages\) Len\(\) int](<#ScoredMessages.Len>)
  - [func \(s ScoredMessages\) Less\(i, j int\) bool](<#ScoredMessages.Less>)
  - [func \(s ScoredMessages\) Swap\(i, j int\)](<#ScoredMessages.Swap>)
- [type Stage](<#Stage>)
- [type StageError](<#StageError>)
  - [func NewStageError\(stageName string, stageType StageType, err error\) \*StageError](<#NewStageError>)
  - [func \(e \*StageError\) Error\(\) string](<#StageError.Error>)
  - [func \(e \*StageError\) Unwrap\(\) error](<#StageError.Unwrap>)
- [type StageFunc](<#StageFunc>)
  - [func NewStageFunc\(name string, stageType StageType, fn func\(context.Context, \<\-chan StreamElement, chan\<\- StreamElement\) error\) \*StageFunc](<#NewStageFunc>)
  - [func \(sf \*StageFunc\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#StageFunc.Process>)
- [type StageMetrics](<#StageMetrics>)
  - [func NewStageMetrics\(stageName string\) \*StageMetrics](<#NewStageMetrics>)
  - [func \(m \*StageMetrics\) GetMetrics\(\) StageMetrics](<#StageMetrics.GetMetrics>)
  - [func \(m \*StageMetrics\) RecordElement\(latency time.Duration, hasError bool\)](<#StageMetrics.RecordElement>)
  - [func \(m \*StageMetrics\) Reset\(\)](<#StageMetrics.Reset>)
- [type StageType](<#StageType>)
  - [func \(st StageType\) String\(\) string](<#StageType.String>)
- [type StateStoreLoadStage](<#StateStoreLoadStage>)
  - [func NewStateStoreLoadStage\(config \*pipeline.StateStoreConfig\) \*StateStoreLoadStage](<#NewStateStoreLoadStage>)
  - [func \(s \*StateStoreLoadStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#StateStoreLoadStage.Process>)
- [type StateStoreSaveStage](<#StateStoreSaveStage>)
  - [func NewStateStoreSaveStage\(config \*pipeline.StateStoreConfig\) \*StateStoreSaveStage](<#NewStateStoreSaveStage>)
  - [func \(s \*StateStoreSaveStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#StateStoreSaveStage.Process>)
- [type StreamElement](<#StreamElement>)
  - [func GetAudioElement\(audio \*AudioData\) \*StreamElement](<#GetAudioElement>)
  - [func GetElement\(\) \*StreamElement](<#GetElement>)
  - [func GetEndOfStreamElement\(\) \*StreamElement](<#GetEndOfStreamElement>)
  - [func GetErrorElement\(err error\) \*StreamElement](<#GetErrorElement>)
  - [func GetImageElement\(image \*ImageData\) \*StreamElement](<#GetImageElement>)
  - [func GetMessageElement\(msg \*types.Message\) \*StreamElement](<#GetMessageElement>)
  - [func GetTextElement\(text string\) \*StreamElement](<#GetTextElement>)
  - [func GetVideoElement\(video \*VideoData\) \*StreamElement](<#GetVideoElement>)
  - [func NewAudioElement\(audio \*AudioData\) StreamElement](<#NewAudioElement>)
  - [func NewEndOfStreamElement\(\) StreamElement](<#NewEndOfStreamElement>)
  - [func NewErrorElement\(err error\) StreamElement](<#NewErrorElement>)
  - [func NewImageElement\(image \*ImageData\) StreamElement](<#NewImageElement>)
  - [func NewMessageElement\(msg \*types.Message\) StreamElement](<#NewMessageElement>)
  - [func NewTextElement\(text string\) StreamElement](<#NewTextElement>)
  - [func NewVideoElement\(video \*VideoData\) StreamElement](<#NewVideoElement>)
  - [func \(e \*StreamElement\) GetMetadata\(key string\) interface\{\}](<#StreamElement.GetMetadata>)
  - [func \(e \*StreamElement\) HasContent\(\) bool](<#StreamElement.HasContent>)
  - [func \(e \*StreamElement\) IsControl\(\) bool](<#StreamElement.IsControl>)
  - [func \(e \*StreamElement\) IsEmpty\(\) bool](<#StreamElement.IsEmpty>)
  - [func \(e \*StreamElement\) Reset\(\)](<#StreamElement.Reset>)
  - [func \(e \*StreamElement\) WithMetadata\(key string, value interface\{\}\) \*StreamElement](<#StreamElement.WithMetadata>)
  - [func \(e \*StreamElement\) WithPriority\(priority Priority\) \*StreamElement](<#StreamElement.WithPriority>)
  - [func \(e \*StreamElement\) WithSequence\(seq int64\) \*StreamElement](<#StreamElement.WithSequence>)
  - [func \(e \*StreamElement\) WithSource\(source string\) \*StreamElement](<#StreamElement.WithSource>)
- [type StreamPipeline](<#StreamPipeline>)
  - [func \(p \*StreamPipeline\) Execute\(ctx context.Context, input \<\-chan StreamElement\) \(\<\-chan StreamElement, error\)](<#StreamPipeline.Execute>)
  - [func \(p \*StreamPipeline\) ExecuteSync\(ctx context.Context, input ...StreamElement\) \(\*ExecutionResult, error\)](<#StreamPipeline.ExecuteSync>)
  - [func \(p \*StreamPipeline\) Shutdown\(ctx context.Context\) error](<#StreamPipeline.Shutdown>)
- [type TTSConfig](<#TTSConfig>)
  - [func DefaultTTSConfig\(\) TTSConfig](<#DefaultTTSConfig>)
- [type TTSService](<#TTSService>)
- [type TTSStage](<#TTSStage>)
  - [func NewTTSStage\(tts TTSService, config TTSConfig\) \*TTSStage](<#NewTTSStage>)
  - [func \(s \*TTSStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#TTSStage.Process>)
- [type TTSStageWithInterruption](<#TTSStageWithInterruption>)
  - [func NewTTSStageWithInterruption\(service tts.Service, config TTSStageWithInterruptionConfig\) \*TTSStageWithInterruption](<#NewTTSStageWithInterruption>)
  - [func \(s \*TTSStageWithInterruption\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#TTSStageWithInterruption.Process>)
- [type TTSStageWithInterruptionConfig](<#TTSStageWithInterruptionConfig>)
  - [func DefaultTTSStageWithInterruptionConfig\(\) TTSStageWithInterruptionConfig](<#DefaultTTSStageWithInterruptionConfig>)
- [type TemplateStage](<#TemplateStage>)
  - [func NewTemplateStage\(\) \*TemplateStage](<#NewTemplateStage>)
  - [func \(s \*TemplateStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#TemplateStage.Process>)
- [type TracingStage](<#TracingStage>)
  - [func NewTracingStage\(wrappedStage Stage, traceIDGen func\(\) string\) \*TracingStage](<#NewTracingStage>)
  - [func \(s \*TracingStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#TracingStage.Process>)
- [type Transcriber](<#Transcriber>)
- [type TruncationStrategy](<#TruncationStrategy>)
- [type VADAccumulatorStage](<#VADAccumulatorStage>)
  - [func NewVADAccumulatorStage\(analyzer audio.VADAnalyzer, transcriber Transcriber, config VADConfig\) \*VADAccumulatorStage](<#NewVADAccumulatorStage>)
  - [func \(s \*VADAccumulatorStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#VADAccumulatorStage.Process>)
- [type VADConfig](<#VADConfig>)
  - [func DefaultVADConfig\(\) VADConfig](<#DefaultVADConfig>)
- [type ValidationStage](<#ValidationStage>)
  - [func NewValidationStage\(registry \*validators.Registry, suppressExceptions bool\) \*ValidationStage](<#NewValidationStage>)
  - [func \(s \*ValidationStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#ValidationStage.Process>)
- [type VariableProviderStage](<#VariableProviderStage>)
  - [func NewVariableProviderStage\(providers ...variables.Provider\) \*VariableProviderStage](<#NewVariableProviderStage>)
  - [func \(s \*VariableProviderStage\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#VariableProviderStage.Process>)
- [type VideoData](<#VideoData>)
- [type WeightedRouter](<#WeightedRouter>)
  - [func NewWeightedRouter\(name string, weights map\[string\]float64\) \*WeightedRouter](<#NewWeightedRouter>)
  - [func \(r \*WeightedRouter\) Process\(ctx context.Context, input \<\-chan StreamElement, output chan\<\- StreamElement\) error](<#WeightedRouter.Process>)
  - [func \(r \*WeightedRouter\) RegisterOutput\(name string, output chan\<\- StreamElement\)](<#WeightedRouter.RegisterOutput>)


## Constants

<a name="DefaultChannelBufferSize"></a>

```go
const (
    // DefaultChannelBufferSize is the default buffer size for channels between stages.
    DefaultChannelBufferSize = 16
    // DefaultMaxConcurrentPipelines is the default maximum number of concurrent pipeline executions.
    DefaultMaxConcurrentPipelines = 100
    // DefaultExecutionTimeoutSeconds is the default execution timeout in seconds.
    DefaultExecutionTimeoutSeconds = 30
    // DefaultGracefulShutdownTimeoutSeconds is the default graceful shutdown timeout in seconds.
    DefaultGracefulShutdownTimeoutSeconds = 10
)
```

## Variables

<a name="ErrPipelineShuttingDown"></a>Common errors

```go
var (
    // ErrPipelineShuttingDown is returned when attempting to execute a pipeline that is shutting down.
    ErrPipelineShuttingDown = errors.New("pipeline is shutting down")

    // ErrShutdownTimeout is returned when pipeline shutdown times out.
    ErrShutdownTimeout = errors.New("shutdown timeout exceeded")

    // ErrInvalidPipeline is returned when building an invalid pipeline.
    ErrInvalidPipeline = errors.New("invalid pipeline configuration")

    // ErrCyclicDependency is returned when the pipeline DAG contains cycles.
    ErrCyclicDependency = errors.New("cyclic dependency detected in pipeline")

    // ErrStageNotFound is returned when a referenced stage doesn't exist.
    ErrStageNotFound = errors.New("stage not found")

    // ErrDuplicateStageName is returned when multiple stages have the same name.
    ErrDuplicateStageName = errors.New("duplicate stage name")

    // ErrNoStages is returned when trying to build a pipeline with no stages.
    ErrNoStages = errors.New("pipeline must have at least one stage")

    // ErrInvalidChannelBufferSize is returned for invalid buffer size.
    ErrInvalidChannelBufferSize = errors.New("channel buffer size must be non-negative")

    // ErrInvalidMaxConcurrentPipelines is returned for invalid max concurrent pipelines.
    ErrInvalidMaxConcurrentPipelines = errors.New("max concurrent pipelines must be non-negative")

    // ErrInvalidExecutionTimeout is returned for invalid execution timeout.
    ErrInvalidExecutionTimeout = errors.New("execution timeout must be non-negative")

    // ErrInvalidGracefulShutdownTimeout is returned for invalid graceful shutdown timeout.
    ErrInvalidGracefulShutdownTimeout = errors.New("graceful shutdown timeout must be non-negative")
)
```

<a name="BatchEmbeddingTexts"></a>
## func BatchEmbeddingTexts

```go
func BatchEmbeddingTexts(texts []string, batchSize int) [][]string
```

BatchEmbeddingTexts splits texts into batches of the given size. Useful for respecting embedding provider batch limits.

<a name="CosineSimilarity"></a>
## func CosineSimilarity

```go
func CosineSimilarity(a, b []float32) float64
```

CosineSimilarity computes the cosine similarity between two embedding vectors. Returns a value between \-1.0 and 1.0, where:

- 1.0 means vectors are identical in direction
- 0.0 means vectors are orthogonal \(unrelated\)
- \-1.0 means vectors are opposite

For text embeddings, values typically range from 0.0 to 1.0, with higher values indicating greater semantic similarity.

Returns 0.0 if vectors have different lengths, are empty, or have zero magnitude.

<a name="DescribeCapabilities"></a>
## func DescribeCapabilities

```go
func DescribeCapabilities(stage Stage) string
```

DescribeCapabilities returns a human\-readable description of a stage's capabilities. Useful for debugging and logging.

<a name="GetTraceInfo"></a>
## func GetTraceInfo

```go
func GetTraceInfo(elem *StreamElement) (traceID string, stageTimes map[string]time.Time)
```

GetTraceInfo extracts trace information from an element.

<a name="NormalizeEmbedding"></a>
## func NormalizeEmbedding

```go
func NormalizeEmbedding(embedding []float32) []float32
```

NormalizeEmbedding normalizes an embedding vector to unit length. This can improve similarity comparisons by ensuring all vectors have the same magnitude.

<a name="PutElement"></a>
## func PutElement

```go
func PutElement(elem *StreamElement)
```

PutElement returns a StreamElement to the pool for reuse. The element is reset before being returned to the pool to prevent data leaks. After calling PutElement, the caller must not use the element again.

<a name="ValidateCapabilities"></a>
## func ValidateCapabilities

```go
func ValidateCapabilities(stages []Stage, edges map[string][]string)
```

ValidateCapabilities checks format compatibility between connected stages. It logs warnings for potential mismatches but does not return errors, as format compatibility can often only be fully determined at runtime.

This function is called during pipeline building to provide early feedback about potential issues.

<a name="AudioCapability"></a>
## type AudioCapability

AudioCapability describes audio format requirements for a stage.

```go
type AudioCapability struct {
    // Formats lists accepted audio formats. Empty slice means any format.
    Formats []AudioFormat
    // SampleRates lists accepted sample rates in Hz. Empty slice means any rate.
    SampleRates []int
    // Channels lists accepted channel counts. Empty slice means any.
    Channels []int
}
```

<a name="AudioCapability.AcceptsAudio"></a>
### func \(\*AudioCapability\) AcceptsAudio

```go
func (ac *AudioCapability) AcceptsAudio(audio *AudioData) bool
```

AcceptsAudio returns true if this capability accepts the given audio data.

<a name="AudioCapability.AcceptsChannels"></a>
### func \(\*AudioCapability\) AcceptsChannels

```go
func (ac *AudioCapability) AcceptsChannels(channels int) bool
```

AcceptsChannels returns true if this capability accepts the given channel count. Returns true if Channels is empty \(accepts any\).

<a name="AudioCapability.AcceptsFormat"></a>
### func \(\*AudioCapability\) AcceptsFormat

```go
func (ac *AudioCapability) AcceptsFormat(format AudioFormat) bool
```

AcceptsFormat returns true if this capability accepts the given format. Returns true if Formats is empty \(accepts any\).

<a name="AudioCapability.AcceptsSampleRate"></a>
### func \(\*AudioCapability\) AcceptsSampleRate

```go
func (ac *AudioCapability) AcceptsSampleRate(rate int) bool
```

AcceptsSampleRate returns true if this capability accepts the given sample rate. Returns true if SampleRates is empty \(accepts any\).

<a name="AudioData"></a>
## type AudioData

AudioData carries audio samples with metadata.

```go
type AudioData struct {
    Samples    []byte        // Raw audio samples
    SampleRate int           // Sample rate in Hz (e.g., 16000, 44100)
    Channels   int           // Number of audio channels (1=mono, 2=stereo)
    Format     AudioFormat   // Audio encoding format
    Duration   time.Duration // Duration of the audio segment
    Encoding   string        // Encoding scheme (e.g., "pcm", "opus")
}
```

<a name="AudioFormat"></a>
## type AudioFormat

AudioFormat represents the encoding format of audio data.

```go
type AudioFormat int
```

<a name="AudioFormatPCM16"></a>

```go
const (
    // AudioFormatPCM16 is 16-bit PCM encoding
    AudioFormatPCM16 AudioFormat = iota
    // AudioFormatFloat32 is 32-bit floating point encoding
    AudioFormatFloat32
    // AudioFormatOpus is Opus codec encoding
    AudioFormatOpus
    // AudioFormatMP3 is MP3 encoding
    AudioFormatMP3
    // AudioFormatAAC is AAC encoding
    AudioFormatAAC
)
```

<a name="AudioFormat.String"></a>
### func \(AudioFormat\) String

```go
func (af AudioFormat) String() string
```

String returns the string representation of the audio format.

<a name="AudioResampleConfig"></a>
## type AudioResampleConfig

AudioResampleConfig contains configuration for the audio resampling stage.

```go
type AudioResampleConfig struct {
    // TargetSampleRate is the desired output sample rate in Hz.
    // Common values: 16000 (Gemini), 24000 (OpenAI TTS), 44100 (CD quality).
    TargetSampleRate int

    // PassthroughIfSameRate skips resampling if input rate matches target rate.
    // Default: true.
    PassthroughIfSameRate bool
}
```

<a name="DefaultAudioResampleConfig"></a>
### func DefaultAudioResampleConfig

```go
func DefaultAudioResampleConfig() AudioResampleConfig
```

DefaultAudioResampleConfig returns sensible defaults for audio resampling.

<a name="AudioResampleStage"></a>
## type AudioResampleStage

AudioResampleStage resamples audio data to a target sample rate. This is useful for normalizing audio from different sources \(TTS, files\) to match provider requirements.

This is a Transform stage: audio element  resampled audio element \(1:1\)

```go
type AudioResampleStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewAudioResampleStage"></a>
### func NewAudioResampleStage

```go
func NewAudioResampleStage(config AudioResampleConfig) *AudioResampleStage
```

NewAudioResampleStage creates a new audio resampling stage.

<a name="AudioResampleStage.GetConfig"></a>
### func \(\*AudioResampleStage\) GetConfig

```go
func (s *AudioResampleStage) GetConfig() AudioResampleConfig
```

GetConfig returns the stage configuration.

<a name="AudioResampleStage.Process"></a>
### func \(\*AudioResampleStage\) Process

```go
func (s *AudioResampleStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Resamples audio in each element to the target sample rate.

<a name="AudioTurnConfig"></a>
## type AudioTurnConfig

AudioTurnConfig configures the AudioTurnStage.

```go
type AudioTurnConfig struct {
    // VAD is the voice activity detector.
    // If nil, a SimpleVAD with default params is created.
    VAD audio.VADAnalyzer

    // TurnDetector determines when user has finished speaking.
    // If nil, VAD state transitions are used for turn detection.
    TurnDetector audio.TurnDetector

    // InterruptionHandler detects when user interrupts TTS output.
    // This should be shared with TTSStageWithInterruption.
    // If nil, interruption detection is disabled.
    InterruptionHandler *audio.InterruptionHandler

    // SilenceDuration is how long silence must persist to trigger turn complete.
    // Default: 800ms
    SilenceDuration time.Duration

    // MinSpeechDuration is minimum speech before turn can complete.
    // Default: 200ms
    MinSpeechDuration time.Duration

    // MaxTurnDuration is maximum turn length before forcing completion.
    // Default: 30s
    MaxTurnDuration time.Duration

    // SampleRate is the audio sample rate for output AudioData.
    // Default: 16000
    SampleRate int
}
```

<a name="DefaultAudioTurnConfig"></a>
### func DefaultAudioTurnConfig

```go
func DefaultAudioTurnConfig() AudioTurnConfig
```

DefaultAudioTurnConfig returns sensible defaults for AudioTurnStage.

<a name="AudioTurnStage"></a>
## type AudioTurnStage

AudioTurnStage detects voice activity and accumulates audio into complete turns. It outputs complete audio utterances when the user stops speaking.

This stage consolidates: \- Voice Activity Detection \(VAD\) \- Turn boundary detection \- Audio accumulation \- Interruption detection \(shared with TTSStageWithInterruption\)

This is an Accumulate stage: N audio chunks  1 audio utterance

```go
type AudioTurnStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewAudioTurnStage"></a>
### func NewAudioTurnStage

```go
func NewAudioTurnStage(config AudioTurnConfig) (*AudioTurnStage, error)
```

NewAudioTurnStage creates a new audio turn stage.

<a name="AudioTurnStage.Process"></a>
### func \(\*AudioTurnStage\) Process

```go
func (s *AudioTurnStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Accumulates audio chunks until turn complete, then emits audio utterance.

<a name="BaseStage"></a>
## type BaseStage

BaseStage provides common functionality for stage implementations. Stages can embed this to reduce boilerplate.

```go
type BaseStage struct {
    // contains filtered or unexported fields
}
```

<a name="NewBaseStage"></a>
### func NewBaseStage

```go
func NewBaseStage(name string, stageType StageType) BaseStage
```

NewBaseStage creates a new BaseStage with the given name and type.

<a name="BaseStage.Name"></a>
### func \(\*BaseStage\) Name

```go
func (b *BaseStage) Name() string
```

Name returns the stage name.

<a name="BaseStage.Type"></a>
### func \(\*BaseStage\) Type

```go
func (b *BaseStage) Type() StageType
```

Type returns the stage type.

<a name="BroadcastRouter"></a>
## type BroadcastRouter

BroadcastRouter sends each element to ALL registered outputs. Useful for fan\-out scenarios where all consumers need every element.

```go
type BroadcastRouter struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewBroadcastRouter"></a>
### func NewBroadcastRouter

```go
func NewBroadcastRouter(name string) *BroadcastRouter
```

NewBroadcastRouter creates a router that broadcasts to all outputs.

<a name="BroadcastRouter.Process"></a>
### func \(\*BroadcastRouter\) Process

```go
func (r *BroadcastRouter) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process broadcasts each element to all outputs.

<a name="BroadcastRouter.RegisterOutput"></a>
### func \(\*BroadcastRouter\) RegisterOutput

```go
func (r *BroadcastRouter) RegisterOutput(name string, output chan<- StreamElement)
```

RegisterOutput registers an output channel with a name.

<a name="ByOriginalIndex"></a>
## type ByOriginalIndex

ByOriginalIndex sorts ScoredMessages by their original index \(ascending\).

```go
type ByOriginalIndex []ScoredMessage
```

<a name="ByOriginalIndex.Len"></a>
### func \(ByOriginalIndex\) Len

```go
func (s ByOriginalIndex) Len() int
```



<a name="ByOriginalIndex.Less"></a>
### func \(ByOriginalIndex\) Less

```go
func (s ByOriginalIndex) Less(i, j int) bool
```



<a name="ByOriginalIndex.Swap"></a>
### func \(ByOriginalIndex\) Swap

```go
func (s ByOriginalIndex) Swap(i, j int)
```



<a name="Capabilities"></a>
## type Capabilities

Capabilities describes what a stage accepts or produces.

```go
type Capabilities struct {
    // ContentTypes lists the content types handled. Empty means any.
    ContentTypes []ContentType
    // Audio specifies audio-specific requirements. Nil means N/A or any.
    Audio *AudioCapability
}
```

<a name="AnyCapabilities"></a>
### func AnyCapabilities

```go
func AnyCapabilities() Capabilities
```

AnyCapabilities returns capabilities that accept any content type.

<a name="AudioCapabilities"></a>
### func AudioCapabilities

```go
func AudioCapabilities(formats []AudioFormat, sampleRates, channels []int) Capabilities
```

AudioCapabilities returns capabilities for audio content with optional format constraints.

<a name="MessageCapabilities"></a>
### func MessageCapabilities

```go
func MessageCapabilities() Capabilities
```

MessageCapabilities returns capabilities for message content.

<a name="TextCapabilities"></a>
### func TextCapabilities

```go
func TextCapabilities() Capabilities
```

TextCapabilities returns capabilities for text\-only content.

<a name="Capabilities.AcceptsContentType"></a>
### func \(\*Capabilities\) AcceptsContentType

```go
func (c *Capabilities) AcceptsContentType(ct ContentType) bool
```

AcceptsContentType returns true if this capability accepts the given content type. Returns true if ContentTypes is empty \(accepts any\).

<a name="Capabilities.AcceptsElement"></a>
### func \(\*Capabilities\) AcceptsElement

```go
func (c *Capabilities) AcceptsElement(elem *StreamElement) bool
```

AcceptsElement returns true if this capability accepts the given stream element.

<a name="ContentRouter"></a>
## type ContentRouter

ContentRouter routes elements to different outputs based on predicate rules. Rules are evaluated in order; the first matching rule determines the destination. Elements that don't match any rule are dropped with a warning log.

```go
type ContentRouter struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewContentRouter"></a>
### func NewContentRouter

```go
func NewContentRouter(name string, rules ...RoutingRule) *ContentRouter
```

NewContentRouter creates a new content\-aware router with the given rules.

<a name="ContentRouter.Process"></a>
### func \(\*ContentRouter\) Process

```go
func (r *ContentRouter) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process routes elements based on the configured rules.

<a name="ContentRouter.RegisterOutput"></a>
### func \(\*ContentRouter\) RegisterOutput

```go
func (r *ContentRouter) RegisterOutput(name string, output chan<- StreamElement)
```

RegisterOutput registers an output channel with a name. This must be called before Process\(\) to set up routing destinations.

<a name="ContentType"></a>
## type ContentType

ContentType describes the type of content a stage handles.

```go
type ContentType int
```

<a name="ContentTypeAny"></a>

```go
const (
    // ContentTypeAny indicates the stage accepts any content type.
    ContentTypeAny ContentType = iota
    // ContentTypeText indicates text content.
    ContentTypeText
    // ContentTypeAudio indicates audio content.
    ContentTypeAudio
    // ContentTypeVideo indicates video content.
    ContentTypeVideo
    // ContentTypeImage indicates image content.
    ContentTypeImage
    // ContentTypeMessage indicates a complete message.
    ContentTypeMessage
    // ContentTypeToolCall indicates a tool invocation.
    ContentTypeToolCall
)
```

<a name="ContentType.String"></a>
### func \(ContentType\) String

```go
func (ct ContentType) String() string
```

String returns the string representation of the content type.

<a name="ContextBuilderPolicy"></a>
## type ContextBuilderPolicy

ContextBuilderPolicy defines token budget and truncation behavior.

```go
type ContextBuilderPolicy struct {
    TokenBudget      int
    ReserveForOutput int
    Strategy         TruncationStrategy
    CacheBreakpoints bool

    // RelevanceConfig for TruncateLeastRelevant strategy (optional).
    // If nil when using TruncateLeastRelevant, falls back to TruncateOldest.
    RelevanceConfig *RelevanceConfig
}
```

<a name="ContextBuilderStage"></a>
## type ContextBuilderStage

ContextBuilderStage manages token budget and truncates messages if needed.

This stage ensures the conversation context fits within the LLM's token budget by applying truncation strategies when messages exceed the limit.

Token budget calculation:

```
available = TokenBudget - ReserveForOutput - systemPromptTokens
```

Truncation strategies \(TruncationStrategy\):

- TruncateOldest: removes oldest messages first \(keeps most recent context\)
- TruncateLeastRelevant: removes least relevant messages \(requires embeddings\) \[TODO\]
- TruncateSummarize: compresses old messages into summaries \[TODO\]
- TruncateFail: returns error if budget exceeded \(strict mode\)

Configuration \(ContextBuilderPolicy\):

- TokenBudget: total tokens allowed \(0 = unlimited, pass\-through mode\)
- ReserveForOutput: tokens reserved for LLM response
- Strategy: truncation strategy to apply
- CacheBreakpoints: enable prompt caching hints

Metadata added:

- context\_truncated: true if truncation was applied
- enable\_cache\_breakpoints: copied from policy.CacheBreakpoints

This is an Accumulate stage: N input elements  N \(possibly fewer\) output elements

```go
type ContextBuilderStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewContextBuilderStage"></a>
### func NewContextBuilderStage

```go
func NewContextBuilderStage(policy *ContextBuilderPolicy) *ContextBuilderStage
```

NewContextBuilderStage creates a context builder stage.

<a name="ContextBuilderStage.Process"></a>
### func \(\*ContextBuilderStage\) Process

```go
func (s *ContextBuilderStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process enforces token budget and truncates messages if needed.

<a name="DebugStage"></a>
## type DebugStage

DebugStage logs StreamElements for debugging pipeline state. Useful for development and troubleshooting.

```go
type DebugStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewDebugStage"></a>
### func NewDebugStage

```go
func NewDebugStage(stageName string) *DebugStage
```

NewDebugStage creates a debug stage that logs elements at a specific pipeline location.

<a name="DebugStage.Process"></a>
### func \(\*DebugStage\) Process

```go
func (s *DebugStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process logs each element as it passes through \(passthrough transform\).

<a name="DuplexProviderStage"></a>
## type DuplexProviderStage

DuplexProviderStage handles bidirectional streaming through a session. It forwards elements from input to the provider's session and forwards responses from the session to output.

This stage is PROVIDER\-AGNOSTIC. Provider\-specific behaviors \(interruptions, reconnection, protocol quirks\) are handled BY the provider internally.

System Prompt Handling: The first element received may contain a system prompt in metadata\["system\_prompt"\]. This is sent to the session via SendSystemContext\(\) before processing audio/text.

Response Accumulation: Streaming providers send text/audio responses in chunks. This stage accumulates content across chunks and creates a Message on turn completion \(FinishReason\).

Session Closure: When the session closes unexpectedly, any accumulated content is emitted as a partial response. The executor is responsible for session recreation if needed.

This is a Bidirectional stage: input elements  session  output elements

```go
type DuplexProviderStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewDuplexProviderStage"></a>
### func NewDuplexProviderStage

```go
func NewDuplexProviderStage(provider providers.StreamInputSupport, baseConfig *providers.StreamingInputConfig) *DuplexProviderStage
```

NewDuplexProviderStage creates a new duplex provider stage. The session is created lazily when the first element arrives, using system\_prompt from element metadata. This allows the pipeline to be the single source of truth for prompt assembly.

<a name="DuplexProviderStage.Process"></a>
### func \(\*DuplexProviderStage\) Process

```go
func (s *DuplexProviderStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Handles bidirectional streaming between input channel and WebSocket session.

For duplex streaming \(Gemini Live API\), this runs until: \- Context is canceled \(user stops the session\) \- Session response channel is closed \(server ends session\) \- Input channel is closed \(upstream ends\)

If no session is pre\-configured, the session is created lazily when the first element arrives. The system\_prompt from element metadata is used as the SystemInstruction for session creation.

<a name="EndInputter"></a>
## type EndInputter

EndInputter is an optional interface for sessions that support explicit end\-of\-input signaling. This is primarily used by mock sessions to trigger responses after all audio has been sent.

```go
type EndInputter interface {
    EndInput()
}
```

<a name="ExecutionResult"></a>
## type ExecutionResult

ExecutionResult represents the final result of a pipeline execution. This matches the existing pipeline.ExecutionResult for compatibility.

```go
type ExecutionResult struct {
    Messages []types.Message        // All messages in the conversation
    Response *Response              // The final response
    Trace    ExecutionTrace         // Execution trace
    CostInfo types.CostInfo         // Cost information
    Metadata map[string]interface{} // Additional metadata
}
```

<a name="ExecutionTrace"></a>
## type ExecutionTrace

ExecutionTrace captures execution history \(for compatibility\).

```go
type ExecutionTrace struct {
    StartedAt   time.Time
    CompletedAt *time.Time
    Duration    time.Duration
}
```

<a name="FilterStage"></a>
## type FilterStage

FilterStage filters elements based on a predicate function.

```go
type FilterStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewFilterStage"></a>
### func NewFilterStage

```go
func NewFilterStage(name string, predicate func(StreamElement) bool) *FilterStage
```

NewFilterStage creates a new filter stage.

<a name="FilterStage.Process"></a>
### func \(\*FilterStage\) Process

```go
func (fs *FilterStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process filters elements based on the predicate.

<a name="FormatCapable"></a>
## type FormatCapable

FormatCapable is an optional interface that stages can implement to declare their input/output format requirements. Stages that don't implement this are treated as accepting/producing any format.

```go
type FormatCapable interface {
    // InputCapabilities returns what formats/content types this stage accepts.
    InputCapabilities() Capabilities
    // OutputCapabilities returns what formats/content types this stage produces.
    OutputCapabilities() Capabilities
}
```

<a name="HashRouter"></a>
## type HashRouter

HashRouter routes elements based on consistent hashing of a key. This ensures elements with the same key always go to the same destination.

```go
type HashRouter struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewHashRouter"></a>
### func NewHashRouter

```go
func NewHashRouter(name string, outputNames []string, keyFunc func(StreamElement) string) *HashRouter
```

NewHashRouter creates a router that uses consistent hashing. The keyFunc extracts a key from each element \(e.g., session ID\). Elements with the same key always route to the same destination.

<a name="HashRouter.Process"></a>
### func \(\*HashRouter\) Process

```go
func (r *HashRouter) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process routes elements based on hash of key.

<a name="HashRouter.RegisterOutput"></a>
### func \(\*HashRouter\) RegisterOutput

```go
func (r *HashRouter) RegisterOutput(name string, output chan<- StreamElement)
```

RegisterOutput registers an output channel with a name.

<a name="ImageData"></a>
## type ImageData

ImageData carries image data with metadata.

```go
type ImageData struct {
    Data     []byte // Raw image data (encoded as JPEG, PNG, etc.)
    MIMEType string // MIME type (e.g., "image/jpeg", "image/png")
    Width    int    // Image width in pixels
    Height   int    // Image height in pixels
    Format   string // Format identifier (e.g., "jpeg", "png", "webp")
}
```

<a name="MapStage"></a>
## type MapStage

MapStage transforms elements using a mapping function.

```go
type MapStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

ExampleMapStage demonstrates using a map stage to transform elements.

```go
package main

import (
	"context"
	"fmt"

	"github.com/AltairaLabs/PromptKit/runtime/pipeline/stage"
	"github.com/AltairaLabs/PromptKit/runtime/types"
)

func main() {
	// Create a map stage that uppercases text
	uppercaseStage := stage.NewMapStage("uppercase", func(elem stage.StreamElement) (stage.StreamElement, error) {
		if elem.Message != nil {
			msg := *elem.Message
			msg.Content = "TRANSFORMED: " + msg.Content
			elem.Message = &msg
		}
		return elem, nil
	})

	// Build pipeline
	pipeline, _ := stage.NewPipelineBuilder().
		Chain(uppercaseStage).
		Build()

	// Execute
	input := make(chan stage.StreamElement, 1)
	input <- stage.NewMessageElement(&types.Message{
		Role:    "user",
		Content: "hello",
	})
	close(input)

	output, _ := pipeline.Execute(context.Background(), input)
	for elem := range output {
		if elem.Message != nil {
			fmt.Printf("%s\n", elem.Message.Content)
		}
	}
}
```

#### Output

```
TRANSFORMED: hello
```

</p>
</details>

<a name="NewMapStage"></a>
### func NewMapStage

```go
func NewMapStage(name string, mapFunc func(StreamElement) (StreamElement, error)) *MapStage
```

NewMapStage creates a new map stage.

<a name="MapStage.Process"></a>
### func \(\*MapStage\) Process

```go
func (ms *MapStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process transforms each element using the map function.

<a name="MediaExternalizerConfig"></a>
## type MediaExternalizerConfig

MediaExternalizerConfig configures media externalization behavior.

```go
type MediaExternalizerConfig struct {
    Enabled         bool
    StorageService  storage.MediaStorageService
    SizeThresholdKB int64
    DefaultPolicy   string
    RunID           string
    SessionID       string
    ConversationID  string
}
```

<a name="MediaExternalizerStage"></a>
## type MediaExternalizerStage

MediaExternalizerStage externalizes large media content to external storage.

When messages contain large inline media \(images, audio, video\), this stage moves the data to external storage and replaces it with a storage reference. This reduces memory usage and allows for media lifecycle management.

Behavior:

- Skipped if Enabled=false or no StorageService configured
- Only externalizes media exceeding SizeThresholdKB \(base64 size\)
- Preserves media.StorageReference if already externalized
- Clears media.Data after successful externalization

Configuration:

- Enabled: master switch for externalization
- SizeThresholdKB: minimum size to externalize \(0 = externalize all\)
- StorageService: where to store media \(S3, GCS, local filesystem, etc.\)
- DefaultPolicy: retention policy name for stored media

This is a Transform stage: 1 input element  1 output element \(with externalized media\)

```go
type MediaExternalizerStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewMediaExternalizerStage"></a>
### func NewMediaExternalizerStage

```go
func NewMediaExternalizerStage(config *MediaExternalizerConfig) *MediaExternalizerStage
```

NewMediaExternalizerStage creates a media externalizer stage.

<a name="MediaExternalizerStage.Process"></a>
### func \(\*MediaExternalizerStage\) Process

```go
func (s *MediaExternalizerStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process externalizes media from messages if they exceed size threshold.

<a name="MergeStage"></a>
## type MergeStage

MergeStage merges multiple input channels into a single output channel. This enables fan\-in patterns where multiple stages feed into one.

This is an Accumulate stage type that handles multiple inputs \(N:1 merge\).

```go
type MergeStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewMergeStage"></a>
### func NewMergeStage

```go
func NewMergeStage(name string, inputCount int) *MergeStage
```

NewMergeStage creates a new merge stage that merges N inputs into 1 output.

<a name="MergeStage.Process"></a>
### func \(\*MergeStage\) Process

```go
func (s *MergeStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface \(single input\). For merge stage, this is not typically used \- use ProcessMultiple instead.

<a name="MergeStage.ProcessMultiple"></a>
### func \(\*MergeStage\) ProcessMultiple

```go
func (s *MergeStage) ProcessMultiple(ctx context.Context, inputs []<-chan StreamElement, output chan<- StreamElement) error
```

ProcessMultiple processes multiple input channels and merges them into one output. This is a special method for merge stages that differs from the standard Process signature.

<a name="MetricsStage"></a>
## type MetricsStage

MetricsStage wraps another stage and collects metrics about its performance. This is a transparent wrapper that doesn't modify element flow.

```go
type MetricsStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewMetricsStage"></a>
### func NewMetricsStage

```go
func NewMetricsStage(wrappedStage Stage) *MetricsStage
```

NewMetricsStage wraps a stage with metrics collection.

<a name="MetricsStage.GetMetrics"></a>
### func \(\*MetricsStage\) GetMetrics

```go
func (s *MetricsStage) GetMetrics() StageMetrics
```

GetMetrics returns the collected metrics.

<a name="MetricsStage.Process"></a>
### func \(\*MetricsStage\) Process

```go
func (s *MetricsStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface with metrics collection.

<a name="PassthroughStage"></a>
## type PassthroughStage

PassthroughStage is a simple stage that passes all elements through unchanged. Useful for testing or as a placeholder.

```go
type PassthroughStage struct {
    BaseStage
}
```

<a name="NewPassthroughStage"></a>
### func NewPassthroughStage

```go
func NewPassthroughStage(name string) *PassthroughStage
```

NewPassthroughStage creates a new passthrough stage.

<a name="PassthroughStage.Process"></a>
### func \(\*PassthroughStage\) Process

```go
func (ps *PassthroughStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process passes all elements through unchanged.

<a name="PipelineBuilder"></a>
## type PipelineBuilder

PipelineBuilder constructs a pipeline DAG. It provides methods for creating linear chains and branching topologies.

```go
type PipelineBuilder struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

ExamplePipelineBuilder demonstrates building a simple linear pipeline.

```go
package main

import (
	"context"
	"fmt"

	"github.com/AltairaLabs/PromptKit/runtime/pipeline/stage"
	"github.com/AltairaLabs/PromptKit/runtime/types"
)

func main() {
	// Create some simple stages
	inputStage := stage.NewPassthroughStage("input")
	processStage := stage.NewPassthroughStage("process")
	outputStage := stage.NewPassthroughStage("output")

	// Build a linear pipeline
	pipeline, err := stage.NewPipelineBuilder().
		Chain(inputStage, processStage, outputStage).
		Build()

	if err != nil {
		fmt.Printf("Error building pipeline: %v\n", err)
		return
	}

	// Create input channel with a message
	input := make(chan stage.StreamElement, 1)
	input <- stage.NewMessageElement(&types.Message{
		Role:    "user",
		Content: "Hello, world!",
	})
	close(input)

	// Execute pipeline
	ctx := context.Background()
	output, err := pipeline.Execute(ctx, input)
	if err != nil {
		fmt.Printf("Error executing pipeline: %v\n", err)
		return
	}

	// Consume output
	for elem := range output {
		if elem.Message != nil {
			fmt.Printf("Received message: %s\n", elem.Message.Content)
		}
	}
}
```

#### Output

```
Received message: Hello, world!
```

</p>
</details>

<details><summary>Example (With Config)</summary>
<p>

ExamplePipelineBuilder\_withConfig demonstrates building a pipeline with custom configuration.

```go
package main

import (
	"fmt"

	"github.com/AltairaLabs/PromptKit/runtime/pipeline/stage"
)

func main() {
	// Create custom config
	config := stage.DefaultPipelineConfig().
		WithChannelBufferSize(32).
		WithPriorityQueue(true).
		WithMetrics(true)

	// Build pipeline with config
	pipeline, err := stage.NewPipelineBuilderWithConfig(config).
		Chain(
			stage.NewPassthroughStage("stage1"),
			stage.NewPassthroughStage("stage2"),
		).
		Build()

	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Pipeline created with %d stages\n", 2)
	_ = pipeline
}
```

#### Output

```
Pipeline created with 2 stages
```

</p>
</details>

<a name="NewPipelineBuilder"></a>
### func NewPipelineBuilder

```go
func NewPipelineBuilder() *PipelineBuilder
```

NewPipelineBuilder creates a new PipelineBuilder with default configuration.

<a name="NewPipelineBuilderWithConfig"></a>
### func NewPipelineBuilderWithConfig

```go
func NewPipelineBuilderWithConfig(config *PipelineConfig) *PipelineBuilder
```

NewPipelineBuilderWithConfig creates a new PipelineBuilder with custom configuration.

<a name="PipelineBuilder.AddStage"></a>
### func \(\*PipelineBuilder\) AddStage

```go
func (b *PipelineBuilder) AddStage(stage Stage) *PipelineBuilder
```

AddStage adds a stage to the builder without connecting it. This is useful when building complex topologies manually.

<a name="PipelineBuilder.Branch"></a>
### func \(\*PipelineBuilder\) Branch

```go
func (b *PipelineBuilder) Branch(fromStage string, toStages ...string) *PipelineBuilder
```

Branch creates multiple outgoing connections from a single stage. This allows one stage's output to fan out to multiple downstream stages.

Example:

```
pipeline := NewPipelineBuilder().
    Chain(NewStageA(), NewStageB()).
    Branch("stageB", "stageC", "stageD").  // B's output goes to both C and D
    Build()
```

<a name="PipelineBuilder.Build"></a>
### func \(\*PipelineBuilder\) Build

```go
func (b *PipelineBuilder) Build() (*StreamPipeline, error)
```

Build constructs the pipeline from the builder's configuration. It validates the pipeline structure and returns an error if invalid.

<a name="PipelineBuilder.Chain"></a>
### func \(\*PipelineBuilder\) Chain

```go
func (b *PipelineBuilder) Chain(stages ...Stage) *PipelineBuilder
```

Chain creates a linear chain of stages. This is the most common pattern: stage1 \-\> stage2 \-\> stage3. Each stage's output is connected to the next stage's input.

Example:

```
pipeline := NewPipelineBuilder().
    Chain(
        NewStageA(),
        NewStageB(),
        NewStageC(),
    ).
    Build()
```

<a name="PipelineBuilder.Clone"></a>
### func \(\*PipelineBuilder\) Clone

```go
func (b *PipelineBuilder) Clone() *PipelineBuilder
```

Clone creates a deep copy of the builder.

<a name="PipelineBuilder.Connect"></a>
### func \(\*PipelineBuilder\) Connect

```go
func (b *PipelineBuilder) Connect(fromStage, toStage string) *PipelineBuilder
```

Connect creates a directed edge from one stage to another. The output of fromStage will be connected to the input of toStage.

<a name="PipelineBuilder.WithConfig"></a>
### func \(\*PipelineBuilder\) WithConfig

```go
func (b *PipelineBuilder) WithConfig(config *PipelineConfig) *PipelineBuilder
```

WithConfig sets the pipeline configuration.

<a name="PipelineBuilder.WithEventEmitter"></a>
### func \(\*PipelineBuilder\) WithEventEmitter

```go
func (b *PipelineBuilder) WithEventEmitter(emitter *events.Emitter) *PipelineBuilder
```

WithEventEmitter sets the event emitter for the pipeline.

<a name="PipelineConfig"></a>
## type PipelineConfig

PipelineConfig defines configuration options for pipeline execution.

```go
type PipelineConfig struct {
    // ChannelBufferSize controls buffering between stages.
    // Smaller values = lower latency but more backpressure.
    // Larger values = higher throughput but more memory usage.
    // Default: 16
    ChannelBufferSize int

    // PriorityQueueEnabled enables priority-based scheduling.
    // When enabled, high-priority elements (audio) are processed before low-priority (logs).
    // Default: false
    PriorityQueueEnabled bool

    // MaxConcurrentPipelines limits the number of concurrent pipeline executions.
    // This is used by PipelinePool to control concurrency.
    // Default: 100
    MaxConcurrentPipelines int

    // ExecutionTimeout sets the maximum duration for a single pipeline execution.
    // Set to 0 to disable timeout.
    // Default: 30 seconds
    ExecutionTimeout time.Duration

    // GracefulShutdownTimeout sets the maximum time to wait for in-flight executions during shutdown.
    // Default: 10 seconds
    GracefulShutdownTimeout time.Duration

    // EnableMetrics enables collection of per-stage metrics (latency, throughput, etc.).
    // Default: false
    EnableMetrics bool

    // EnableTracing enables detailed tracing of element flow through stages.
    // Default: false (can be expensive for high-throughput pipelines)
    EnableTracing bool
}
```

<a name="DefaultPipelineConfig"></a>
### func DefaultPipelineConfig

```go
func DefaultPipelineConfig() *PipelineConfig
```

DefaultPipelineConfig returns a PipelineConfig with sensible defaults.

<a name="PipelineConfig.Validate"></a>
### func \(\*PipelineConfig\) Validate

```go
func (c *PipelineConfig) Validate() error
```

Validate checks if the configuration is valid.

<a name="PipelineConfig.WithChannelBufferSize"></a>
### func \(\*PipelineConfig\) WithChannelBufferSize

```go
func (c *PipelineConfig) WithChannelBufferSize(size int) *PipelineConfig
```

WithChannelBufferSize sets the channel buffer size.

<a name="PipelineConfig.WithExecutionTimeout"></a>
### func \(\*PipelineConfig\) WithExecutionTimeout

```go
func (c *PipelineConfig) WithExecutionTimeout(timeout time.Duration) *PipelineConfig
```

WithExecutionTimeout sets the execution timeout.

<a name="PipelineConfig.WithGracefulShutdownTimeout"></a>
### func \(\*PipelineConfig\) WithGracefulShutdownTimeout

```go
func (c *PipelineConfig) WithGracefulShutdownTimeout(timeout time.Duration) *PipelineConfig
```

WithGracefulShutdownTimeout sets the graceful shutdown timeout.

<a name="PipelineConfig.WithMaxConcurrentPipelines"></a>
### func \(\*PipelineConfig\) WithMaxConcurrentPipelines

```go
func (c *PipelineConfig) WithMaxConcurrentPipelines(maxPipelines int) *PipelineConfig
```

WithMaxConcurrentPipelines sets the maximum number of concurrent pipeline executions.

<a name="PipelineConfig.WithMetrics"></a>
### func \(\*PipelineConfig\) WithMetrics

```go
func (c *PipelineConfig) WithMetrics(enabled bool) *PipelineConfig
```

WithMetrics enables or disables metrics collection.

<a name="PipelineConfig.WithPriorityQueue"></a>
### func \(\*PipelineConfig\) WithPriorityQueue

```go
func (c *PipelineConfig) WithPriorityQueue(enabled bool) *PipelineConfig
```

WithPriorityQueue enables or disables priority\-based scheduling.

<a name="PipelineConfig.WithTracing"></a>
### func \(\*PipelineConfig\) WithTracing

```go
func (c *PipelineConfig) WithTracing(enabled bool) *PipelineConfig
```

WithTracing enables or disables detailed tracing.

<a name="Priority"></a>
## type Priority

Priority defines the scheduling priority for stream elements. Higher priority elements are processed before lower priority ones.

```go
type Priority int
```

<a name="PriorityLow"></a>

```go
const (
    // PriorityLow is for non-critical data like logs or metrics
    PriorityLow Priority = iota
    // PriorityNormal is the default priority for most elements
    PriorityNormal
    // PriorityHigh is for real-time audio/video that requires low latency
    PriorityHigh
    // PriorityCritical is for control signals, errors, and system messages
    PriorityCritical
)
```

<a name="PriorityChannel"></a>
## type PriorityChannel

PriorityChannel is a channel that supports priority\-based element delivery. Higher priority elements are delivered before lower priority elements.

```go
type PriorityChannel struct {
    // contains filtered or unexported fields
}
```

<a name="NewPriorityChannel"></a>
### func NewPriorityChannel

```go
func NewPriorityChannel(capacity int) *PriorityChannel
```

NewPriorityChannel creates a new priority channel with the given capacity.

<a name="PriorityChannel.Close"></a>
### func \(\*PriorityChannel\) Close

```go
func (pc *PriorityChannel) Close()
```

Close closes the priority channel.

<a name="PriorityChannel.Len"></a>
### func \(\*PriorityChannel\) Len

```go
func (pc *PriorityChannel) Len() int
```

Len returns the current number of elements in the channel.

<a name="PriorityChannel.Receive"></a>
### func \(\*PriorityChannel\) Receive

```go
func (pc *PriorityChannel) Receive(ctx context.Context) (StreamElement, bool, error)
```

Receive receives the highest priority element from the channel. Blocks if the channel is empty.

<a name="PriorityChannel.Send"></a>
### func \(\*PriorityChannel\) Send

```go
func (pc *PriorityChannel) Send(ctx context.Context, elem StreamElement) error
```

Send sends an element to the priority channel. Blocks if the channel is at capacity.

<a name="PromptAssemblyStage"></a>
## type PromptAssemblyStage

PromptAssemblyStage loads and assembles prompts from the prompt registry. It enriches elements with system prompt, allowed tools, and variables.

```go
type PromptAssemblyStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewPromptAssemblyStage"></a>
### func NewPromptAssemblyStage

```go
func NewPromptAssemblyStage(promptRegistry *prompt.Registry, taskType string, baseVariables map[string]string) *PromptAssemblyStage
```

NewPromptAssemblyStage creates a new prompt assembly stage.

<a name="PromptAssemblyStage.Process"></a>
### func \(\*PromptAssemblyStage\) Process

```go
func (s *PromptAssemblyStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process loads and assembles the prompt, enriching elements with prompt data.

<a name="ProviderConfig"></a>
## type ProviderConfig

ProviderConfig contains configuration for the provider stage.

```go
type ProviderConfig struct {
    MaxTokens    int
    Temperature  float32
    Seed         *int
    DisableTrace bool
}
```

<a name="ProviderStage"></a>
## type ProviderStage

ProviderStage executes LLM calls and handles tool execution. This is the request/response mode implementation.

```go
type ProviderStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewProviderStage"></a>
### func NewProviderStage

```go
func NewProviderStage(provider providers.Provider, toolRegistry *tools.Registry, toolPolicy *pipeline.ToolPolicy, config *ProviderConfig) *ProviderStage
```

NewProviderStage creates a new provider stage for request/response mode.

<a name="ProviderStage.Process"></a>
### func \(\*ProviderStage\) Process

```go
func (s *ProviderStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process executes the LLM provider call and handles tool execution.

<a name="QuerySourceType"></a>
## type QuerySourceType

QuerySourceType defines how to construct the relevance query.

```go
type QuerySourceType string
```

<a name="QuerySourceLastUser"></a>

```go
const (
    // QuerySourceLastUser uses the last user message as the query
    QuerySourceLastUser QuerySourceType = "last_user"
    // QuerySourceLastN concatenates the last N messages as the query
    QuerySourceLastN QuerySourceType = "last_n"
    // QuerySourceCustom uses a custom query string
    QuerySourceCustom QuerySourceType = "custom"
)
```

<a name="RandomRouter"></a>
## type RandomRouter

RandomRouter distributes elements randomly across outputs.

```go
type RandomRouter struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewRandomRouter"></a>
### func NewRandomRouter

```go
func NewRandomRouter(name string, outputNames []string) *RandomRouter
```

NewRandomRouter creates a router that distributes elements randomly.

<a name="RandomRouter.Process"></a>
### func \(\*RandomRouter\) Process

```go
func (r *RandomRouter) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process distributes elements randomly.

<a name="RandomRouter.RegisterOutput"></a>
### func \(\*RandomRouter\) RegisterOutput

```go
func (r *RandomRouter) RegisterOutput(name string, output chan<- StreamElement)
```

RegisterOutput registers an output channel with a name.

<a name="RelevanceConfig"></a>
## type RelevanceConfig

RelevanceConfig configures embedding\-based relevance truncation. Used when TruncationStrategy is TruncateLeastRelevant.

```go
type RelevanceConfig struct {
    // EmbeddingProvider generates embeddings for similarity scoring.
    // Required for relevance-based truncation; if nil, falls back to oldest.
    EmbeddingProvider providers.EmbeddingProvider

    // MinRecentMessages always keeps the N most recent messages
    // regardless of relevance score. Default: 3
    MinRecentMessages int

    // AlwaysKeepSystemRole keeps all system role messages regardless of score.
    AlwaysKeepSystemRole bool

    // SimilarityThreshold is the minimum score to consider a message relevant (0.0-1.0).
    // Messages below this threshold may be dropped first.
    SimilarityThreshold float64

    // QuerySource determines what text to compare messages against.
    // Default: QuerySourceLastUser
    QuerySource QuerySourceType

    // LastNCount is the number of messages to use when QuerySource is QuerySourceLastN.
    // Default: 3
    LastNCount int

    // CustomQuery is the query text when QuerySource is QuerySourceCustom.
    CustomQuery string

    // CacheEmbeddings enables caching of embeddings across truncation calls.
    // Useful when context changes incrementally.
    CacheEmbeddings bool
}
```

<a name="Response"></a>
## type Response

Response represents a response message \(for compatibility with existing pipeline\).

```go
type Response struct {
    Role          string
    Content       string
    Parts         []types.ContentPart
    ToolCalls     []types.MessageToolCall
    FinalResponse string
}
```

<a name="ResponseVADConfig"></a>
## type ResponseVADConfig

ResponseVADConfig configures the ResponseVADStage.

```go
type ResponseVADConfig struct {
    // VAD is the voice activity detector.
    // If nil, a SimpleVAD with default params is created.
    VAD audio.VADAnalyzer

    // SilenceDuration is how long silence must persist after EndOfStream
    // to confirm turn completion.
    // Default: 500ms
    SilenceDuration time.Duration

    // MaxWaitDuration is the maximum time to wait for silence after EndOfStream.
    // If silence is not detected within this time, EndOfStream is emitted anyway.
    // Default: 3s
    MaxWaitDuration time.Duration

    // SampleRate is the expected audio sample rate.
    // Default: 24000 (Gemini output)
    SampleRate int
}
```

<a name="DefaultResponseVADConfig"></a>
### func DefaultResponseVADConfig

```go
func DefaultResponseVADConfig() ResponseVADConfig
```

DefaultResponseVADConfig returns sensible defaults for ResponseVADStage.

<a name="ResponseVADStage"></a>
## type ResponseVADStage

ResponseVADStage monitors response audio for silence and delays EndOfStream until actual silence is detected. This decouples turn completion from provider signaling \(e.g., Gemini's turnComplete\) which may arrive before all audio chunks have been received.

This stage: 1. Passes through all elements immediately \(audio, text, messages\) 2. When EndOfStream is received from upstream, starts monitoring for silence 3. Only emits EndOfStream downstream when VAD confirms sustained silence 4. Has a max wait timeout to prevent indefinite blocking

This is a Transform stage with buffering: it may hold EndOfStream temporarily.

```go
type ResponseVADStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewResponseVADStage"></a>
### func NewResponseVADStage

```go
func NewResponseVADStage(config ResponseVADConfig) (*ResponseVADStage, error)
```

NewResponseVADStage creates a new response VAD stage.

<a name="ResponseVADStage.Process"></a>
### func \(\*ResponseVADStage\) Process

```go
func (s *ResponseVADStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Monitors response audio for silence and delays EndOfStream until confirmed.

<a name="RoundRobinRouter"></a>
## type RoundRobinRouter

RoundRobinRouter distributes elements across outputs in sequence.

```go
type RoundRobinRouter struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewRoundRobinRouter"></a>
### func NewRoundRobinRouter

```go
func NewRoundRobinRouter(name string, outputNames []string) *RoundRobinRouter
```

NewRoundRobinRouter creates a router that cycles through outputs sequentially.

<a name="RoundRobinRouter.Process"></a>
### func \(\*RoundRobinRouter\) Process

```go
func (r *RoundRobinRouter) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process distributes elements in round\-robin fashion.

<a name="RoundRobinRouter.RegisterOutput"></a>
### func \(\*RoundRobinRouter\) RegisterOutput

```go
func (r *RoundRobinRouter) RegisterOutput(name string, output chan<- StreamElement)
```

RegisterOutput registers an output channel with a name.

<a name="RouterFunc"></a>
## type RouterFunc

RouterFunc determines which output channel\(s\) to route an element to. Returns a slice of output names. Empty slice means drop the element.

```go
type RouterFunc func(elem *StreamElement) []string
```

<a name="RouterStage"></a>
## type RouterStage

RouterStage routes elements to different output channels based on a routing function. This enables conditional branching and dynamic routing in the pipeline.

This is a special stage type that supports multiple outputs \(1:N routing\).

```go
type RouterStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewRouterStage"></a>
### func NewRouterStage

```go
func NewRouterStage(name string, routerFunc RouterFunc) *RouterStage
```

NewRouterStage creates a new router stage with the given routing function.

<a name="RouterStage.Process"></a>
### func \(\*RouterStage\) Process

```go
func (s *RouterStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Routes each element to appropriate output channel\(s\) based on routing function.

<a name="RouterStage.RegisterOutput"></a>
### func \(\*RouterStage\) RegisterOutput

```go
func (s *RouterStage) RegisterOutput(name string, output chan<- StreamElement)
```

RegisterOutput registers an output channel with a name. This must be called before Process\(\) to set up routing destinations.

<a name="RoutingRule"></a>
## type RoutingRule

RoutingRule defines a predicate\-based routing rule.

```go
type RoutingRule struct {
    // Name identifies this rule for logging/debugging.
    Name string
    // Predicate returns true if the element should be routed to this rule's output.
    Predicate func(StreamElement) bool
    // Output is the destination name for matching elements.
    Output string
}
```

<a name="RouteAudio"></a>
### func RouteAudio

```go
func RouteAudio(output string, format AudioFormat) RoutingRule
```

RouteAudio creates a routing rule for audio elements with specific format.

<a name="RouteContentType"></a>
### func RouteContentType

```go
func RouteContentType(output string, ct ContentType) RoutingRule
```

RouteContentType creates a routing rule for elements of a specific content type.

<a name="RouteWhen"></a>
### func RouteWhen

```go
func RouteWhen(output string, predicate func(StreamElement) bool) RoutingRule
```

RouteWhen creates a routing rule with the given predicate.

<a name="STTStage"></a>
## type STTStage

STTStage transcribes audio to text using a speech\-to\-text service.

This is a Transform stage: audio element  text element \(1:1\)

```go
type STTStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewSTTStage"></a>
### func NewSTTStage

```go
func NewSTTStage(service stt.Service, config STTStageConfig) *STTStage
```

NewSTTStage creates a new STT stage.

<a name="STTStage.Process"></a>
### func \(\*STTStage\) Process

```go
func (s *STTStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Transcribes audio elements to text.

<a name="STTStageConfig"></a>
## type STTStageConfig

STTStageConfig configures the STTStage.

```go
type STTStageConfig struct {
    // Language hint for transcription (e.g., "en")
    Language string

    // SkipEmpty skips transcription for empty audio
    SkipEmpty bool

    // MinAudioBytes is minimum audio size to transcribe
    MinAudioBytes int
}
```

<a name="DefaultSTTStageConfig"></a>
### func DefaultSTTStageConfig

```go
func DefaultSTTStageConfig() STTStageConfig
```

DefaultSTTStageConfig returns sensible defaults.

<a name="ScoredMessage"></a>
## type ScoredMessage

ScoredMessage pairs a message with its relevance score and metadata. Used during relevance\-based truncation to track which messages to keep.

```go
type ScoredMessage struct {
    // Index is the original position in the message slice
    Index int

    // Message is the actual message content
    Message types.Message

    // Score is the cosine similarity to the query (0.0 to 1.0)
    Score float64

    // IsProtected indicates if this message should always be kept
    // (e.g., recent messages or system messages)
    IsProtected bool

    // TokenCount is the estimated token count for this message
    TokenCount int
}
```

<a name="ScoredMessages"></a>
## type ScoredMessages

ScoredMessages is a sortable slice of ScoredMessage.

```go
type ScoredMessages []ScoredMessage
```

<a name="ScoredMessages.Len"></a>
### func \(ScoredMessages\) Len

```go
func (s ScoredMessages) Len() int
```



<a name="ScoredMessages.Less"></a>
### func \(ScoredMessages\) Less

```go
func (s ScoredMessages) Less(i, j int) bool
```



<a name="ScoredMessages.Swap"></a>
### func \(ScoredMessages\) Swap

```go
func (s ScoredMessages) Swap(i, j int)
```



<a name="Stage"></a>
## type Stage

Stage is a processing unit in the pipeline DAG. Unlike traditional middleware, stages explicitly declare their I/O characteristics and operate on channels of StreamElements, enabling true streaming execution.

Stages read from an input channel, process elements, and write to an output channel. The stage MUST close the output channel when done \(or when input closes\).

Example implementation:

```
type ExampleStage struct {
    name string
}

func (s *ExampleStage) Name() string {
    return s.name
}

func (s *ExampleStage) Type() StageType {
    return StageTypeTransform
}

func (s *ExampleStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error {
    defer close(output)

    for elem := range input {
        // Process element
        processedElem := s.transform(elem)

        // Write to output
        select {
        case output <- processedElem:
        case <-ctx.Done():
            return ctx.Err()
        }
    }

    return nil
}
```

```go
type Stage interface {
    // Name returns a unique identifier for this stage.
    // This is used for logging, tracing, and debugging.
    Name() string

    // Type returns the stage's processing model.
    // This helps the pipeline builder understand how the stage behaves.
    Type() StageType

    // Process is called once when the pipeline starts.
    // The stage reads from input, processes elements, and writes to output.
    // The stage MUST close output when done (or when input closes).
    // Returns an error if processing fails.
    Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
}
```

<a name="StageError"></a>
## type StageError

StageError wraps an error with stage information.

```go
type StageError struct {
    StageName string
    StageType StageType
    Err       error
}
```

<a name="NewStageError"></a>
### func NewStageError

```go
func NewStageError(stageName string, stageType StageType, err error) *StageError
```

NewStageError creates a new StageError.

<a name="StageError.Error"></a>
### func \(\*StageError\) Error

```go
func (e *StageError) Error() string
```

Error returns the error message.

<a name="StageError.Unwrap"></a>
### func \(\*StageError\) Unwrap

```go
func (e *StageError) Unwrap() error
```

Unwrap returns the underlying error.

<a name="StageFunc"></a>
## type StageFunc

StageFunc is a functional adapter that allows using a function as a Stage. This is useful for simple transformations without defining a new type.

```go
type StageFunc struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewStageFunc"></a>
### func NewStageFunc

```go
func NewStageFunc(name string, stageType StageType, fn func(context.Context, <-chan StreamElement, chan<- StreamElement) error) *StageFunc
```

NewStageFunc creates a new functional stage.

<a name="StageFunc.Process"></a>
### func \(\*StageFunc\) Process

```go
func (sf *StageFunc) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process executes the stage function.

<a name="StageMetrics"></a>
## type StageMetrics

StageMetrics contains performance metrics for a stage.

```go
type StageMetrics struct {
    StageName       string
    ElementsIn      int64
    ElementsOut     int64
    ElementsErrored int64
    TotalLatency    time.Duration
    MinLatency      time.Duration
    MaxLatency      time.Duration
    AvgLatency      time.Duration
    LastUpdated     time.Time
    // contains filtered or unexported fields
}
```

<a name="NewStageMetrics"></a>
### func NewStageMetrics

```go
func NewStageMetrics(stageName string) *StageMetrics
```

NewStageMetrics creates a new metrics collector for a stage.

<a name="StageMetrics.GetMetrics"></a>
### func \(\*StageMetrics\) GetMetrics

```go
func (m *StageMetrics) GetMetrics() StageMetrics
```

GetMetrics returns a copy of the current metrics \(thread\-safe\).

<a name="StageMetrics.RecordElement"></a>
### func \(\*StageMetrics\) RecordElement

```go
func (m *StageMetrics) RecordElement(latency time.Duration, hasError bool)
```

RecordElement records metrics for a processed element.

<a name="StageMetrics.Reset"></a>
### func \(\*StageMetrics\) Reset

```go
func (m *StageMetrics) Reset()
```

Reset resets all metrics to zero.

<a name="StageType"></a>
## type StageType

StageType defines the processing model of a stage.

```go
type StageType int
```

<a name="StageTypeTransform"></a>

```go
const (
    // StageTypeTransform performs 1:1 or 1:N element transformation.
    // Each input element produces one or more output elements.
    // Examples: validation, prompt assembly, text formatting.
    StageTypeTransform StageType = iota

    // StageTypeAccumulate performs N:1 accumulation.
    // Multiple input elements are collected and combined into one output element.
    // Examples: VAD buffering, message accumulation.
    StageTypeAccumulate

    // StageTypeGenerate performs 0:N generation.
    // Generates output elements without consuming input (or consumes once then generates many).
    // Examples: LLM streaming response, TTS generation.
    StageTypeGenerate

    // StageTypeSink is a terminal stage (N:0).
    // Consumes input elements but produces no output.
    // Examples: state store save, metrics collection, logging.
    StageTypeSink

    // StageTypeBidirectional supports full duplex communication.
    // Both reads from input and writes to output concurrently.
    // Examples: WebSocket session, duplex provider.
    StageTypeBidirectional
)
```

<a name="StageType.String"></a>
### func \(StageType\) String

```go
func (st StageType) String() string
```

String returns the string representation of the stage type.

<a name="StateStoreLoadStage"></a>
## type StateStoreLoadStage

StateStoreLoadStage loads conversation history from state store.

```go
type StateStoreLoadStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewStateStoreLoadStage"></a>
### func NewStateStoreLoadStage

```go
func NewStateStoreLoadStage(config *pipeline.StateStoreConfig) *StateStoreLoadStage
```

NewStateStoreLoadStage creates a new state store load stage.

<a name="StateStoreLoadStage.Process"></a>
### func \(\*StateStoreLoadStage\) Process

```go
func (s *StateStoreLoadStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process loads conversation history and emits it before current input.

<a name="StateStoreSaveStage"></a>
## type StateStoreSaveStage

StateStoreSaveStage saves conversation state to state store.

```go
type StateStoreSaveStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewStateStoreSaveStage"></a>
### func NewStateStoreSaveStage

```go
func NewStateStoreSaveStage(config *pipeline.StateStoreConfig) *StateStoreSaveStage
```

NewStateStoreSaveStage creates a new state store save stage.

<a name="StateStoreSaveStage.Process"></a>
### func \(\*StateStoreSaveStage\) Process

```go
func (s *StateStoreSaveStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process collects all messages and saves them to state store.

<a name="StreamElement"></a>
## type StreamElement

StreamElement is the unit of data flowing through the pipeline. It can carry different types of content and supports backpressure. Each element should contain at most one content type.

```go
type StreamElement struct {
    // Content types (at most one should be set per element)
    Text      *string                // Text content
    Audio     *AudioData             // Audio samples
    Video     *VideoData             // Video frame
    Image     *ImageData             // Image data
    Message   *types.Message         // Complete message
    ToolCall  *types.MessageToolCall // Tool invocation
    Part      *types.ContentPart     // Generic content part (text, image, audio, video)
    MediaData *types.MediaContent    // Media content with MIME type

    // Metadata
    Sequence  int64                  // Monotonic sequence number
    Timestamp time.Time              // When element was created
    Source    string                 // Stage that produced this element
    Priority  Priority               // Scheduling priority (for QoS)
    Metadata  map[string]interface{} // Additional metadata for passing data between stages

    // Control signals
    EndOfStream bool  // No more elements after this
    Error       error // Error propagation
}
```

<details><summary>Example</summary>
<p>

ExampleStreamElement demonstrates creating different types of stream elements.

```go
package main

import (
	"fmt"

	"github.com/AltairaLabs/PromptKit/runtime/pipeline/stage"
	"github.com/AltairaLabs/PromptKit/runtime/types"
)

func main() {
	// Text element
	textElem := stage.NewTextElement("Hello")
	fmt.Printf("Text element: %v\n", *textElem.Text)

	// Message element
	msgElem := stage.NewMessageElement(&types.Message{
		Role:    "user",
		Content: "Hello",
	})
	fmt.Printf("Message element: %s\n", msgElem.Message.Content)

	// Error element
	errElem := stage.NewErrorElement(fmt.Errorf("test error"))
	fmt.Printf("Error element: %v\n", errElem.Error)

}
```

#### Output

```
Text element: Hello
Message element: Hello
Error element: test error
```

</p>
</details>

<a name="GetAudioElement"></a>
### func GetAudioElement

```go
func GetAudioElement(audio *AudioData) *StreamElement
```

GetAudioElement retrieves a StreamElement from the pool and initializes it with audio data. This is a pooled alternative to NewAudioElement.

<a name="GetElement"></a>
### func GetElement

```go
func GetElement() *StreamElement
```

GetElement retrieves a StreamElement from the pool or creates a new one. The returned element is reset to its zero state with an initialized Metadata map. Callers should use PutElement when the element is no longer needed.

<a name="GetEndOfStreamElement"></a>
### func GetEndOfStreamElement

```go
func GetEndOfStreamElement() *StreamElement
```

GetEndOfStreamElement retrieves a StreamElement from the pool and marks it as end\-of\-stream. This is a pooled alternative to NewEndOfStreamElement.

<a name="GetErrorElement"></a>
### func GetErrorElement

```go
func GetErrorElement(err error) *StreamElement
```

GetErrorElement retrieves a StreamElement from the pool and initializes it with an error. This is a pooled alternative to NewErrorElement.

<a name="GetImageElement"></a>
### func GetImageElement

```go
func GetImageElement(image *ImageData) *StreamElement
```

GetImageElement retrieves a StreamElement from the pool and initializes it with image data. This is a pooled alternative to NewImageElement.

<a name="GetMessageElement"></a>
### func GetMessageElement

```go
func GetMessageElement(msg *types.Message) *StreamElement
```

GetMessageElement retrieves a StreamElement from the pool and initializes it with a message. This is a pooled alternative to NewMessageElement.

<a name="GetTextElement"></a>
### func GetTextElement

```go
func GetTextElement(text string) *StreamElement
```

GetTextElement retrieves a StreamElement from the pool and initializes it with text content. This is a pooled alternative to NewTextElement.

<a name="GetVideoElement"></a>
### func GetVideoElement

```go
func GetVideoElement(video *VideoData) *StreamElement
```

GetVideoElement retrieves a StreamElement from the pool and initializes it with video data. This is a pooled alternative to NewVideoElement.

<a name="NewAudioElement"></a>
### func NewAudioElement

```go
func NewAudioElement(audio *AudioData) StreamElement
```

NewAudioElement creates a new StreamElement with audio data.

<a name="NewEndOfStreamElement"></a>
### func NewEndOfStreamElement

```go
func NewEndOfStreamElement() StreamElement
```

NewEndOfStreamElement creates a new StreamElement marking end of stream.

<a name="NewErrorElement"></a>
### func NewErrorElement

```go
func NewErrorElement(err error) StreamElement
```

NewErrorElement creates a new StreamElement with an error.

<a name="NewImageElement"></a>
### func NewImageElement

```go
func NewImageElement(image *ImageData) StreamElement
```

NewImageElement creates a new StreamElement with image data.

<a name="NewMessageElement"></a>
### func NewMessageElement

```go
func NewMessageElement(msg *types.Message) StreamElement
```

NewMessageElement creates a new StreamElement with a message.

<a name="NewTextElement"></a>
### func NewTextElement

```go
func NewTextElement(text string) StreamElement
```

NewTextElement creates a new StreamElement with text content.

<a name="NewVideoElement"></a>
### func NewVideoElement

```go
func NewVideoElement(video *VideoData) StreamElement
```

NewVideoElement creates a new StreamElement with video data.

<a name="StreamElement.GetMetadata"></a>
### func \(\*StreamElement\) GetMetadata

```go
func (e *StreamElement) GetMetadata(key string) interface{}
```

GetMetadata retrieves metadata by key, returning nil if not found.

<a name="StreamElement.HasContent"></a>
### func \(\*StreamElement\) HasContent

```go
func (e *StreamElement) HasContent() bool
```

HasContent returns true if the element contains any content \(excluding control signals\).

<a name="StreamElement.IsControl"></a>
### func \(\*StreamElement\) IsControl

```go
func (e *StreamElement) IsControl() bool
```

IsControl returns true if the element is a control signal \(error or end\-of\-stream\).

<a name="StreamElement.IsEmpty"></a>
### func \(\*StreamElement\) IsEmpty

```go
func (e *StreamElement) IsEmpty() bool
```

IsEmpty returns true if the element contains no content.

<a name="StreamElement.Reset"></a>
### func \(\*StreamElement\) Reset

```go
func (e *StreamElement) Reset()
```

Reset clears all fields of the StreamElement to their zero values. This is called automatically by PutElement before returning to the pool. The Metadata map is cleared but retained to avoid reallocation.

<a name="StreamElement.WithMetadata"></a>
### func \(\*StreamElement\) WithMetadata

```go
func (e *StreamElement) WithMetadata(key string, value interface{}) *StreamElement
```

WithMetadata adds metadata to this element.

<a name="StreamElement.WithPriority"></a>
### func \(\*StreamElement\) WithPriority

```go
func (e *StreamElement) WithPriority(priority Priority) *StreamElement
```

WithPriority sets the priority for this element.

<a name="StreamElement.WithSequence"></a>
### func \(\*StreamElement\) WithSequence

```go
func (e *StreamElement) WithSequence(seq int64) *StreamElement
```

WithSequence sets the sequence number for this element.

<a name="StreamElement.WithSource"></a>
### func \(\*StreamElement\) WithSource

```go
func (e *StreamElement) WithSource(source string) *StreamElement
```

WithSource sets the source stage name for this element.

<a name="StreamPipeline"></a>
## type StreamPipeline

StreamPipeline represents an executable pipeline of stages. It manages the DAG of stages, creates channels between them, and orchestrates execution.

```go
type StreamPipeline struct {
    // contains filtered or unexported fields
}
```

<a name="StreamPipeline.Execute"></a>
### func \(\*StreamPipeline\) Execute

```go
func (p *StreamPipeline) Execute(ctx context.Context, input <-chan StreamElement) (<-chan StreamElement, error)
```

Execute starts the pipeline execution with the given input channel. Returns an output channel that will receive all elements from terminal stages. The pipeline executes in background goroutines and closes the output channel when complete.

<a name="StreamPipeline.ExecuteSync"></a>
### func \(\*StreamPipeline\) ExecuteSync

```go
func (p *StreamPipeline) ExecuteSync(ctx context.Context, input ...StreamElement) (*ExecutionResult, error)
```

ExecuteSync runs the pipeline synchronously and returns the accumulated result. This is a convenience method for request/response mode where you want a single result. It converts the streaming execution into a blocking call.

<a name="StreamPipeline.Shutdown"></a>
### func \(\*StreamPipeline\) Shutdown

```go
func (p *StreamPipeline) Shutdown(ctx context.Context) error
```

Shutdown gracefully shuts down the pipeline, waiting for in\-flight executions to complete.

<a name="TTSConfig"></a>
## type TTSConfig

TTSConfig contains configuration for TTS stage.

```go
type TTSConfig struct {
    // SkipEmpty skips synthesis for empty or whitespace-only text
    SkipEmpty bool

    // MinTextLength is the minimum text length to synthesize (0 = no minimum)
    MinTextLength int
}
```

<a name="DefaultTTSConfig"></a>
### func DefaultTTSConfig

```go
func DefaultTTSConfig() TTSConfig
```

DefaultTTSConfig returns sensible defaults for TTS configuration.

<a name="TTSService"></a>
## type TTSService

TTSService converts text to audio.

```go
type TTSService interface {
    // Synthesize converts text to audio bytes.
    Synthesize(ctx context.Context, text string) ([]byte, error)

    // MIMEType returns the MIME type of the synthesized audio.
    MIMEType() string
}
```

<a name="TTSStage"></a>
## type TTSStage

TTSStage synthesizes audio for streaming text elements. It reads text elements from input and adds audio data to them.

This is a Transform stage: text element  text\+audio element \(1:1\)

```go
type TTSStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewTTSStage"></a>
### func NewTTSStage

```go
func NewTTSStage(tts TTSService, config TTSConfig) *TTSStage
```

NewTTSStage creates a new TTS stage.

<a name="TTSStage.Process"></a>
### func \(\*TTSStage\) Process

```go
func (s *TTSStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Synthesizes audio for each text element and adds it to the element.

<a name="TTSStageWithInterruption"></a>
## type TTSStageWithInterruption

TTSStageWithInterruption synthesizes text to audio with interruption support. When the user starts speaking \(detected via shared InterruptionHandler\), synthesis is stopped and pending output is discarded.

This is a Transform stage: text element  audio element \(1:1\)

```go
type TTSStageWithInterruption struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewTTSStageWithInterruption"></a>
### func NewTTSStageWithInterruption

```go
func NewTTSStageWithInterruption(service tts.Service, config TTSStageWithInterruptionConfig) *TTSStageWithInterruption
```

NewTTSStageWithInterruption creates a new TTS stage with interruption support.

<a name="TTSStageWithInterruption.Process"></a>
### func \(\*TTSStageWithInterruption\) Process

```go
func (s *TTSStageWithInterruption) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Synthesizes audio for text elements with interruption support.

<a name="TTSStageWithInterruptionConfig"></a>
## type TTSStageWithInterruptionConfig

TTSStageWithInterruptionConfig configures TTSStageWithInterruption.

```go
type TTSStageWithInterruptionConfig struct {
    // Voice is the voice ID to use
    Voice string

    // Speed is the speech rate (0.5-2.0)
    Speed float64

    // InterruptionHandler for detecting user interrupts during TTS output.
    // Should be shared with AudioTurnStage.
    InterruptionHandler *audio.InterruptionHandler

    // SkipEmpty skips synthesis for empty text
    SkipEmpty bool

    // MinTextLength is minimum text length to synthesize
    MinTextLength int
}
```

<a name="DefaultTTSStageWithInterruptionConfig"></a>
### func DefaultTTSStageWithInterruptionConfig

```go
func DefaultTTSStageWithInterruptionConfig() TTSStageWithInterruptionConfig
```

DefaultTTSStageWithInterruptionConfig returns sensible defaults.

<a name="TemplateStage"></a>
## type TemplateStage

TemplateStage substitutes \{\{variable\}\} placeholders in messages and metadata.

This stage reads variables from the element's metadata\["variables"\] map and replaces all occurrences of \{\{variable\_name\}\} in:

- metadata\["system\_prompt"\] \- the system prompt for the LLM
- message.Content \- the message text content
- message.Parts\[\].Text \- individual content parts

Variables are typically set by:

- PromptAssemblyStage \(from base\_variables in config\)
- VariableProviderStage \(from dynamic variable providers\)

Example:

```
Input: "Hello {{name}}, the topic is {{topic}}"
Variables: {"name": "Alice", "topic": "AI"}
Output: "Hello Alice, the topic is AI"
```

This is a Transform stage: 1 input element  1 output element

```go
type TemplateStage struct {
    BaseStage
}
```

<a name="NewTemplateStage"></a>
### func NewTemplateStage

```go
func NewTemplateStage() *TemplateStage
```

NewTemplateStage creates a template substitution stage.

<a name="TemplateStage.Process"></a>
### func \(\*TemplateStage\) Process

```go
func (s *TemplateStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process substitutes variables in messages and system prompt metadata.

<a name="TracingStage"></a>
## type TracingStage

TracingStage wraps another stage and adds element\-level tracing. Each element gets a trace ID and timing information.

```go
type TracingStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewTracingStage"></a>
### func NewTracingStage

```go
func NewTracingStage(wrappedStage Stage, traceIDGen func() string) *TracingStage
```

NewTracingStage wraps a stage with tracing support.

<a name="TracingStage.Process"></a>
### func \(\*TracingStage\) Process

```go
func (s *TracingStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface with tracing.

<a name="Transcriber"></a>
## type Transcriber

Transcriber converts audio bytes to text. Follows Go naming convention for single\-method interfaces.

```go
type Transcriber interface {
    Transcribe(ctx context.Context, audio []byte) (string, error)
}
```

<a name="TruncationStrategy"></a>
## type TruncationStrategy

TruncationStrategy defines how to handle messages when over token budget.

```go
type TruncationStrategy string
```

<a name="TruncateOldest"></a>

```go
const (
    // TruncateOldest drops oldest messages first
    TruncateOldest TruncationStrategy = "oldest"
    // TruncateLeastRelevant drops least relevant messages (requires embeddings)
    TruncateLeastRelevant TruncationStrategy = "relevance"
    // TruncateSummarize compresses old messages into summaries
    TruncateSummarize TruncationStrategy = "summarize"
    // TruncateFail returns error if over budget
    TruncateFail TruncationStrategy = "fail"
)
```

<a name="VADAccumulatorStage"></a>
## type VADAccumulatorStage

VADAccumulatorStage reads streaming audio chunks, detects turn boundaries via VAD, and emits a single Message element with the transcribed text.

This is an Accumulate stage: N audio chunks  1 message element

```go
type VADAccumulatorStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewVADAccumulatorStage"></a>
### func NewVADAccumulatorStage

```go
func NewVADAccumulatorStage(analyzer audio.VADAnalyzer, transcriber Transcriber, config VADConfig) *VADAccumulatorStage
```

NewVADAccumulatorStage creates a new VAD accumulator stage.

<a name="VADAccumulatorStage.Process"></a>
### func \(\*VADAccumulatorStage\) Process

```go
func (s *VADAccumulatorStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process implements the Stage interface. Accumulates audio chunks until turn complete, then transcribes and emits a message.

<a name="VADConfig"></a>
## type VADConfig

VADConfig contains configuration for VAD accumulator stage.

```go
type VADConfig struct {
    // Threshold for silence detection (0.0 = silence, 1.0 = speech)
    Threshold float64

    // MinSpeechDuration is the minimum duration of speech before turn can complete
    MinSpeechDuration time.Duration

    // MaxTurnDuration is the maximum duration before forcing turn completion
    MaxTurnDuration time.Duration

    // SilenceDuration is how long silence must persist to trigger turn complete
    SilenceDuration time.Duration
}
```

<a name="DefaultVADConfig"></a>
### func DefaultVADConfig

```go
func DefaultVADConfig() VADConfig
```

DefaultVADConfig returns sensible defaults for VAD configuration.

<a name="ValidationStage"></a>
## type ValidationStage

ValidationStage validates responses using configured validators.

```go
type ValidationStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewValidationStage"></a>
### func NewValidationStage

```go
func NewValidationStage(registry *validators.Registry, suppressExceptions bool) *ValidationStage
```

NewValidationStage creates a new validation stage.

<a name="ValidationStage.Process"></a>
### func \(\*ValidationStage\) Process

```go
func (s *ValidationStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process validates response elements and attaches results to metadata.

<a name="VariableProviderStage"></a>
## type VariableProviderStage

VariableProviderStage resolves variables from dynamic providers and adds them to metadata.

This stage calls each registered variable provider to fetch dynamic variables \(e.g., from environment, external services, databases\) and merges them into the element's metadata\["variables"\] map for use by TemplateStage.

Provider resolution order:

1. Variables from earlier stages \(e.g., PromptAssemblyStage base\_variables\)
2. Each provider is called in sequence; later providers can override earlier values

Error handling:

- If any provider fails, the stage returns an error and aborts the pipeline
- This ensures variable resolution failures are surfaced early

Example providers:

- Environment variable provider: reads from OS environment
- Config provider: reads from configuration files
- External API provider: fetches user context from external services

This is a Transform stage: 1 input element  1 output element \(with enriched metadata\)

```go
type VariableProviderStage struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewVariableProviderStage"></a>
### func NewVariableProviderStage

```go
func NewVariableProviderStage(providers ...variables.Provider) *VariableProviderStage
```

NewVariableProviderStage creates a variable provider stage.

<a name="VariableProviderStage.Process"></a>
### func \(\*VariableProviderStage\) Process

```go
func (s *VariableProviderStage) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process resolves variables from all providers and merges them into element metadata.

<a name="VideoData"></a>
## type VideoData

VideoData carries video frame data with metadata.

```go
type VideoData struct {
    Data       []byte        // Raw video frame data or encoded video segment
    MIMEType   string        // MIME type (e.g., "video/mp4", "video/webm")
    Width      int           // Frame width in pixels
    Height     int           // Frame height in pixels
    FrameRate  float64       // Frames per second
    Duration   time.Duration // Duration of the video segment
    Timestamp  time.Time     // Timestamp of this frame
    Format     string        // Format identifier (e.g., "h264", "vp8")
    IsKeyFrame bool          // True if this is a key frame
}
```

<a name="WeightedRouter"></a>
## type WeightedRouter

WeightedRouter distributes elements across outputs based on configured weights.

```go
type WeightedRouter struct {
    BaseStage
    // contains filtered or unexported fields
}
```

<a name="NewWeightedRouter"></a>
### func NewWeightedRouter

```go
func NewWeightedRouter(name string, weights map[string]float64) *WeightedRouter
```

NewWeightedRouter creates a router that distributes elements based on weights. Weights are normalized to sum to 1.0. Example: \{"primary": 0.7, "secondary": 0.3\} routes 70% to primary, 30% to secondary.

<a name="WeightedRouter.Process"></a>
### func \(\*WeightedRouter\) Process

```go
func (r *WeightedRouter) Process(ctx context.Context, input <-chan StreamElement, output chan<- StreamElement) error
```

Process distributes elements based on weights.

<a name="WeightedRouter.RegisterOutput"></a>
### func \(\*WeightedRouter\) RegisterOutput

```go
func (r *WeightedRouter) RegisterOutput(name string, output chan<- StreamElement)
```

RegisterOutput registers an output channel with a name.

# schema

```go
import "github.com/AltairaLabs/PromptKit/runtime/prompt/schema"
```

Package schema provides embedded PromptPack schema for offline validation.

## Index

- [Constants](<#constants>)
- [func ExtractSchemaURL\(packJSON \[\]byte\) string](<#ExtractSchemaURL>)
- [func GetEmbeddedSchema\(\) string](<#GetEmbeddedSchema>)
- [func GetEmbeddedSchemaVersion\(\) \(string, error\)](<#GetEmbeddedSchemaVersion>)
- [func GetSchemaLoader\(packSchemaURL string\) \(gojsonschema.JSONLoader, error\)](<#GetSchemaLoader>)


## Constants

<a name="DefaultSchemaURL"></a>DefaultSchemaURL is the canonical URL for the PromptPack schema.

```go
const DefaultSchemaURL = "https://promptpack.org/schema/latest/promptpack.schema.json"
```

<a name="SchemaSourceEnvVar"></a>SchemaSourceEnvVar is the environment variable to override schema source. Values: "local" \(embedded\), "remote" \(fetch from URL\), or a file path.

```go
const SchemaSourceEnvVar = "PROMPTKIT_SCHEMA_SOURCE"
```

<a name="ExtractSchemaURL"></a>
## func ExtractSchemaURL

```go
func ExtractSchemaURL(packJSON []byte) string
```

ExtractSchemaURL extracts the $schema URL from pack JSON data. Returns empty string if not present or invalid.

<a name="GetEmbeddedSchema"></a>
## func GetEmbeddedSchema

```go
func GetEmbeddedSchema() string
```

GetEmbeddedSchema returns the embedded schema as a string.

<a name="GetEmbeddedSchemaVersion"></a>
## func GetEmbeddedSchemaVersion

```go
func GetEmbeddedSchemaVersion() (string, error)
```

GetEmbeddedSchemaVersion returns the version from the embedded schema.

<a name="GetSchemaLoader"></a>
## func GetSchemaLoader

```go
func GetSchemaLoader(packSchemaURL string) (gojsonschema.JSONLoader, error)
```

GetSchemaLoader returns a gojsonschema loader for the PromptPack schema. Priority:

1. If PROMPTKIT\_SCHEMA\_SOURCE is set to "local", use embedded schema
2. If PROMPTKIT\_SCHEMA\_SOURCE is a file path, load from that file
3. If PROMPTKIT\_SCHEMA\_SOURCE is "remote" and packSchemaURL is provided, fetch from that URL
4. Otherwise, use embedded schema \(default for offline support\)

# claude

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/claude"
```

Package claude provides Anthropic Claude LLM provider integration.

## Index

- [type Provider](<#Provider>)
  - [func NewProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*Provider](<#NewProvider>)
  - [func \(p \*Provider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#Provider.CalculateCost>)
  - [func \(p \*Provider\) GetMultimodalCapabilities\(\) providers.MultimodalCapabilities](<#Provider.GetMultimodalCapabilities>)
  - [func \(p \*Provider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#Provider.Predict>)
  - [func \(p \*Provider\) PredictMultimodal\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#Provider.PredictMultimodal>)
  - [func \(p \*Provider\) PredictMultimodalStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#Provider.PredictMultimodalStream>)
  - [func \(p \*Provider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#Provider.PredictStream>)
- [type ToolProvider](<#ToolProvider>)
  - [func NewToolProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*ToolProvider](<#NewToolProvider>)
  - [func \(p \*ToolProvider\) BuildTooling\(descriptors \[\]\*providers.ToolDescriptor\) \(interface\{\}, error\)](<#ToolProvider.BuildTooling>)
  - [func \(p \*ToolProvider\) PredictStreamWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(\<\-chan providers.StreamChunk, error\)](<#ToolProvider.PredictStreamWithTools>)
  - [func \(p \*ToolProvider\) PredictWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#ToolProvider.PredictWithTools>)


<a name="Provider"></a>
## type Provider

Provider implements the Provider interface for Anthropic Claude

```go
type Provider struct {
    providers.BaseProvider
    // contains filtered or unexported fields
}
```

<a name="NewProvider"></a>
### func NewProvider

```go
func NewProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *Provider
```

NewProvider creates a new Claude provider

<a name="Provider.CalculateCost"></a>
### func \(\*Provider\) CalculateCost

```go
func (p *Provider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="Provider.GetMultimodalCapabilities"></a>
### func \(\*Provider\) GetMultimodalCapabilities

```go
func (p *Provider) GetMultimodalCapabilities() providers.MultimodalCapabilities
```

GetMultimodalCapabilities returns Claude's multimodal support capabilities

<a name="Provider.Predict"></a>
### func \(\*Provider\) Predict

```go
func (p *Provider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict sends a predict request to Claude

<a name="Provider.PredictMultimodal"></a>
### func \(\*Provider\) PredictMultimodal

```go
func (p *Provider) PredictMultimodal(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

PredictMultimodal sends a multimodal predict request to Claude

<a name="Provider.PredictMultimodalStream"></a>
### func \(\*Provider\) PredictMultimodalStream

```go
func (p *Provider) PredictMultimodalStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictMultimodalStream sends a streaming multimodal predict request to Claude

<a name="Provider.PredictStream"></a>
### func \(\*Provider\) PredictStream

```go
func (p *Provider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream streams a predict response from Claude

<a name="ToolProvider"></a>
## type ToolProvider

ToolProvider extends ClaudeProvider with tool support

```go
type ToolProvider struct {
    *Provider
}
```

<a name="NewToolProvider"></a>
### func NewToolProvider

```go
func NewToolProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *ToolProvider
```

NewToolProvider creates a new Claude provider with tool support

<a name="ToolProvider.BuildTooling"></a>
### func \(\*ToolProvider\) BuildTooling

```go
func (p *ToolProvider) BuildTooling(descriptors []*providers.ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to Claude format

<a name="ToolProvider.PredictStreamWithTools"></a>
### func \(\*ToolProvider\) PredictStreamWithTools

```go
func (p *ToolProvider) PredictStreamWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (<-chan providers.StreamChunk, error)
```

PredictStreamWithTools performs a streaming predict request with tool support

<a name="ToolProvider.PredictWithTools"></a>
### func \(\*ToolProvider\) PredictWithTools

```go
func (p *ToolProvider) PredictWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictWithTools performs a predict request with tool support

# gemini

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/gemini"
```

Package gemini provides Gemini Live API streaming support.

IMPORTANT: Response Modality Limitation

The Gemini Live API does NOT support requesting both TEXT and AUDIO response modalities simultaneously. Attempting to set ResponseModalities to \["TEXT", "AUDIO"\] will result in a WebSocket error:

```
websocket: close 1007 (invalid payload data): Request contains an invalid argument.
```

Valid configurations:

- \["TEXT"\] \- Text responses only \(default\)
- \["AUDIO"\] \- Audio responses only

If you need both text and audio, you must choose one primary modality. For audio responses with transcription, the API may provide output transcription separately via the OutputTranscription field.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func ClassifyError\(apiErr \*APIError\) error](<#ClassifyError>)
- [type APIError](<#APIError>)
  - [func \(e \*APIError\) Error\(\) string](<#APIError.Error>)
  - [func \(e \*APIError\) IsAuthError\(\) bool](<#APIError.IsAuthError>)
  - [func \(e \*APIError\) IsPolicyViolation\(\) bool](<#APIError.IsPolicyViolation>)
  - [func \(e \*APIError\) IsRetryable\(\) bool](<#APIError.IsRetryable>)
- [type AudioEncoder](<#AudioEncoder>)
  - [func NewAudioEncoder\(\) \*AudioEncoder](<#NewAudioEncoder>)
  - [func NewAudioEncoderWithChunkSize\(chunkSize int\) \(\*AudioEncoder, error\)](<#NewAudioEncoderWithChunkSize>)
  - [func \(e \*AudioEncoder\) AssembleChunks\(chunks \[\]\*types.MediaChunk\) \(\[\]byte, error\)](<#AudioEncoder.AssembleChunks>)
  - [func \(e \*AudioEncoder\) ConvertInt16ToPCM\(samples \[\]int16\) \[\]byte](<#AudioEncoder.ConvertInt16ToPCM>)
  - [func \(e \*AudioEncoder\) ConvertPCMToInt16\(pcmData \[\]byte\) \(\[\]int16, error\)](<#AudioEncoder.ConvertPCMToInt16>)
  - [func \(e \*AudioEncoder\) CreateChunks\(ctx context.Context, pcmData \[\]byte\) \(\[\]\*types.MediaChunk, error\)](<#AudioEncoder.CreateChunks>)
  - [func \(e \*AudioEncoder\) DecodePCM\(base64Data string\) \(\[\]byte, error\)](<#AudioEncoder.DecodePCM>)
  - [func \(e \*AudioEncoder\) EncodePCM\(pcmData \[\]byte\) \(string, error\)](<#AudioEncoder.EncodePCM>)
  - [func \(e \*AudioEncoder\) GenerateSineWave\(frequency float64, durationMs int, amplitude float64\) \[\]byte](<#AudioEncoder.GenerateSineWave>)
  - [func \(e \*AudioEncoder\) GetChunkDurationMs\(chunkSize int\) float64](<#AudioEncoder.GetChunkDurationMs>)
  - [func \(e \*AudioEncoder\) GetChunkSize\(\) int](<#AudioEncoder.GetChunkSize>)
  - [func \(e \*AudioEncoder\) GetSampleRate\(\) int](<#AudioEncoder.GetSampleRate>)
  - [func \(e \*AudioEncoder\) ReadChunks\(ctx context.Context, reader io.Reader\) \(chunkStream \<\-chan \*types.MediaChunk, errStream \<\-chan error\)](<#AudioEncoder.ReadChunks>)
  - [func \(e \*AudioEncoder\) ValidateConfig\(config \*types.StreamingMediaConfig\) error](<#AudioEncoder.ValidateConfig>)
- [type EmbeddingOption](<#EmbeddingOption>)
  - [func WithGeminiEmbeddingAPIKey\(key string\) EmbeddingOption](<#WithGeminiEmbeddingAPIKey>)
  - [func WithGeminiEmbeddingBaseURL\(url string\) EmbeddingOption](<#WithGeminiEmbeddingBaseURL>)
  - [func WithGeminiEmbeddingHTTPClient\(client \*http.Client\) EmbeddingOption](<#WithGeminiEmbeddingHTTPClient>)
  - [func WithGeminiEmbeddingModel\(model string\) EmbeddingOption](<#WithGeminiEmbeddingModel>)
- [type EmbeddingProvider](<#EmbeddingProvider>)
  - [func NewEmbeddingProvider\(opts ...EmbeddingOption\) \(\*EmbeddingProvider, error\)](<#NewEmbeddingProvider>)
  - [func \(p \*EmbeddingProvider\) Embed\(ctx context.Context, req providers.EmbeddingRequest\) \(providers.EmbeddingResponse, error\)](<#EmbeddingProvider.Embed>)
  - [func \(p \*EmbeddingProvider\) EstimateCost\(tokens int\) float64](<#EmbeddingProvider.EstimateCost>)
- [type ErrorResponse](<#ErrorResponse>)
- [type FunctionCall](<#FunctionCall>)
- [type InlineData](<#InlineData>)
- [type ModelTurn](<#ModelTurn>)
- [type Part](<#Part>)
- [type PromptFeedback](<#PromptFeedback>)
  - [func \(f \*PromptFeedback\) GetBlockReason\(\) string](<#PromptFeedback.GetBlockReason>)
  - [func \(f \*PromptFeedback\) IsBlocked\(\) bool](<#PromptFeedback.IsBlocked>)
- [type Provider](<#Provider>)
  - [func NewProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*Provider](<#NewProvider>)
  - [func \(p \*Provider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#Provider.CalculateCost>)
  - [func \(p \*Provider\) CreateStreamSession\(ctx context.Context, req \*providers.StreamingInputConfig\) \(providers.StreamInputSession, error\)](<#Provider.CreateStreamSession>)
  - [func \(p \*Provider\) GetMultimodalCapabilities\(\) providers.MultimodalCapabilities](<#Provider.GetMultimodalCapabilities>)
  - [func \(p \*Provider\) GetStreamingCapabilities\(\) providers.StreamingCapabilities](<#Provider.GetStreamingCapabilities>)
  - [func \(p \*Provider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#Provider.Predict>)
  - [func \(p \*Provider\) PredictMultimodal\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#Provider.PredictMultimodal>)
  - [func \(p \*Provider\) PredictMultimodalStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#Provider.PredictMultimodalStream>)
  - [func \(p \*Provider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#Provider.PredictStream>)
  - [func \(p \*Provider\) SupportsStreamInput\(\) \[\]string](<#Provider.SupportsStreamInput>)
- [type RecoveryStrategy](<#RecoveryStrategy>)
  - [func DetermineRecoveryStrategy\(err error\) RecoveryStrategy](<#DetermineRecoveryStrategy>)
- [type SafetyRating](<#SafetyRating>)
- [type ServerContent](<#ServerContent>)
- [type ServerMessage](<#ServerMessage>)
  - [func \(s \*ServerMessage\) UnmarshalJSON\(data \[\]byte\) error](<#ServerMessage.UnmarshalJSON>)
- [type SetupComplete](<#SetupComplete>)
- [type StreamSession](<#StreamSession>)
  - [func NewStreamSession\(ctx context.Context, wsURL, apiKey string, config \*StreamSessionConfig\) \(\*StreamSession, error\)](<#NewStreamSession>)
  - [func \(s \*StreamSession\) Close\(\) error](<#StreamSession.Close>)
  - [func \(s \*StreamSession\) CompleteTurn\(ctx context.Context\) error](<#StreamSession.CompleteTurn>)
  - [func \(s \*StreamSession\) Done\(\) \<\-chan struct\{\}](<#StreamSession.Done>)
  - [func \(s \*StreamSession\) EndInput\(\)](<#StreamSession.EndInput>)
  - [func \(s \*StreamSession\) Error\(\) error](<#StreamSession.Error>)
  - [func \(s \*StreamSession\) Response\(\) \<\-chan providers.StreamChunk](<#StreamSession.Response>)
  - [func \(s \*StreamSession\) SendChunk\(ctx context.Context, chunk \*types.MediaChunk\) error](<#StreamSession.SendChunk>)
  - [func \(s \*StreamSession\) SendSystemContext\(ctx context.Context, text string\) error](<#StreamSession.SendSystemContext>)
  - [func \(s \*StreamSession\) SendText\(ctx context.Context, text string\) error](<#StreamSession.SendText>)
  - [func \(s \*StreamSession\) SendToolResponse\(ctx context.Context, toolCallID, result string\) error](<#StreamSession.SendToolResponse>)
  - [func \(s \*StreamSession\) SendToolResponses\(ctx context.Context, responses \[\]providers.ToolResponse\) error](<#StreamSession.SendToolResponses>)
- [type StreamSessionConfig](<#StreamSessionConfig>)
- [type ToolCallMsg](<#ToolCallMsg>)
- [type ToolDefinition](<#ToolDefinition>)
- [type ToolProvider](<#ToolProvider>)
  - [func NewToolProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*ToolProvider](<#NewToolProvider>)
  - [func \(p \*ToolProvider\) BuildTooling\(descriptors \[\]\*providers.ToolDescriptor\) \(interface\{\}, error\)](<#ToolProvider.BuildTooling>)
  - [func \(p \*ToolProvider\) CreateStreamSession\(ctx context.Context, req \*providers.StreamingInputConfig\) \(providers.StreamInputSession, error\)](<#ToolProvider.CreateStreamSession>)
  - [func \(p \*ToolProvider\) GetStreamingCapabilities\(\) providers.StreamingCapabilities](<#ToolProvider.GetStreamingCapabilities>)
  - [func \(p \*ToolProvider\) PredictStreamWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(\<\-chan providers.StreamChunk, error\)](<#ToolProvider.PredictStreamWithTools>)
  - [func \(p \*ToolProvider\) PredictWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#ToolProvider.PredictWithTools>)
  - [func \(p \*ToolProvider\) SupportsStreamInput\(\) \[\]string](<#ToolProvider.SupportsStreamInput>)
- [type Transcription](<#Transcription>)
- [type UsageMetadata](<#UsageMetadata>)
- [type VADConfig](<#VADConfig>)
- [type WebSocketManager](<#WebSocketManager>)
  - [func NewWebSocketManager\(url, apiKey string\) \*WebSocketManager](<#NewWebSocketManager>)
  - [func \(wm \*WebSocketManager\) Close\(\) error](<#WebSocketManager.Close>)
  - [func \(wm \*WebSocketManager\) Connect\(ctx context.Context\) error](<#WebSocketManager.Connect>)
  - [func \(wm \*WebSocketManager\) ConnectWithRetry\(ctx context.Context\) error](<#WebSocketManager.ConnectWithRetry>)
  - [func \(wm \*WebSocketManager\) IsConnected\(\) bool](<#WebSocketManager.IsConnected>)
  - [func \(wm \*WebSocketManager\) Receive\(ctx context.Context, v interface\{\}\) error](<#WebSocketManager.Receive>)
  - [func \(wm \*WebSocketManager\) Send\(msg interface\{\}\) error](<#WebSocketManager.Send>)
  - [func \(wm \*WebSocketManager\) SendPing\(\) error](<#WebSocketManager.SendPing>)
  - [func \(wm \*WebSocketManager\) StartHeartbeat\(ctx context.Context, interval time.Duration\)](<#WebSocketManager.StartHeartbeat>)


## Constants

<a name="DefaultChunkDuration"></a>

```go
const (

    // DefaultChunkDuration is 100ms of audio
    DefaultChunkDuration = 100 // milliseconds
    // DefaultChunkSize is the number of bytes for 100ms at 16kHz 16-bit mono
    // 16000 Hz * 0.1 sec * 2 bytes/sample = 3200 bytes
    DefaultChunkSize = (geminiSampleRate * DefaultChunkDuration / 1000) * bytesPerSample
)
```

<a name="DefaultGeminiEmbeddingModel"></a>Embedding model constants

```go
const (
    // DefaultGeminiEmbeddingModel is the default model for embeddings
    DefaultGeminiEmbeddingModel = "text-embedding-004"

    // EmbeddingModel004 is the current recommended model
    EmbeddingModel004 = "text-embedding-004"

    // EmbeddingModel001 is the legacy embedding model
    EmbeddingModel001 = "embedding-001"
)
```

<a name="ErrNotConnected"></a>Common error messages

```go
const (
    ErrNotConnected  = "not connected"
    ErrManagerClosed = "manager is closed"
)
```

<a name="ErrSessionClosed"></a>Common error messages

```go
const (
    ErrSessionClosed = "session is closed"
)
```

## Variables

<a name="ErrInvalidSampleRate"></a>

```go
var (
    // ErrInvalidSampleRate indicates an unsupported sample rate
    ErrInvalidSampleRate = errors.New("invalid sample rate: must be 16000 Hz")
    // ErrInvalidChannels indicates an unsupported channel count
    ErrInvalidChannels = errors.New("invalid channels: must be mono (1 channel)")
    // ErrInvalidBitDepth indicates an unsupported bit depth
    ErrInvalidBitDepth = errors.New("invalid bit depth: must be 16 bits")
    // ErrInvalidChunkSize indicates chunk size is not aligned
    ErrInvalidChunkSize = errors.New("invalid chunk size: must be multiple of sample size")
    // ErrEmptyAudioData indicates no audio data provided
    ErrEmptyAudioData = errors.New("empty audio data")
)
```

<a name="ErrInvalidAudioFormat"></a>Common errors for Gemini streaming

```go
var (
    // ErrInvalidAudioFormat indicates audio format doesn't meet Gemini requirements
    ErrInvalidAudioFormat = errors.New("invalid audio format")

    // ErrRateLimitExceeded indicates too many requests
    ErrRateLimitExceeded = errors.New("rate limit exceeded")

    // ErrAuthenticationFailed indicates invalid API key
    ErrAuthenticationFailed = errors.New("authentication failed")

    // ErrServiceUnavailable indicates temporary service issue
    ErrServiceUnavailable = errors.New("service unavailable")

    // ErrPolicyViolation indicates content policy violation
    ErrPolicyViolation = errors.New("policy violation")

    // ErrInvalidRequest indicates malformed request
    ErrInvalidRequest = errors.New("invalid request")
)
```

<a name="ClassifyError"></a>
## func ClassifyError

```go
func ClassifyError(apiErr *APIError) error
```

ClassifyError converts an API error code to a standard error

<a name="APIError"></a>
## type APIError

GeminiAPIError represents an error from the Gemini API

```go
type APIError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Status  string `json:"status"`
}
```

<a name="APIError.Error"></a>
### func \(\*APIError\) Error

```go
func (e *APIError) Error() string
```

Error implements the error interface

<a name="APIError.IsAuthError"></a>
### func \(\*APIError\) IsAuthError

```go
func (e *APIError) IsAuthError() bool
```

IsAuthError returns true if the error is authentication\-related

<a name="APIError.IsPolicyViolation"></a>
### func \(\*APIError\) IsPolicyViolation

```go
func (e *APIError) IsPolicyViolation() bool
```

IsPolicyViolation returns true if the error is a content policy violation

<a name="APIError.IsRetryable"></a>
### func \(\*APIError\) IsRetryable

```go
func (e *APIError) IsRetryable() bool
```

IsRetryable returns true if the error can be retried

<a name="AudioEncoder"></a>
## type AudioEncoder

AudioEncoder handles PCM Linear16 audio encoding for Gemini Live API

```go
type AudioEncoder struct {
    // contains filtered or unexported fields
}
```

<a name="NewAudioEncoder"></a>
### func NewAudioEncoder

```go
func NewAudioEncoder() *AudioEncoder
```

NewAudioEncoder creates a new audio encoder with Gemini Live API specifications

<a name="NewAudioEncoderWithChunkSize"></a>
### func NewAudioEncoderWithChunkSize

```go
func NewAudioEncoderWithChunkSize(chunkSize int) (*AudioEncoder, error)
```

NewAudioEncoderWithChunkSize creates an encoder with custom chunk size

<a name="AudioEncoder.AssembleChunks"></a>
### func \(\*AudioEncoder\) AssembleChunks

```go
func (e *AudioEncoder) AssembleChunks(chunks []*types.MediaChunk) ([]byte, error)
```

AssembleChunks reassembles MediaChunks back into continuous PCM data.

<a name="AudioEncoder.ConvertInt16ToPCM"></a>
### func \(\*AudioEncoder\) ConvertInt16ToPCM

```go
func (e *AudioEncoder) ConvertInt16ToPCM(samples []int16) []byte
```

ConvertInt16ToPCM converts \[\]int16 samples to PCM bytes \(little\-endian\)

<a name="AudioEncoder.ConvertPCMToInt16"></a>
### func \(\*AudioEncoder\) ConvertPCMToInt16

```go
func (e *AudioEncoder) ConvertPCMToInt16(pcmData []byte) ([]int16, error)
```

ConvertPCMToInt16 converts PCM bytes to \[\]int16 samples \(little\-endian\)

<a name="AudioEncoder.CreateChunks"></a>
### func \(\*AudioEncoder\) CreateChunks

```go
func (e *AudioEncoder) CreateChunks(ctx context.Context, pcmData []byte) ([]*types.MediaChunk, error)
```

CreateChunks splits PCM audio data into appropriately sized chunks

<a name="AudioEncoder.DecodePCM"></a>
### func \(\*AudioEncoder\) DecodePCM

```go
func (e *AudioEncoder) DecodePCM(base64Data string) ([]byte, error)
```

DecodePCM decodes base64\-encoded audio data back to raw PCM

<a name="AudioEncoder.EncodePCM"></a>
### func \(\*AudioEncoder\) EncodePCM

```go
func (e *AudioEncoder) EncodePCM(pcmData []byte) (string, error)
```

EncodePCM encodes raw PCM audio data to base64 for WebSocket transmission

<a name="AudioEncoder.GenerateSineWave"></a>
### func \(\*AudioEncoder\) GenerateSineWave

```go
func (e *AudioEncoder) GenerateSineWave(frequency float64, durationMs int, amplitude float64) []byte
```

GenerateSineWave generates PCM audio for a sine wave \(useful for testing\)

<a name="AudioEncoder.GetChunkDurationMs"></a>
### func \(\*AudioEncoder\) GetChunkDurationMs

```go
func (e *AudioEncoder) GetChunkDurationMs(chunkSize int) float64
```

GetChunkDurationMs calculates the duration of a chunk in milliseconds

<a name="AudioEncoder.GetChunkSize"></a>
### func \(\*AudioEncoder\) GetChunkSize

```go
func (e *AudioEncoder) GetChunkSize() int
```

GetChunkSize returns the configured chunk size in bytes

<a name="AudioEncoder.GetSampleRate"></a>
### func \(\*AudioEncoder\) GetSampleRate

```go
func (e *AudioEncoder) GetSampleRate() int
```

GetSampleRate returns the configured sample rate

<a name="AudioEncoder.ReadChunks"></a>
### func \(\*AudioEncoder\) ReadChunks

```go
func (e *AudioEncoder) ReadChunks(ctx context.Context, reader io.Reader) (chunkStream <-chan *types.MediaChunk, errStream <-chan error)
```

ReadChunks reads audio from an io.Reader and creates chunks on\-the\-fly

<a name="AudioEncoder.ValidateConfig"></a>
### func \(\*AudioEncoder\) ValidateConfig

```go
func (e *AudioEncoder) ValidateConfig(config *types.StreamingMediaConfig) error
```

ValidateConfig validates audio configuration against Gemini requirements

<a name="EmbeddingOption"></a>
## type EmbeddingOption

EmbeddingOption configures the EmbeddingProvider.

```go
type EmbeddingOption func(*EmbeddingProvider)
```

<a name="WithGeminiEmbeddingAPIKey"></a>
### func WithGeminiEmbeddingAPIKey

```go
func WithGeminiEmbeddingAPIKey(key string) EmbeddingOption
```

WithGeminiEmbeddingAPIKey sets the API key explicitly.

<a name="WithGeminiEmbeddingBaseURL"></a>
### func WithGeminiEmbeddingBaseURL

```go
func WithGeminiEmbeddingBaseURL(url string) EmbeddingOption
```

WithGeminiEmbeddingBaseURL sets a custom base URL.

<a name="WithGeminiEmbeddingHTTPClient"></a>
### func WithGeminiEmbeddingHTTPClient

```go
func WithGeminiEmbeddingHTTPClient(client *http.Client) EmbeddingOption
```

WithGeminiEmbeddingHTTPClient sets a custom HTTP client.

<a name="WithGeminiEmbeddingModel"></a>
### func WithGeminiEmbeddingModel

```go
func WithGeminiEmbeddingModel(model string) EmbeddingOption
```

WithGeminiEmbeddingModel sets the embedding model.

<a name="EmbeddingProvider"></a>
## type EmbeddingProvider

EmbeddingProvider implements embedding generation via Gemini API.

```go
type EmbeddingProvider struct {
    *providers.BaseEmbeddingProvider
}
```

<a name="NewEmbeddingProvider"></a>
### func NewEmbeddingProvider

```go
func NewEmbeddingProvider(opts ...EmbeddingOption) (*EmbeddingProvider, error)
```

NewEmbeddingProvider creates a Gemini embedding provider.

<a name="EmbeddingProvider.Embed"></a>
### func \(\*EmbeddingProvider\) Embed

```go
func (p *EmbeddingProvider) Embed(ctx context.Context, req providers.EmbeddingRequest) (providers.EmbeddingResponse, error)
```

Embed generates embeddings for the given texts.

<a name="EmbeddingProvider.EstimateCost"></a>
### func \(\*EmbeddingProvider\) EstimateCost

```go
func (p *EmbeddingProvider) EstimateCost(tokens int) float64
```

EstimateCost estimates the cost for embedding the given number of tokens. Note: Gemini embeddings are currently free tier.

<a name="ErrorResponse"></a>
## type ErrorResponse

ErrorResponse wraps a GeminiAPIError in a message format

```go
type ErrorResponse struct {
    Error *APIError `json:"error"`
}
```

<a name="FunctionCall"></a>
## type FunctionCall

FunctionCall represents a function call

```go
type FunctionCall struct {
    Name string                 `json:"name,omitempty"`
    ID   string                 `json:"id,omitempty"`
    Args map[string]interface{} `json:"args,omitempty"`
}
```

<a name="InlineData"></a>
## type InlineData

InlineData represents inline media data

```go
type InlineData struct {
    MimeType string `json:"mimeType,omitempty"` // camelCase!
    Data     string `json:"data,omitempty"`     // Base64 encoded
}
```

<a name="ModelTurn"></a>
## type ModelTurn

ModelTurn represents a model response turn

```go
type ModelTurn struct {
    Parts []Part `json:"parts,omitempty"`
}
```

<a name="Part"></a>
## type Part

Part represents a content part \(text or inline data\)

```go
type Part struct {
    Text       string      `json:"text,omitempty"`
    InlineData *InlineData `json:"inlineData,omitempty"` // camelCase!
}
```

<a name="PromptFeedback"></a>
## type PromptFeedback

PromptFeedback contains safety ratings and block reason

```go
type PromptFeedback struct {
    SafetyRatings []SafetyRating `json:"safetyRatings,omitempty"`
    BlockReason   string         `json:"blockReason,omitempty"`
}
```

<a name="PromptFeedback.GetBlockReason"></a>
### func \(\*PromptFeedback\) GetBlockReason

```go
func (f *PromptFeedback) GetBlockReason() string
```

GetBlockReason returns a human\-readable block reason

<a name="PromptFeedback.IsBlocked"></a>
### func \(\*PromptFeedback\) IsBlocked

```go
func (f *PromptFeedback) IsBlocked() bool
```

IsBlocked returns true if content was blocked by safety filters

<a name="Provider"></a>
## type Provider

Provider implements the Provider interface for Google Gemini

```go
type Provider struct {
    providers.BaseProvider
    Model    string
    BaseURL  string
    ApiKey   string
    Defaults providers.ProviderDefaults
}
```

<a name="NewProvider"></a>
### func NewProvider

```go
func NewProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *Provider
```

NewProvider creates a new Gemini provider

<a name="Provider.CalculateCost"></a>
### func \(\*Provider\) CalculateCost

```go
func (p *Provider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="Provider.CreateStreamSession"></a>
### func \(\*Provider\) CreateStreamSession

```go
func (p *Provider) CreateStreamSession(ctx context.Context, req *providers.StreamingInputConfig) (providers.StreamInputSession, error)
```

CreateStreamSession creates a new bidirectional streaming session with Gemini Live API

Response Modalities: By default, the session is configured to return TEXT responses only. To request audio responses, pass "response\_modalities" in the request metadata:

```
req := providers.StreamInputRequest{
    Config: config,
    Metadata: map[string]interface{}{
        "response_modalities": []string{"AUDIO"}, // Audio only (TEXT+AUDIO not supported)
    },
}
```

Audio responses will be delivered in the StreamChunk.Metadata\["audio\_data"\] field as base64\-encoded PCM.

<a name="Provider.GetMultimodalCapabilities"></a>
### func \(\*Provider\) GetMultimodalCapabilities

```go
func (p *Provider) GetMultimodalCapabilities() providers.MultimodalCapabilities
```

GetMultimodalCapabilities returns Gemini's multimodal support capabilities

<a name="Provider.GetStreamingCapabilities"></a>
### func \(\*Provider\) GetStreamingCapabilities

```go
func (p *Provider) GetStreamingCapabilities() providers.StreamingCapabilities
```

GetStreamingCapabilities returns detailed information about Gemini's streaming support

<a name="Provider.Predict"></a>
### func \(\*Provider\) Predict

```go
func (p *Provider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict sends a predict request to Gemini

<a name="Provider.PredictMultimodal"></a>
### func \(\*Provider\) PredictMultimodal

```go
func (p *Provider) PredictMultimodal(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

PredictMultimodal performs a predict request with multimodal content

<a name="Provider.PredictMultimodalStream"></a>
### func \(\*Provider\) PredictMultimodalStream

```go
func (p *Provider) PredictMultimodalStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictMultimodalStream performs a streaming predict request with multimodal content

<a name="Provider.PredictStream"></a>
### func \(\*Provider\) PredictStream

```go
func (p *Provider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream streams a predict response from Gemini

<a name="Provider.SupportsStreamInput"></a>
### func \(\*Provider\) SupportsStreamInput

```go
func (p *Provider) SupportsStreamInput() []string
```

SupportsStreamInput returns the media types supported for streaming input

<a name="RecoveryStrategy"></a>
## type RecoveryStrategy

RecoveryStrategy defines how to handle different error types

```go
type RecoveryStrategy int
```

<a name="RecoveryRetry"></a>

```go
const (
    // RecoveryRetry indicates the operation should be retried
    RecoveryRetry RecoveryStrategy = iota

    // RecoveryFailFast indicates the operation should fail immediately
    RecoveryFailFast

    // RecoveryGracefulDegradation indicates fallback to a simpler mode
    RecoveryGracefulDegradation

    // RecoveryWaitAndRetry indicates retry after a delay
    RecoveryWaitAndRetry
)
```

<a name="DetermineRecoveryStrategy"></a>
### func DetermineRecoveryStrategy

```go
func DetermineRecoveryStrategy(err error) RecoveryStrategy
```

DetermineRecoveryStrategy determines how to handle an error

<a name="SafetyRating"></a>
## type SafetyRating

SafetyRating represents content safety assessment

```go
type SafetyRating struct {
    Category    string `json:"category"`
    Probability string `json:"probability"`
}
```

<a name="ServerContent"></a>
## type ServerContent

ServerContent represents the server content \(BidiGenerateContentServerContent\)

```go
type ServerContent struct {
    ModelTurn           *ModelTurn     `json:"modelTurn,omitempty"`
    TurnComplete        bool           `json:"turnComplete,omitempty"`
    GenerationComplete  bool           `json:"generationComplete,omitempty"`
    Interrupted         bool           `json:"interrupted,omitempty"`
    InputTranscription  *Transcription `json:"inputTranscription,omitempty"`  // User speech transcription
    OutputTranscription *Transcription `json:"outputTranscription,omitempty"` // Model speech transcription
}
```

<a name="ServerMessage"></a>
## type ServerMessage

ServerMessage represents a message from the Gemini server \(BidiGenerateContentServerMessage\)

```go
type ServerMessage struct {
    SetupComplete *SetupComplete `json:"setupComplete,omitempty"`
    ServerContent *ServerContent `json:"serverContent,omitempty"`
    ToolCall      *ToolCallMsg   `json:"toolCall,omitempty"`
    UsageMetadata *UsageMetadata `json:"usageMetadata,omitempty"`
}
```

<a name="ServerMessage.UnmarshalJSON"></a>
### func \(\*ServerMessage\) UnmarshalJSON

```go
func (s *ServerMessage) UnmarshalJSON(data []byte) error
```

UnmarshalJSON unmarshals ServerMessage from JSON with custom handling.

<a name="SetupComplete"></a>
## type SetupComplete

SetupComplete indicates setup is complete \(empty object per docs\)

```go
type SetupComplete struct{}
```

<a name="StreamSession"></a>
## type StreamSession

StreamSession implements StreamInputSession for Gemini Live API with automatic reconnection on unexpected connection drops.

```go
type StreamSession struct {
    // contains filtered or unexported fields
}
```

<a name="NewStreamSession"></a>
### func NewStreamSession

```go
func NewStreamSession(ctx context.Context, wsURL, apiKey string, config *StreamSessionConfig) (*StreamSession, error)
```

NewStreamSession creates a new streaming session

<a name="StreamSession.Close"></a>
### func \(\*StreamSession\) Close

```go
func (s *StreamSession) Close() error
```

Close closes the session

<a name="StreamSession.CompleteTurn"></a>
### func \(\*StreamSession\) CompleteTurn

```go
func (s *StreamSession) CompleteTurn(ctx context.Context) error
```

CompleteTurn signals that the current turn is complete

<a name="StreamSession.Done"></a>
### func \(\*StreamSession\) Done

```go
func (s *StreamSession) Done() <-chan struct{}
```

Done returns a channel that's closed when the session ends

<a name="StreamSession.EndInput"></a>
### func \(\*StreamSession\) EndInput

```go
func (s *StreamSession) EndInput()
```

EndInput implements the EndInputter interface expected by DuplexProviderStage. It signals that the user's input turn is complete and the model should respond.

Behavior depends on VAD configuration: \- If VAD is disabled: sends activityEnd signal for explicit turn control \- If VAD is enabled: sends silence frames to trigger VAD end\-of\-speech detection

<a name="StreamSession.Error"></a>
### func \(\*StreamSession\) Error

```go
func (s *StreamSession) Error() error
```

Err returns the error that caused the session to close

<a name="StreamSession.Response"></a>
### func \(\*StreamSession\) Response

```go
func (s *StreamSession) Response() <-chan providers.StreamChunk
```

Response returns the channel for receiving responses

<a name="StreamSession.SendChunk"></a>
### func \(\*StreamSession\) SendChunk

```go
func (s *StreamSession) SendChunk(ctx context.Context, chunk *types.MediaChunk) error
```

SendChunk sends a media chunk to the server. When VAD is disabled \(manual turn control\), automatically sends activityStart before the first audio chunk of a turn.

<a name="StreamSession.SendSystemContext"></a>
### func \(\*StreamSession\) SendSystemContext

```go
func (s *StreamSession) SendSystemContext(ctx context.Context, text string) error
```

SendSystemContext sends a text message as context without completing the turn. Use this for system prompts that should provide context but not trigger a response. The audio/text that follows will be processed with this context in mind.

<a name="StreamSession.SendText"></a>
### func \(\*StreamSession\) SendText

```go
func (s *StreamSession) SendText(ctx context.Context, text string) error
```

SendText sends a text message to the server and marks the turn as complete

<a name="StreamSession.SendToolResponse"></a>
### func \(\*StreamSession\) SendToolResponse

```go
func (s *StreamSession) SendToolResponse(ctx context.Context, toolCallID, result string) error
```

SendToolResponse sends a single tool execution result back to Gemini. The toolCallID must match the ID from the FunctionCall. The result should be a JSON\-serializable string \(typically JSON\).

<a name="StreamSession.SendToolResponses"></a>
### func \(\*StreamSession\) SendToolResponses

```go
func (s *StreamSession) SendToolResponses(ctx context.Context, responses []providers.ToolResponse) error
```

SendToolResponses sends multiple tool execution results back to Gemini. This is used when the model makes parallel tool calls. After receiving the tool responses, Gemini will continue generating.

<a name="StreamSessionConfig"></a>
## type StreamSessionConfig

StreamSessionConfig configures a streaming session

```go
type StreamSessionConfig struct {
    Model              string   // Model name (will be prefixed with "models/" automatically)
    ResponseModalities []string // "TEXT" or "AUDIO" - NOT both! See package doc for details.
    SystemInstruction  string   // System prompt/instruction for the model
    InputCostPer1K     float64  // Cost per 1K input tokens (for USD calculation)
    OutputCostPer1K    float64  // Cost per 1K output tokens (for USD calculation)

    // VAD configures Voice Activity Detection settings.
    // If nil, Gemini uses its default VAD settings.
    VAD *VADConfig

    // Tools defines the function declarations available to the model.
    // When tools are configured, the model will return structured tool calls
    // instead of speaking them as text. Tool definitions should match the
    // OpenAPI schema subset supported by Gemini.
    Tools []ToolDefinition

    // AutoReconnect enables automatic reconnection on unexpected connection drops.
    // When enabled, the session will attempt to reconnect and continue receiving
    // responses. Note: conversation context may be lost on reconnection.
    AutoReconnect     bool
    MaxReconnectTries int // Maximum reconnection attempts (default: 3)
}
```

<a name="ToolCallMsg"></a>
## type ToolCallMsg

ToolCallMsg represents a tool call from the model

```go
type ToolCallMsg struct {
    FunctionCalls []FunctionCall `json:"functionCalls,omitempty"`
}
```

<a name="ToolDefinition"></a>
## type ToolDefinition

ToolDefinition represents a function/tool that the model can call. This follows the Gemini function calling schema.

```go
type ToolDefinition struct {
    Name        string                 `json:"name"`
    Description string                 `json:"description,omitempty"`
    Parameters  map[string]interface{} `json:"parameters,omitempty"` // JSON Schema for parameters
}
```

<a name="ToolProvider"></a>
## type ToolProvider

ToolProvider extends GeminiProvider with tool support

```go
type ToolProvider struct {
    *Provider
    // contains filtered or unexported fields
}
```

<a name="NewToolProvider"></a>
### func NewToolProvider

```go
func NewToolProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *ToolProvider
```

NewToolProvider creates a new Gemini provider with tool support

<a name="ToolProvider.BuildTooling"></a>
### func \(\*ToolProvider\) BuildTooling

```go
func (p *ToolProvider) BuildTooling(descriptors []*providers.ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to Gemini format

<a name="ToolProvider.CreateStreamSession"></a>
### func \(\*ToolProvider\) CreateStreamSession

```go
func (p *ToolProvider) CreateStreamSession(ctx context.Context, req *providers.StreamingInputConfig) (providers.StreamInputSession, error)
```

CreateStreamSession forwards to the embedded Provider's CreateStreamSession. This enables duplex streaming with tool support.

<a name="ToolProvider.GetStreamingCapabilities"></a>
### func \(\*ToolProvider\) GetStreamingCapabilities

```go
func (p *ToolProvider) GetStreamingCapabilities() providers.StreamingCapabilities
```

GetStreamingCapabilities forwards to the embedded Provider's GetStreamingCapabilities.

<a name="ToolProvider.PredictStreamWithTools"></a>
### func \(\*ToolProvider\) PredictStreamWithTools

```go
func (p *ToolProvider) PredictStreamWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (<-chan providers.StreamChunk, error)
```

PredictStreamWithTools performs a streaming predict request with tool support

<a name="ToolProvider.PredictWithTools"></a>
### func \(\*ToolProvider\) PredictWithTools

```go
func (p *ToolProvider) PredictWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictWithTools performs a predict request with tool support

<a name="ToolProvider.SupportsStreamInput"></a>
### func \(\*ToolProvider\) SupportsStreamInput

```go
func (p *ToolProvider) SupportsStreamInput() []string
```

SupportsStreamInput forwards to the embedded Provider's SupportsStreamInput.

<a name="Transcription"></a>
## type Transcription

Transcription represents audio transcription \(BidiGenerateContentTranscription\)

```go
type Transcription struct {
    Text string `json:"text,omitempty"`
}
```

<a name="UsageMetadata"></a>
## type UsageMetadata

UsageMetadata contains token usage information

```go
type UsageMetadata struct {
    PromptTokenCount   int `json:"promptTokenCount,omitempty"`
    ResponseTokenCount int `json:"responseTokenCount,omitempty"`
    TotalTokenCount    int `json:"totalTokenCount,omitempty"`
}
```

<a name="VADConfig"></a>
## type VADConfig

VADConfig configures Voice Activity Detection settings for Gemini Live API. These settings control when Gemini detects the end of speech and starts responding.

```go
type VADConfig struct {
    // Disabled turns off automatic VAD (manual turn control only)
    Disabled bool
    // StartOfSpeechSensitivity controls how sensitive the VAD is to detecting speech start.
    // Valid values: "UNSPECIFIED", "LOW", "MEDIUM", "HIGH"
    StartOfSpeechSensitivity string
    // EndOfSpeechSensitivity controls how sensitive the VAD is to detecting silence.
    // Valid values: "UNSPECIFIED", "LOW", "MEDIUM", "HIGH"
    // Lower sensitivity = longer silence needed to trigger end of speech
    EndOfSpeechSensitivity string
    // PrefixPaddingMs is extra padding in milliseconds before speech detection
    PrefixPaddingMs int
    // SilenceThresholdMs is the duration of silence (in ms) to trigger end of speech.
    // This maps to Gemini's "suffixPaddingMs" parameter.
    // Default is typically ~500ms. Increase for TTS audio with natural pauses.
    SilenceThresholdMs int
}
```

<a name="WebSocketManager"></a>
## type WebSocketManager

WebSocketManager manages a WebSocket connection with reconnection logic.

```go
type WebSocketManager struct {
    // contains filtered or unexported fields
}
```

<a name="NewWebSocketManager"></a>
### func NewWebSocketManager

```go
func NewWebSocketManager(url, apiKey string) *WebSocketManager
```

NewWebSocketManager creates a new WebSocket manager

<a name="WebSocketManager.Close"></a>
### func \(\*WebSocketManager\) Close

```go
func (wm *WebSocketManager) Close() error
```

Close gracefully closes the WebSocket connection

<a name="WebSocketManager.Connect"></a>
### func \(\*WebSocketManager\) Connect

```go
func (wm *WebSocketManager) Connect(ctx context.Context) error
```

Connect establishes a WebSocket connection to the Gemini Live API

<a name="WebSocketManager.ConnectWithRetry"></a>
### func \(\*WebSocketManager\) ConnectWithRetry

```go
func (wm *WebSocketManager) ConnectWithRetry(ctx context.Context) error
```

ConnectWithRetry connects with exponential backoff retry logic

<a name="WebSocketManager.IsConnected"></a>
### func \(\*WebSocketManager\) IsConnected

```go
func (wm *WebSocketManager) IsConnected() bool
```

IsConnected returns true if the WebSocket is connected

<a name="WebSocketManager.Receive"></a>
### func \(\*WebSocketManager\) Receive

```go
func (wm *WebSocketManager) Receive(ctx context.Context, v interface{}) error
```

Receive reads a message from the WebSocket

<a name="WebSocketManager.Send"></a>
### func \(\*WebSocketManager\) Send

```go
func (wm *WebSocketManager) Send(msg interface{}) error
```

Send sends a message through the WebSocket

<a name="WebSocketManager.SendPing"></a>
### func \(\*WebSocketManager\) SendPing

```go
func (wm *WebSocketManager) SendPing() error
```

SendPing sends a WebSocket ping to keep the connection alive

<a name="WebSocketManager.StartHeartbeat"></a>
### func \(\*WebSocketManager\) StartHeartbeat

```go
func (wm *WebSocketManager) StartHeartbeat(ctx context.Context, interval time.Duration)
```

StartHeartbeat starts a goroutine that sends periodic pings

# imagen

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/imagen"
```

Package imagen provides Google Imagen image generation provider integration.

## Index

- [type Config](<#Config>)
- [type Provider](<#Provider>)
  - [func NewProvider\(config Config\) \*Provider](<#NewProvider>)
  - [func \(p \*Provider\) CalculateCost\(inputTokens, outputTokens, cachedTokens int\) types.CostInfo](<#Provider.CalculateCost>)
  - [func \(p \*Provider\) Close\(\) error](<#Provider.Close>)
  - [func \(p \*Provider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#Provider.Predict>)
  - [func \(p \*Provider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#Provider.PredictStream>)
  - [func \(p \*Provider\) SupportsStreaming\(\) bool](<#Provider.SupportsStreaming>)


<a name="Config"></a>
## type Config

ImagenConfig holds configuration for creating an Imagen provider

```go
type Config struct {
    ID               string
    Model            string
    BaseURL          string
    ApiKey           string
    ProjectID        string
    Location         string
    IncludeRawOutput bool
    Defaults         providers.ProviderDefaults
}
```

<a name="Provider"></a>
## type Provider

Provider implements the Provider interface for Google's Imagen image generation

```go
type Provider struct {
    providers.BaseProvider
    Model      string
    BaseURL    string
    ApiKey     string
    ProjectID  string
    Location   string
    Defaults   providers.ProviderDefaults
    HTTPClient *http.Client
}
```

<a name="NewProvider"></a>
### func NewProvider

```go
func NewProvider(config Config) *Provider
```

NewProvider creates a new Imagen provider

<a name="Provider.CalculateCost"></a>
### func \(\*Provider\) CalculateCost

```go
func (p *Provider) CalculateCost(inputTokens, outputTokens, cachedTokens int) types.CostInfo
```

CalculateCost calculates cost breakdown \(simplified for Imagen\)

<a name="Provider.Close"></a>
### func \(\*Provider\) Close

```go
func (p *Provider) Close() error
```

Close cleans up resources

<a name="Provider.Predict"></a>
### func \(\*Provider\) Predict

```go
func (p *Provider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict generates images based on the last user message

<a name="Provider.PredictStream"></a>
### func \(\*Provider\) PredictStream

```go
func (p *Provider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream is not supported for image generation

<a name="Provider.SupportsStreaming"></a>
### func \(\*Provider\) SupportsStreaming

```go
func (p *Provider) SupportsStreaming() bool
```

SupportsStreaming returns false for Imagen

# mock

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/mock"
```

Package mock provides mock provider implementation for testing and development.

## Index

- [Constants](<#constants>)
- [type AudioURL](<#AudioURL>)
- [type Config](<#Config>)
- [type ContentPart](<#ContentPart>)
  - [func \(m \*ContentPart\) ToContentPart\(\) \*types.ContentPart](<#ContentPart.ToContentPart>)
- [type FileMockRepository](<#FileMockRepository>)
  - [func NewFileMockRepository\(configPath string\) \(\*FileMockRepository, error\)](<#NewFileMockRepository>)
  - [func \(r \*FileMockRepository\) GetResponse\(ctx context.Context, params ResponseParams\) \(string, error\)](<#FileMockRepository.GetResponse>)
  - [func \(r \*FileMockRepository\) GetTurn\(ctx context.Context, params ResponseParams\) \(\*Turn, error\)](<#FileMockRepository.GetTurn>)
- [type ImageURL](<#ImageURL>)
- [type InMemoryMockRepository](<#InMemoryMockRepository>)
  - [func NewInMemoryMockRepository\(defaultResponse string\) \*InMemoryMockRepository](<#NewInMemoryMockRepository>)
  - [func \(r \*InMemoryMockRepository\) GetResponse\(ctx context.Context, params ResponseParams\) \(string, error\)](<#InMemoryMockRepository.GetResponse>)
  - [func \(r \*InMemoryMockRepository\) GetTurn\(ctx context.Context, params ResponseParams\) \(\*Turn, error\)](<#InMemoryMockRepository.GetTurn>)
  - [func \(r \*InMemoryMockRepository\) SetResponse\(scenarioID string, turnNumber int, response string\)](<#InMemoryMockRepository.SetResponse>)
- [type MockStreamSession](<#MockStreamSession>)
  - [func NewMockStreamSession\(\) \*MockStreamSession](<#NewMockStreamSession>)
  - [func \(m \*MockStreamSession\) Close\(\) error](<#MockStreamSession.Close>)
  - [func \(m \*MockStreamSession\) Done\(\) \<\-chan struct\{\}](<#MockStreamSession.Done>)
  - [func \(m \*MockStreamSession\) EmitChunk\(chunk \*providers.StreamChunk\)](<#MockStreamSession.EmitChunk>)
  - [func \(m \*MockStreamSession\) EndInput\(\)](<#MockStreamSession.EndInput>)
  - [func \(m \*MockStreamSession\) Error\(\) error](<#MockStreamSession.Error>)
  - [func \(m \*MockStreamSession\) GetChunks\(\) \[\]\*types.MediaChunk](<#MockStreamSession.GetChunks>)
  - [func \(m \*MockStreamSession\) GetTexts\(\) \[\]string](<#MockStreamSession.GetTexts>)
  - [func \(m \*MockStreamSession\) Response\(\) \<\-chan providers.StreamChunk](<#MockStreamSession.Response>)
  - [func \(m \*MockStreamSession\) SendChunk\(ctx context.Context, chunk \*types.MediaChunk\) error](<#MockStreamSession.SendChunk>)
  - [func \(m \*MockStreamSession\) SendSystemContext\(ctx context.Context, text string\) error](<#MockStreamSession.SendSystemContext>)
  - [func \(m \*MockStreamSession\) SendText\(ctx context.Context, text string\) error](<#MockStreamSession.SendText>)
  - [func \(m \*MockStreamSession\) WithAutoRespond\(text string\) \*MockStreamSession](<#MockStreamSession.WithAutoRespond>)
  - [func \(m \*MockStreamSession\) WithCloseAfterResponse\(closeAfter bool\) \*MockStreamSession](<#MockStreamSession.WithCloseAfterResponse>)
  - [func \(m \*MockStreamSession\) WithCloseAfterTurns\(turns int, noResponse ...bool\) \*MockStreamSession](<#MockStreamSession.WithCloseAfterTurns>)
  - [func \(m \*MockStreamSession\) WithError\(err error\) \*MockStreamSession](<#MockStreamSession.WithError>)
  - [func \(m \*MockStreamSession\) WithInterruptOnTurn\(turnNumber int\) \*MockStreamSession](<#MockStreamSession.WithInterruptOnTurn>)
  - [func \(m \*MockStreamSession\) WithResponseChunks\(chunks \[\]providers.StreamChunk\) \*MockStreamSession](<#MockStreamSession.WithResponseChunks>)
  - [func \(m \*MockStreamSession\) WithSendChunkError\(err error\) \*MockStreamSession](<#MockStreamSession.WithSendChunkError>)
  - [func \(m \*MockStreamSession\) WithSendTextError\(err error\) \*MockStreamSession](<#MockStreamSession.WithSendTextError>)
- [type Provider](<#Provider>)
  - [func NewProvider\(id, model string, includeRawOutput bool\) \*Provider](<#NewProvider>)
  - [func NewProviderWithRepository\(id, model string, includeRawOutput bool, repo ResponseRepository\) \*Provider](<#NewProviderWithRepository>)
  - [func \(m \*Provider\) CalculateCost\(inputTokens, outputTokens, cachedTokens int\) types.CostInfo](<#Provider.CalculateCost>)
  - [func \(m \*Provider\) Close\(\) error](<#Provider.Close>)
  - [func \(m \*Provider\) ID\(\) string](<#Provider.ID>)
  - [func \(m \*Provider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#Provider.Predict>)
  - [func \(m \*Provider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#Provider.PredictStream>)
  - [func \(m \*Provider\) ShouldIncludeRawOutput\(\) bool](<#Provider.ShouldIncludeRawOutput>)
  - [func \(m \*Provider\) SupportsStreaming\(\) bool](<#Provider.SupportsStreaming>)
- [type ResponseParams](<#ResponseParams>)
- [type ResponseRepository](<#ResponseRepository>)
- [type ScenarioConfig](<#ScenarioConfig>)
- [type StreamingProvider](<#StreamingProvider>)
  - [func NewStreamingProvider\(id, model string, includeRawOutput bool\) \*StreamingProvider](<#NewStreamingProvider>)
  - [func NewStreamingProviderWithRepository\(id, model string, includeRawOutput bool, repo ResponseRepository\) \*StreamingProvider](<#NewStreamingProviderWithRepository>)
  - [func \(p \*StreamingProvider\) CreateStreamSession\(ctx context.Context, req \*providers.StreamingInputConfig\) \(providers.StreamInputSession, error\)](<#StreamingProvider.CreateStreamSession>)
  - [func \(p \*StreamingProvider\) GetSession\(\) \*MockStreamSession](<#StreamingProvider.GetSession>)
  - [func \(p \*StreamingProvider\) GetSessions\(\) \[\]\*MockStreamSession](<#StreamingProvider.GetSessions>)
  - [func \(p \*StreamingProvider\) GetStreamingCapabilities\(\) providers.StreamingCapabilities](<#StreamingProvider.GetStreamingCapabilities>)
  - [func \(p \*StreamingProvider\) SupportsStreamInput\(\) \[\]string](<#StreamingProvider.SupportsStreamInput>)
  - [func \(p \*StreamingProvider\) WithAutoRespond\(responseText string\) \*StreamingProvider](<#StreamingProvider.WithAutoRespond>)
  - [func \(p \*StreamingProvider\) WithCloseAfterTurns\(turns int, noResponse ...bool\) \*StreamingProvider](<#StreamingProvider.WithCloseAfterTurns>)
  - [func \(p \*StreamingProvider\) WithCreateSessionError\(err error\) \*StreamingProvider](<#StreamingProvider.WithCreateSessionError>)
  - [func \(p \*StreamingProvider\) WithInterruptOnTurn\(turnNumber int\) \*StreamingProvider](<#StreamingProvider.WithInterruptOnTurn>)
- [type ToolCall](<#ToolCall>)
- [type ToolProvider](<#ToolProvider>)
  - [func NewToolProvider\(id, model string, includeRawOutput bool, additionalConfig map\[string\]interface\{\}\) \*ToolProvider](<#NewToolProvider>)
  - [func NewToolProviderWithRepository\(id, model string, includeRawOutput bool, repo ResponseRepository\) \*ToolProvider](<#NewToolProviderWithRepository>)
  - [func \(m \*ToolProvider\) BuildTooling\(descriptors \[\]\*providers.ToolDescriptor\) \(interface\{\}, error\)](<#ToolProvider.BuildTooling>)
  - [func \(m \*ToolProvider\) PredictStreamWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(\<\-chan providers.StreamChunk, error\)](<#ToolProvider.PredictStreamWithTools>)
  - [func \(m \*ToolProvider\) PredictWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#ToolProvider.PredictWithTools>)
- [type Turn](<#Turn>)
  - [func \(t \*Turn\) ToContentParts\(\) \[\]types.ContentPart](<#Turn.ToContentParts>)
- [type VideoURL](<#VideoURL>)


## Constants

<a name="DefaultMockStreamingResponse"></a>

```go
const (

    // DefaultMockStreamingResponse is the default response text for auto-respond mode.
    DefaultMockStreamingResponse = "Mock streaming response"
)
```

<a name="AudioURL"></a>
## type AudioURL

AudioURL represents audio content in a mock response.

```go
type AudioURL struct {
    URL string `yaml:"url"` // URL to the audio file (can be mock://, http://, https://, data:, or file path)
}
```

<a name="Config"></a>
## type Config

Config represents the structure of a mock configuration file. This allows scenario\-specific and turn\-specific responses to be defined.

```go
type Config struct {
    // Default response if no specific match is found
    DefaultResponse string `yaml:"defaultResponse"`

    // Scenario-specific responses keyed by scenario ID
    Scenarios map[string]ScenarioConfig `yaml:"scenarios,omitempty"`

    // Selfplay persona responses keyed by persona ID
    // Used when generating user messages in selfplay mode
    Selfplay map[string]ScenarioConfig `yaml:"selfplay,omitempty"`
}
```

<a name="ContentPart"></a>
## type ContentPart

ContentPart represents a single content part in a multimodal mock response. This mirrors the structure of types.ContentPart but with YAML\-friendly field names.

```go
type ContentPart struct {
    Type     string                 `yaml:"type"`                // "text", "image", "audio", or "video"
    Text     string                 `yaml:"text,omitempty"`      // Text content (for type="text")
    ImageURL *ImageURL              `yaml:"image_url,omitempty"` // Image URL (for type="image")
    AudioURL *AudioURL              `yaml:"audio_url,omitempty"` // Audio URL (for type="audio")
    VideoURL *VideoURL              `yaml:"video_url,omitempty"` // Video URL (for type="video")
    Metadata map[string]interface{} `yaml:"metadata,omitempty"`  // Additional metadata
}
```

<a name="ContentPart.ToContentPart"></a>
### func \(\*ContentPart\) ToContentPart

```go
func (m *ContentPart) ToContentPart() *types.ContentPart
```

ToContentPart converts a ContentPart to types.ContentPart.

<a name="FileMockRepository"></a>
## type FileMockRepository

FileMockRepository loads mock responses from a YAML configuration file. This is the default implementation for file\-based mock configurations.

```go
type FileMockRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewFileMockRepository"></a>
### func NewFileMockRepository

```go
func NewFileMockRepository(configPath string) (*FileMockRepository, error)
```

NewFileMockRepository creates a repository that loads mock responses from a YAML file. The file should follow the Config structure with scenarios and turn\-specific responses.

<a name="FileMockRepository.GetResponse"></a>
### func \(\*FileMockRepository\) GetResponse

```go
func (r *FileMockRepository) GetResponse(ctx context.Context, params ResponseParams) (string, error)
```

GetResponse retrieves a mock response based on the provided parameters. It follows this priority order: 1. Scenario \+ Turn specific response 2. Scenario default response 3. Global default response 4. Generic fallback message

<a name="FileMockRepository.GetTurn"></a>
### func \(\*FileMockRepository\) GetTurn

```go
func (r *FileMockRepository) GetTurn(ctx context.Context, params ResponseParams) (*Turn, error)
```

GetTurn retrieves a structured mock turn response that may include tool calls. This method supports both backward\-compatible string responses and new structured Turn responses.

For selfplay user turns \(when ArenaRole == "self\_play\_user"\), it looks up responses from the selfplay section using PersonaID. For regular turns, it uses scenario responses.

<a name="ImageURL"></a>
## type ImageURL

ImageURL represents image content in a mock response.

```go
type ImageURL struct {
    URL    string  `yaml:"url"`              // URL to the image (can be mock://, http://, https://, data:, or file path)
    Detail *string `yaml:"detail,omitempty"` // Detail level: "low", "high", "auto"
}
```

<a name="InMemoryMockRepository"></a>
## type InMemoryMockRepository

InMemoryMockRepository stores mock responses in memory. This is useful for testing and programmatic configuration without files.

```go
type InMemoryMockRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewInMemoryMockRepository"></a>
### func NewInMemoryMockRepository

```go
func NewInMemoryMockRepository(defaultResponse string) *InMemoryMockRepository
```

NewInMemoryMockRepository creates an in\-memory repository with a default response.

<a name="InMemoryMockRepository.GetResponse"></a>
### func \(\*InMemoryMockRepository\) GetResponse

```go
func (r *InMemoryMockRepository) GetResponse(ctx context.Context, params ResponseParams) (string, error)
```

GetResponse retrieves a mock response based on the provided parameters.

<a name="InMemoryMockRepository.GetTurn"></a>
### func \(\*InMemoryMockRepository\) GetTurn

```go
func (r *InMemoryMockRepository) GetTurn(ctx context.Context, params ResponseParams) (*Turn, error)
```

GetTurn retrieves a structured mock turn response. InMemoryMockRepository currently only supports simple text responses.

<a name="InMemoryMockRepository.SetResponse"></a>
### func \(\*InMemoryMockRepository\) SetResponse

```go
func (r *InMemoryMockRepository) SetResponse(scenarioID string, turnNumber int, response string)
```

SetResponse sets a mock response for a specific scenario and turn. Use turnNumber = 0 for scenario default, or \-1 for global default.

<a name="MockStreamSession"></a>
## type MockStreamSession

MockStreamSession implements providers.StreamInputSession for testing duplex scenarios.

```go
type MockStreamSession struct {
    // contains filtered or unexported fields
}
```

<a name="NewMockStreamSession"></a>
### func NewMockStreamSession

```go
func NewMockStreamSession() *MockStreamSession
```

NewMockStreamSession creates a new mock stream session.

<a name="MockStreamSession.Close"></a>
### func \(\*MockStreamSession\) Close

```go
func (m *MockStreamSession) Close() error
```

Close implements StreamInputSession.Close.

<a name="MockStreamSession.Done"></a>
### func \(\*MockStreamSession\) Done

```go
func (m *MockStreamSession) Done() <-chan struct{}
```

Done implements StreamInputSession.Done.

<a name="MockStreamSession.EmitChunk"></a>
### func \(\*MockStreamSession\) EmitChunk

```go
func (m *MockStreamSession) EmitChunk(chunk *providers.StreamChunk)
```

EmitChunk sends a response chunk \(for testing\).

<a name="MockStreamSession.EndInput"></a>
### func \(\*MockStreamSession\) EndInput

```go
func (m *MockStreamSession) EndInput()
```

EndInput signals the end of input for the current turn. For mock sessions with auto\-respond enabled, this triggers the response.

<a name="MockStreamSession.Error"></a>
### func \(\*MockStreamSession\) Error

```go
func (m *MockStreamSession) Error() error
```

Error implements StreamInputSession.Error.

<a name="MockStreamSession.GetChunks"></a>
### func \(\*MockStreamSession\) GetChunks

```go
func (m *MockStreamSession) GetChunks() []*types.MediaChunk
```

GetChunks returns all received media chunks \(for testing\).

<a name="MockStreamSession.GetTexts"></a>
### func \(\*MockStreamSession\) GetTexts

```go
func (m *MockStreamSession) GetTexts() []string
```

GetTexts returns all received text messages \(for testing\).

<a name="MockStreamSession.Response"></a>
### func \(\*MockStreamSession\) Response

```go
func (m *MockStreamSession) Response() <-chan providers.StreamChunk
```

Response implements StreamInputSession.Response.

<a name="MockStreamSession.SendChunk"></a>
### func \(\*MockStreamSession\) SendChunk

```go
func (m *MockStreamSession) SendChunk(ctx context.Context, chunk *types.MediaChunk) error
```

SendChunk implements StreamInputSession.SendChunk.

<a name="MockStreamSession.SendSystemContext"></a>
### func \(\*MockStreamSession\) SendSystemContext

```go
func (m *MockStreamSession) SendSystemContext(ctx context.Context, text string) error
```

SendSystemContext implements StreamInputSession.SendSystemContext. Unlike SendText, this does NOT trigger a response from the model.

<a name="MockStreamSession.SendText"></a>
### func \(\*MockStreamSession\) SendText

```go
func (m *MockStreamSession) SendText(ctx context.Context, text string) error
```

SendText implements StreamInputSession.SendText.

<a name="MockStreamSession.WithAutoRespond"></a>
### func \(\*MockStreamSession\) WithAutoRespond

```go
func (m *MockStreamSession) WithAutoRespond(text string) *MockStreamSession
```

WithAutoRespond configures the session to automatically respond to inputs. The session stays open to handle multiple turns \- call Close\(\) when done.

<a name="MockStreamSession.WithCloseAfterResponse"></a>
### func \(\*MockStreamSession\) WithCloseAfterResponse

```go
func (m *MockStreamSession) WithCloseAfterResponse(closeAfter bool) *MockStreamSession
```

WithCloseAfterResponse configures whether to close the response channel after auto\-responding.

<a name="MockStreamSession.WithCloseAfterTurns"></a>
### func \(\*MockStreamSession\) WithCloseAfterTurns

```go
func (m *MockStreamSession) WithCloseAfterTurns(turns int, noResponse ...bool) *MockStreamSession
```

WithCloseAfterTurns configures the session to close unexpectedly after N turns. This simulates Gemini dropping the connection mid\-conversation. If noResponse is true, the session closes WITHOUT sending the final response \(mimics Gemini closing after interrupted turnComplete\).

<a name="MockStreamSession.WithError"></a>
### func \(\*MockStreamSession\) WithError

```go
func (m *MockStreamSession) WithError(err error) *MockStreamSession
```

WithError sets the error returned by Error\(\).

<a name="MockStreamSession.WithInterruptOnTurn"></a>
### func \(\*MockStreamSession\) WithInterruptOnTurn

```go
func (m *MockStreamSession) WithInterruptOnTurn(turnNumber int) *MockStreamSession
```

WithInterruptOnTurn configures the session to simulate an interruption on a specific turn. This mimics Gemini detecting user speech while the model is responding. The turn is 1\-indexed \(first turn = 1\).

<a name="MockStreamSession.WithResponseChunks"></a>
### func \(\*MockStreamSession\) WithResponseChunks

```go
func (m *MockStreamSession) WithResponseChunks(chunks []providers.StreamChunk) *MockStreamSession
```

WithResponseChunks configures custom response chunks to emit.

<a name="MockStreamSession.WithSendChunkError"></a>
### func \(\*MockStreamSession\) WithSendChunkError

```go
func (m *MockStreamSession) WithSendChunkError(err error) *MockStreamSession
```

WithSendChunkError configures SendChunk to return an error.

<a name="MockStreamSession.WithSendTextError"></a>
### func \(\*MockStreamSession\) WithSendTextError

```go
func (m *MockStreamSession) WithSendTextError(err error) *MockStreamSession
```

WithSendTextError configures SendText to return an error.

<a name="Provider"></a>
## type Provider

Provider is a provider implementation for testing and development. It returns mock responses without making any API calls, using a repository pattern to source responses from various backends \(files, memory, databases\).

Provider is designed to be reusable across different contexts:

- Arena testing: scenario and turn\-specific responses
- SDK examples: simple deterministic responses
- Unit tests: programmatic response configuration

```go
type Provider struct {
    // contains filtered or unexported fields
}
```

<a name="NewProvider"></a>
### func NewProvider

```go
func NewProvider(id, model string, includeRawOutput bool) *Provider
```

NewProvider creates a new mock provider with default in\-memory responses. This constructor maintains backward compatibility with existing code.

<a name="NewProviderWithRepository"></a>
### func NewProviderWithRepository

```go
func NewProviderWithRepository(id, model string, includeRawOutput bool, repo ResponseRepository) *Provider
```

NewProviderWithRepository creates a mock provider with a custom response repository. This allows for advanced scenarios like file\-based or database\-backed mock responses.

<a name="Provider.CalculateCost"></a>
### func \(\*Provider\) CalculateCost

```go
func (m *Provider) CalculateCost(inputTokens, outputTokens, cachedTokens int) types.CostInfo
```

CalculateCost calculates cost breakdown for given token counts.

<a name="Provider.Close"></a>
### func \(\*Provider\) Close

```go
func (m *Provider) Close() error
```

Close is a no\-op for the mock provider. NOSONAR: Intentionally empty \- mock provider has no resources to clean up

<a name="Provider.ID"></a>
### func \(\*Provider\) ID

```go
func (m *Provider) ID() string
```

ID returns the provider ID.

<a name="Provider.Predict"></a>
### func \(\*Provider\) Predict

```go
func (m *Provider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict returns a mock response using the configured repository.

<a name="Provider.PredictStream"></a>
### func \(\*Provider\) PredictStream

```go
func (m *Provider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream returns a mock streaming response using the configured repository.

<a name="Provider.ShouldIncludeRawOutput"></a>
### func \(\*Provider\) ShouldIncludeRawOutput

```go
func (m *Provider) ShouldIncludeRawOutput() bool
```

ShouldIncludeRawOutput returns whether raw API responses should be included.

<a name="Provider.SupportsStreaming"></a>
### func \(\*Provider\) SupportsStreaming

```go
func (m *Provider) SupportsStreaming() bool
```

SupportsStreaming indicates whether the provider supports streaming.

<a name="ResponseParams"></a>
## type ResponseParams

ResponseParams contains parameters for looking up mock responses. Different implementations may use different subsets of these fields.

```go
type ResponseParams struct {
    ScenarioID string // Optional: ID of the scenario being executed
    TurnNumber int    // Optional: Turn number in a multi-turn conversation
    ProviderID string // Optional: ID of the provider being mocked
    ModelName  string // Optional: Model name being mocked
    PersonaID  string // Optional: ID of the persona for selfplay user responses
    ArenaRole  string // Optional: Role in arena (e.g., "self_play_user")
}
```

<a name="ResponseRepository"></a>
## type ResponseRepository

ResponseRepository provides an interface for retrieving mock responses. This abstraction allows mock data to come from various sources \(files, databases, etc.\) and makes MockProvider reusable across different contexts \(Arena, SDK examples, unit tests\).

```go
type ResponseRepository interface {
    // GetResponse retrieves a mock response for the given context.
    // Parameters can include scenario ID, turn number, provider ID, etc.
    // Returns the response text and any error encountered.
    GetResponse(ctx context.Context, params ResponseParams) (string, error)

    // GetTurn retrieves a mock turn response that may include tool calls.
    // This extends GetResponse to support structured turn data with tool call simulation.
    GetTurn(ctx context.Context, params ResponseParams) (*Turn, error)
}
```

<a name="ScenarioConfig"></a>
## type ScenarioConfig

ScenarioConfig defines mock responses for a specific scenario.

```go
type ScenarioConfig struct {
    // Default response for this scenario (overrides global default)
    DefaultResponse string `yaml:"defaultResponse,omitempty"`

    // Turn-specific responses keyed by turn number (1-indexed)
    // Supports both simple string responses (backward compatibility) and structured Turn responses
    Turns map[int]interface{} `yaml:"turns,omitempty"`
}
```

<a name="StreamingProvider"></a>
## type StreamingProvider

StreamingProvider extends Provider with StreamInputSupport for duplex testing.

```go
type StreamingProvider struct {
    *Provider
    // contains filtered or unexported fields
}
```

<a name="NewStreamingProvider"></a>
### func NewStreamingProvider

```go
func NewStreamingProvider(id, model string, includeRawOutput bool) *StreamingProvider
```

NewStreamingProvider creates a mock provider with duplex streaming support.

<a name="NewStreamingProviderWithRepository"></a>
### func NewStreamingProviderWithRepository

```go
func NewStreamingProviderWithRepository(id, model string, includeRawOutput bool, repo ResponseRepository) *StreamingProvider
```

NewStreamingProviderWithRepository creates a mock streaming provider with a custom repository.

<a name="StreamingProvider.CreateStreamSession"></a>
### func \(\*StreamingProvider\) CreateStreamSession

```go
func (p *StreamingProvider) CreateStreamSession(ctx context.Context, req *providers.StreamingInputConfig) (providers.StreamInputSession, error)
```

CreateStreamSession implements StreamInputSupport.CreateStreamSession.

<a name="StreamingProvider.GetSession"></a>
### func \(\*StreamingProvider\) GetSession

```go
func (p *StreamingProvider) GetSession() *MockStreamSession
```

GetSession returns the first/most recent mock session for testing access to sent chunks/texts. For multiple sessions, use GetSessions\(\) instead.

<a name="StreamingProvider.GetSessions"></a>
### func \(\*StreamingProvider\) GetSessions

```go
func (p *StreamingProvider) GetSessions() []*MockStreamSession
```

GetSessions returns all created sessions for testing.

<a name="StreamingProvider.GetStreamingCapabilities"></a>
### func \(\*StreamingProvider\) GetStreamingCapabilities

```go
func (p *StreamingProvider) GetStreamingCapabilities() providers.StreamingCapabilities
```

GetStreamingCapabilities implements StreamInputSupport.GetStreamingCapabilities.

<a name="StreamingProvider.SupportsStreamInput"></a>
### func \(\*StreamingProvider\) SupportsStreamInput

```go
func (p *StreamingProvider) SupportsStreamInput() []string
```

SupportsStreamInput implements StreamInputSupport.SupportsStreamInput.

<a name="StreamingProvider.WithAutoRespond"></a>
### func \(\*StreamingProvider\) WithAutoRespond

```go
func (p *StreamingProvider) WithAutoRespond(responseText string) *StreamingProvider
```

WithAutoRespond configures the provider to create sessions that auto\-respond to inputs.

<a name="StreamingProvider.WithCloseAfterTurns"></a>
### func \(\*StreamingProvider\) WithCloseAfterTurns

```go
func (p *StreamingProvider) WithCloseAfterTurns(turns int, noResponse ...bool) *StreamingProvider
```

WithCloseAfterTurns configures the provider to create sessions that close unexpectedly after N turns. This simulates Gemini dropping the connection. If noResponse is true, the session closes WITHOUT sending the final response.

<a name="StreamingProvider.WithCreateSessionError"></a>
### func \(\*StreamingProvider\) WithCreateSessionError

```go
func (p *StreamingProvider) WithCreateSessionError(err error) *StreamingProvider
```

WithCreateSessionError configures CreateStreamSession to return an error.

<a name="StreamingProvider.WithInterruptOnTurn"></a>
### func \(\*StreamingProvider\) WithInterruptOnTurn

```go
func (p *StreamingProvider) WithInterruptOnTurn(turnNumber int) *StreamingProvider
```

WithInterruptOnTurn configures the provider to create sessions that simulate an interruption on a specific turn. This mimics Gemini detecting user speech while the model is responding.

<a name="ToolCall"></a>
## type ToolCall

ToolCall represents a simulated tool call from the LLM.

```go
type ToolCall struct {
    Name      string                 `yaml:"name"`      // Name of the tool to call
    Arguments map[string]interface{} `yaml:"arguments"` // Arguments to pass to the tool
}
```

<a name="ToolProvider"></a>
## type ToolProvider

ToolProvider extends MockProvider to support tool/function calling and duplex streaming. It implements the ToolSupport interface to enable tool call simulation while maintaining compatibility with the existing MockProvider API. By embedding StreamingProvider, it also supports StreamInputSupport for duplex scenarios.

```go
type ToolProvider struct {
    *StreamingProvider
}
```

<a name="NewToolProvider"></a>
### func NewToolProvider

```go
func NewToolProvider(id, model string, includeRawOutput bool, additionalConfig map[string]interface{}) *ToolProvider
```

NewToolProvider creates a new mock provider with tool support and duplex streaming. This uses default in\-memory responses for backward compatibility.

<a name="NewToolProviderWithRepository"></a>
### func NewToolProviderWithRepository

```go
func NewToolProviderWithRepository(id, model string, includeRawOutput bool, repo ResponseRepository) *ToolProvider
```

NewToolProviderWithRepository creates a mock provider with tool support and duplex streaming using a custom response repository for advanced scenarios.

<a name="ToolProvider.BuildTooling"></a>
### func \(\*ToolProvider\) BuildTooling

```go
func (m *ToolProvider) BuildTooling(descriptors []*providers.ToolDescriptor) (interface{}, error)
```

BuildTooling implements the ToolSupport interface. For mock providers, we just return the tools as\-is since we don't need to transform them into a provider\-specific format.

<a name="ToolProvider.PredictStreamWithTools"></a>
### func \(\*ToolProvider\) PredictStreamWithTools

```go
func (m *ToolProvider) PredictStreamWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (<-chan providers.StreamChunk, error)
```

PredictStreamWithTools performs a streaming predict request with tool support. For mock providers, this delegates to PredictWithTools and wraps the response in chunks.

<a name="ToolProvider.PredictWithTools"></a>
### func \(\*ToolProvider\) PredictWithTools

```go
func (m *ToolProvider) PredictWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictWithTools implements the ToolSupport interface. This method handles the initial predict request with tools available, potentially returning tool calls based on the mock configuration.

<a name="Turn"></a>
## type Turn

Turn represents a structured mock response that may include tool calls and multimodal content. This extends simple text responses to support tool call simulation and multimodal content parts.

```go
type Turn struct {
    Type      string        `yaml:"type"`                 // "text", "tool_calls", or "multimodal"
    Content   string        `yaml:"content,omitempty"`    // Text content for the response
    Parts     []ContentPart `yaml:"parts,omitempty"`      // Multimodal content parts (text, image, audio, video)
    ToolCalls []ToolCall    `yaml:"tool_calls,omitempty"` // Tool calls to simulate
}
```

<a name="Turn.ToContentParts"></a>
### func \(\*Turn\) ToContentParts

```go
func (t *Turn) ToContentParts() []types.ContentPart
```

ToContentParts converts Turn to a slice of types.ContentPart. This handles both legacy text\-only responses and new multimodal responses.

<a name="VideoURL"></a>
## type VideoURL

VideoURL represents video content in a mock response.

```go
type VideoURL struct {
    URL string `yaml:"url"` // URL to the video file (can be mock://, http://, https://, data:, or file path)
}
```

# openai

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/openai"
```

Package openai provides OpenAI LLM provider integration.

Package openai provides OpenAI Realtime API streaming support.

Package openai provides OpenAI Realtime API streaming support.

Package openai provides OpenAI Realtime API streaming support.

Package openai provides OpenAI Realtime API streaming support.

Package openai provides OpenAI Realtime API streaming support.

Package openai provides OpenAI Realtime API streaming support.

Package openai provides OpenAI Realtime API streaming support.

## Index

- [Constants](<#constants>)
- [func ParseServerEvent\(data \[\]byte\) \(interface\{\}, error\)](<#ParseServerEvent>)
- [func RealtimeStreamingCapabilities\(\) providers.StreamingCapabilities](<#RealtimeStreamingCapabilities>)
- [type ClientEvent](<#ClientEvent>)
- [type ConversationContent](<#ConversationContent>)
- [type ConversationItem](<#ConversationItem>)
- [type ConversationItemCreateEvent](<#ConversationItemCreateEvent>)
- [type ConversationItemCreatedEvent](<#ConversationItemCreatedEvent>)
- [type ConversationItemInputAudioTranscriptionCompletedEvent](<#ConversationItemInputAudioTranscriptionCompletedEvent>)
- [type ConversationItemInputAudioTranscriptionFailedEvent](<#ConversationItemInputAudioTranscriptionFailedEvent>)
- [type EmbeddingOption](<#EmbeddingOption>)
  - [func WithEmbeddingAPIKey\(key string\) EmbeddingOption](<#WithEmbeddingAPIKey>)
  - [func WithEmbeddingBaseURL\(url string\) EmbeddingOption](<#WithEmbeddingBaseURL>)
  - [func WithEmbeddingHTTPClient\(client \*http.Client\) EmbeddingOption](<#WithEmbeddingHTTPClient>)
  - [func WithEmbeddingModel\(model string\) EmbeddingOption](<#WithEmbeddingModel>)
- [type EmbeddingProvider](<#EmbeddingProvider>)
  - [func NewEmbeddingProvider\(opts ...EmbeddingOption\) \(\*EmbeddingProvider, error\)](<#NewEmbeddingProvider>)
  - [func \(p \*EmbeddingProvider\) Embed\(ctx context.Context, req providers.EmbeddingRequest\) \(providers.EmbeddingResponse, error\)](<#EmbeddingProvider.Embed>)
  - [func \(p \*EmbeddingProvider\) EstimateCost\(tokens int\) float64](<#EmbeddingProvider.EstimateCost>)
- [type ErrorDetail](<#ErrorDetail>)
- [type ErrorEvent](<#ErrorEvent>)
- [type InputAudioBufferAppendEvent](<#InputAudioBufferAppendEvent>)
- [type InputAudioBufferClearEvent](<#InputAudioBufferClearEvent>)
- [type InputAudioBufferClearedEvent](<#InputAudioBufferClearedEvent>)
- [type InputAudioBufferCommitEvent](<#InputAudioBufferCommitEvent>)
- [type InputAudioBufferCommittedEvent](<#InputAudioBufferCommittedEvent>)
- [type InputAudioBufferSpeechStartedEvent](<#InputAudioBufferSpeechStartedEvent>)
- [type InputAudioBufferSpeechStoppedEvent](<#InputAudioBufferSpeechStoppedEvent>)
- [type Provider](<#Provider>)
  - [func NewProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*Provider](<#NewProvider>)
  - [func \(p \*Provider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#Provider.CalculateCost>)
  - [func \(p \*Provider\) CreateStreamSession\(ctx context.Context, req \*providers.StreamingInputConfig\) \(providers.StreamInputSession, error\)](<#Provider.CreateStreamSession>)
  - [func \(p \*Provider\) GetMultimodalCapabilities\(\) providers.MultimodalCapabilities](<#Provider.GetMultimodalCapabilities>)
  - [func \(p \*Provider\) GetStreamingCapabilities\(\) providers.StreamingCapabilities](<#Provider.GetStreamingCapabilities>)
  - [func \(p \*Provider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#Provider.Predict>)
  - [func \(p \*Provider\) PredictMultimodal\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#Provider.PredictMultimodal>)
  - [func \(p \*Provider\) PredictMultimodalStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#Provider.PredictMultimodalStream>)
  - [func \(p \*Provider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#Provider.PredictStream>)
  - [func \(p \*Provider\) SupportsStreamInput\(\) \[\]string](<#Provider.SupportsStreamInput>)
- [type RateLimit](<#RateLimit>)
- [type RateLimitsUpdatedEvent](<#RateLimitsUpdatedEvent>)
- [type RealtimeSession](<#RealtimeSession>)
  - [func NewRealtimeSession\(ctx context.Context, apiKey string, config \*RealtimeSessionConfig\) \(\*RealtimeSession, error\)](<#NewRealtimeSession>)
  - [func \(s \*RealtimeSession\) CancelResponse\(\) error](<#RealtimeSession.CancelResponse>)
  - [func \(s \*RealtimeSession\) ClearAudioBuffer\(\) error](<#RealtimeSession.ClearAudioBuffer>)
  - [func \(s \*RealtimeSession\) Close\(\) error](<#RealtimeSession.Close>)
  - [func \(s \*RealtimeSession\) CommitAudioBuffer\(\) error](<#RealtimeSession.CommitAudioBuffer>)
  - [func \(s \*RealtimeSession\) Done\(\) \<\-chan struct\{\}](<#RealtimeSession.Done>)
  - [func \(s \*RealtimeSession\) EndInput\(\)](<#RealtimeSession.EndInput>)
  - [func \(s \*RealtimeSession\) Error\(\) error](<#RealtimeSession.Error>)
  - [func \(s \*RealtimeSession\) Response\(\) \<\-chan providers.StreamChunk](<#RealtimeSession.Response>)
  - [func \(s \*RealtimeSession\) SendChunk\(ctx context.Context, chunk \*types.MediaChunk\) error](<#RealtimeSession.SendChunk>)
  - [func \(s \*RealtimeSession\) SendSystemContext\(ctx context.Context, text string\) error](<#RealtimeSession.SendSystemContext>)
  - [func \(s \*RealtimeSession\) SendText\(ctx context.Context, text string\) error](<#RealtimeSession.SendText>)
  - [func \(s \*RealtimeSession\) SendToolResponse\(ctx context.Context, toolCallID, result string\) error](<#RealtimeSession.SendToolResponse>)
  - [func \(s \*RealtimeSession\) SendToolResponses\(ctx context.Context, responses \[\]providers.ToolResponse\) error](<#RealtimeSession.SendToolResponses>)
  - [func \(s \*RealtimeSession\) TriggerResponse\(config \*ResponseConfig\) error](<#RealtimeSession.TriggerResponse>)
- [type RealtimeSessionConfig](<#RealtimeSessionConfig>)
  - [func DefaultRealtimeSessionConfig\(\) RealtimeSessionConfig](<#DefaultRealtimeSessionConfig>)
- [type RealtimeToolDef](<#RealtimeToolDef>)
- [type RealtimeToolDefinition](<#RealtimeToolDefinition>)
- [type RealtimeWebSocket](<#RealtimeWebSocket>)
  - [func NewRealtimeWebSocket\(model, apiKey string\) \*RealtimeWebSocket](<#NewRealtimeWebSocket>)
  - [func \(ws \*RealtimeWebSocket\) Close\(\) error](<#RealtimeWebSocket.Close>)
  - [func \(ws \*RealtimeWebSocket\) Connect\(ctx context.Context\) error](<#RealtimeWebSocket.Connect>)
  - [func \(ws \*RealtimeWebSocket\) ConnectWithRetry\(ctx context.Context\) error](<#RealtimeWebSocket.ConnectWithRetry>)
  - [func \(ws \*RealtimeWebSocket\) IsClosed\(\) bool](<#RealtimeWebSocket.IsClosed>)
  - [func \(ws \*RealtimeWebSocket\) Receive\(ctx context.Context\) \(\[\]byte, error\)](<#RealtimeWebSocket.Receive>)
  - [func \(ws \*RealtimeWebSocket\) ReceiveLoop\(ctx context.Context, msgCh chan\<\- \[\]byte\) error](<#RealtimeWebSocket.ReceiveLoop>)
  - [func \(ws \*RealtimeWebSocket\) Send\(msg interface\{\}\) error](<#RealtimeWebSocket.Send>)
  - [func \(ws \*RealtimeWebSocket\) StartHeartbeat\(ctx context.Context, interval time.Duration\)](<#RealtimeWebSocket.StartHeartbeat>)
- [type ResponseAudioDeltaEvent](<#ResponseAudioDeltaEvent>)
- [type ResponseAudioDoneEvent](<#ResponseAudioDoneEvent>)
- [type ResponseAudioTranscriptDeltaEvent](<#ResponseAudioTranscriptDeltaEvent>)
- [type ResponseAudioTranscriptDoneEvent](<#ResponseAudioTranscriptDoneEvent>)
- [type ResponseCancelEvent](<#ResponseCancelEvent>)
- [type ResponseConfig](<#ResponseConfig>)
- [type ResponseContentPartAddedEvent](<#ResponseContentPartAddedEvent>)
- [type ResponseContentPartDoneEvent](<#ResponseContentPartDoneEvent>)
- [type ResponseCreateEvent](<#ResponseCreateEvent>)
- [type ResponseCreatedEvent](<#ResponseCreatedEvent>)
- [type ResponseDoneEvent](<#ResponseDoneEvent>)
- [type ResponseFunctionCallArgumentsDeltaEvent](<#ResponseFunctionCallArgumentsDeltaEvent>)
- [type ResponseFunctionCallArgumentsDoneEvent](<#ResponseFunctionCallArgumentsDoneEvent>)
- [type ResponseInfo](<#ResponseInfo>)
- [type ResponseOutputItemAddedEvent](<#ResponseOutputItemAddedEvent>)
- [type ResponseOutputItemDoneEvent](<#ResponseOutputItemDoneEvent>)
- [type ResponseTextDeltaEvent](<#ResponseTextDeltaEvent>)
- [type ResponseTextDoneEvent](<#ResponseTextDoneEvent>)
- [type ServerEvent](<#ServerEvent>)
- [type SessionConfig](<#SessionConfig>)
- [type SessionCreatedEvent](<#SessionCreatedEvent>)
- [type SessionInfo](<#SessionInfo>)
- [type SessionUpdateEvent](<#SessionUpdateEvent>)
- [type SessionUpdatedEvent](<#SessionUpdatedEvent>)
- [type ToolProvider](<#ToolProvider>)
  - [func NewToolProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool, additionalConfig map\[string\]interface\{\}\) \*ToolProvider](<#NewToolProvider>)
  - [func \(p \*ToolProvider\) BuildTooling\(descriptors \[\]\*providers.ToolDescriptor\) \(interface\{\}, error\)](<#ToolProvider.BuildTooling>)
  - [func \(p \*ToolProvider\) PredictMultimodalWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#ToolProvider.PredictMultimodalWithTools>)
  - [func \(p \*ToolProvider\) PredictStreamWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(\<\-chan providers.StreamChunk, error\)](<#ToolProvider.PredictStreamWithTools>)
  - [func \(p \*ToolProvider\) PredictWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#ToolProvider.PredictWithTools>)
- [type TranscriptionConfig](<#TranscriptionConfig>)
- [type TurnDetectionConfig](<#TurnDetectionConfig>)
- [type UsageInfo](<#UsageInfo>)


## Constants

<a name="DefaultEmbeddingModel"></a>Embedding model constants

```go
const (
    // DefaultEmbeddingModel is the default model for embeddings
    DefaultEmbeddingModel = "text-embedding-3-small"

    // EmbeddingModelAda002 is the legacy ada-002 model
    EmbeddingModelAda002 = "text-embedding-ada-002"

    // EmbeddingModel3Small is the newer small model with better performance
    EmbeddingModel3Small = "text-embedding-3-small"

    // EmbeddingModel3Large is the large model with highest quality
    EmbeddingModel3Large = "text-embedding-3-large"
)
```

<a name="RealtimeAPIEndpoint"></a>Realtime API constants

```go
const (
    // RealtimeAPIEndpoint is the base WebSocket endpoint for OpenAI Realtime API.
    RealtimeAPIEndpoint = "wss://api.openai.com/v1/realtime"

    // RealtimeBetaHeader is required for the Realtime API.
    RealtimeBetaHeader = "realtime=v1"

    // Default audio configuration for OpenAI Realtime API.
    // OpenAI Realtime uses 24kHz 16-bit PCM mono audio.
    DefaultRealtimeSampleRate = 24000
    DefaultRealtimeChannels   = 1
    DefaultRealtimeBitDepth   = 16
)
```

<a name="ParseServerEvent"></a>
## func ParseServerEvent

```go
func ParseServerEvent(data []byte) (interface{}, error)
```

ParseServerEvent parses a raw JSON message into the appropriate event type.

<a name="RealtimeStreamingCapabilities"></a>
## func RealtimeStreamingCapabilities

```go
func RealtimeStreamingCapabilities() providers.StreamingCapabilities
```

RealtimeStreamingCapabilities returns the streaming capabilities for OpenAI Realtime API.

<a name="ClientEvent"></a>
## type ClientEvent

ClientEvent is the base structure for all client events.

```go
type ClientEvent struct {
    EventID string `json:"event_id,omitempty"`
    Type    string `json:"type"`
}
```

<a name="ConversationContent"></a>
## type ConversationContent

ConversationContent represents content within a conversation item.

```go
type ConversationContent struct {
    Type       string `json:"type"` // "input_text", "input_audio", "text", "audio"
    Text       string `json:"text,omitempty"`
    Audio      string `json:"audio,omitempty"`      // Base64-encoded
    Transcript string `json:"transcript,omitempty"` // For audio content
}
```

<a name="ConversationItem"></a>
## type ConversationItem

ConversationItem represents an item in the conversation.

```go
type ConversationItem struct {
    ID        string                `json:"id,omitempty"`
    Type      string                `json:"type"` // "message", "function_call", "function_call_output"
    Status    string                `json:"status,omitempty"`
    Role      string                `json:"role,omitempty"` // "user", "assistant", "system"
    Content   []ConversationContent `json:"content,omitempty"`
    CallID    string                `json:"call_id,omitempty"`   // For function_call_output
    Output    string                `json:"output,omitempty"`    // For function_call_output
    Name      string                `json:"name,omitempty"`      // For function_call
    Arguments string                `json:"arguments,omitempty"` // For function_call
}
```

<a name="ConversationItemCreateEvent"></a>
## type ConversationItemCreateEvent

ConversationItemCreateEvent adds an item to the conversation.

```go
type ConversationItemCreateEvent struct {
    ClientEvent
    PreviousItemID string           `json:"previous_item_id,omitempty"`
    Item           ConversationItem `json:"item"`
}
```

<a name="ConversationItemCreatedEvent"></a>
## type ConversationItemCreatedEvent

ConversationItemCreatedEvent confirms an item was added.

```go
type ConversationItemCreatedEvent struct {
    ServerEvent
    PreviousItemID string           `json:"previous_item_id"`
    Item           ConversationItem `json:"item"`
}
```

<a name="ConversationItemInputAudioTranscriptionCompletedEvent"></a>
## type ConversationItemInputAudioTranscriptionCompletedEvent

ConversationItemInputAudioTranscriptionCompletedEvent provides transcription.

```go
type ConversationItemInputAudioTranscriptionCompletedEvent struct {
    ServerEvent
    ItemID       string `json:"item_id"`
    ContentIndex int    `json:"content_index"`
    Transcript   string `json:"transcript"`
}
```

<a name="ConversationItemInputAudioTranscriptionFailedEvent"></a>
## type ConversationItemInputAudioTranscriptionFailedEvent

ConversationItemInputAudioTranscriptionFailedEvent indicates transcription failed.

```go
type ConversationItemInputAudioTranscriptionFailedEvent struct {
    ServerEvent
    ItemID       string      `json:"item_id"`
    ContentIndex int         `json:"content_index"`
    Error        ErrorDetail `json:"error"`
}
```

<a name="EmbeddingOption"></a>
## type EmbeddingOption

EmbeddingOption configures the EmbeddingProvider.

```go
type EmbeddingOption func(*EmbeddingProvider)
```

<a name="WithEmbeddingAPIKey"></a>
### func WithEmbeddingAPIKey

```go
func WithEmbeddingAPIKey(key string) EmbeddingOption
```

WithEmbeddingAPIKey sets the API key explicitly.

<a name="WithEmbeddingBaseURL"></a>
### func WithEmbeddingBaseURL

```go
func WithEmbeddingBaseURL(url string) EmbeddingOption
```

WithEmbeddingBaseURL sets a custom base URL \(for Azure or proxies\).

<a name="WithEmbeddingHTTPClient"></a>
### func WithEmbeddingHTTPClient

```go
func WithEmbeddingHTTPClient(client *http.Client) EmbeddingOption
```

WithEmbeddingHTTPClient sets a custom HTTP client.

<a name="WithEmbeddingModel"></a>
### func WithEmbeddingModel

```go
func WithEmbeddingModel(model string) EmbeddingOption
```

WithEmbeddingModel sets the embedding model.

<a name="EmbeddingProvider"></a>
## type EmbeddingProvider

EmbeddingProvider implements embedding generation via OpenAI API.

```go
type EmbeddingProvider struct {
    *providers.BaseEmbeddingProvider
}
```

<a name="NewEmbeddingProvider"></a>
### func NewEmbeddingProvider

```go
func NewEmbeddingProvider(opts ...EmbeddingOption) (*EmbeddingProvider, error)
```

NewEmbeddingProvider creates an OpenAI embedding provider.

<a name="EmbeddingProvider.Embed"></a>
### func \(\*EmbeddingProvider\) Embed

```go
func (p *EmbeddingProvider) Embed(ctx context.Context, req providers.EmbeddingRequest) (providers.EmbeddingResponse, error)
```

Embed generates embeddings for the given texts.

<a name="EmbeddingProvider.EstimateCost"></a>
### func \(\*EmbeddingProvider\) EstimateCost

```go
func (p *EmbeddingProvider) EstimateCost(tokens int) float64
```

EstimateCost estimates the cost for embedding the given number of tokens.

<a name="ErrorDetail"></a>
## type ErrorDetail

ErrorDetail contains error information.

```go
type ErrorDetail struct {
    Type    string `json:"type"`
    Code    string `json:"code"`
    Message string `json:"message"`
    Param   string `json:"param,omitempty"`
    EventID string `json:"event_id,omitempty"`
}
```

<a name="ErrorEvent"></a>
## type ErrorEvent

ErrorEvent indicates an error occurred.

```go
type ErrorEvent struct {
    ServerEvent
    Error ErrorDetail `json:"error"`
}
```

<a name="InputAudioBufferAppendEvent"></a>
## type InputAudioBufferAppendEvent

InputAudioBufferAppendEvent appends audio to the input buffer.

```go
type InputAudioBufferAppendEvent struct {
    ClientEvent
    Audio string `json:"audio"` // Base64-encoded audio data
}
```

<a name="InputAudioBufferClearEvent"></a>
## type InputAudioBufferClearEvent

InputAudioBufferClearEvent clears the audio buffer.

```go
type InputAudioBufferClearEvent struct {
    ClientEvent
}
```

<a name="InputAudioBufferClearedEvent"></a>
## type InputAudioBufferClearedEvent

InputAudioBufferClearedEvent confirms audio buffer was cleared.

```go
type InputAudioBufferClearedEvent struct {
    ServerEvent
}
```

<a name="InputAudioBufferCommitEvent"></a>
## type InputAudioBufferCommitEvent

InputAudioBufferCommitEvent commits the audio buffer for processing.

```go
type InputAudioBufferCommitEvent struct {
    ClientEvent
}
```

<a name="InputAudioBufferCommittedEvent"></a>
## type InputAudioBufferCommittedEvent

InputAudioBufferCommittedEvent confirms audio buffer was committed.

```go
type InputAudioBufferCommittedEvent struct {
    ServerEvent
    PreviousItemID string `json:"previous_item_id"`
    ItemID         string `json:"item_id"`
}
```

<a name="InputAudioBufferSpeechStartedEvent"></a>
## type InputAudioBufferSpeechStartedEvent

InputAudioBufferSpeechStartedEvent indicates speech was detected.

```go
type InputAudioBufferSpeechStartedEvent struct {
    ServerEvent
    AudioStartMs int    `json:"audio_start_ms"`
    ItemID       string `json:"item_id"`
}
```

<a name="InputAudioBufferSpeechStoppedEvent"></a>
## type InputAudioBufferSpeechStoppedEvent

InputAudioBufferSpeechStoppedEvent indicates speech ended.

```go
type InputAudioBufferSpeechStoppedEvent struct {
    ServerEvent
    AudioEndMs int    `json:"audio_end_ms"`
    ItemID     string `json:"item_id"`
}
```

<a name="Provider"></a>
## type Provider

OpenAIProvider implements the Provider interface for OpenAI

```go
type Provider struct {
    providers.BaseProvider
    // contains filtered or unexported fields
}
```

<a name="NewProvider"></a>
### func NewProvider

```go
func NewProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *Provider
```

NewProvider creates a new OpenAI provider

<a name="Provider.CalculateCost"></a>
### func \(\*Provider\) CalculateCost

```go
func (p *Provider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="Provider.CreateStreamSession"></a>
### func \(\*Provider\) CreateStreamSession

```go
func (p *Provider) CreateStreamSession(ctx context.Context, req *providers.StreamingInputConfig) (providers.StreamInputSession, error)
```

CreateStreamSession creates a new bidirectional streaming session with OpenAI Realtime API.

The session supports real\-time audio input/output with the following features: \- Bidirectional audio streaming \(send and receive audio simultaneously\) \- Server\-side voice activity detection \(VAD\) for automatic turn detection \- Function/tool calling during the streaming session \- Input and output audio transcription

Audio Format: OpenAI Realtime API uses 24kHz 16\-bit PCM mono audio by default. The session automatically handles base64 encoding/decoding of audio data.

Example usage:

```
session, err := provider.CreateStreamSession(ctx, &providers.StreamingInputConfig{
    Config: types.StreamingMediaConfig{
        Type:       types.ContentTypeAudio,
        SampleRate: 24000,
        Encoding:   "pcm16",
        Channels:   1,
    },
    SystemInstruction: "You are a helpful assistant.",
})
```

<a name="Provider.GetMultimodalCapabilities"></a>
### func \(\*Provider\) GetMultimodalCapabilities

```go
func (p *Provider) GetMultimodalCapabilities() providers.MultimodalCapabilities
```

GetMultimodalCapabilities returns OpenAI's multimodal capabilities

<a name="Provider.GetStreamingCapabilities"></a>
### func \(\*Provider\) GetStreamingCapabilities

```go
func (p *Provider) GetStreamingCapabilities() providers.StreamingCapabilities
```

GetStreamingCapabilities returns detailed information about OpenAI's streaming support.

<a name="Provider.Predict"></a>
### func \(\*Provider\) Predict

```go
func (p *Provider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict sends a predict request to OpenAI

<a name="Provider.PredictMultimodal"></a>
### func \(\*Provider\) PredictMultimodal

```go
func (p *Provider) PredictMultimodal(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

PredictMultimodal performs a predict request with multimodal content

<a name="Provider.PredictMultimodalStream"></a>
### func \(\*Provider\) PredictMultimodalStream

```go
func (p *Provider) PredictMultimodalStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictMultimodalStream performs a streaming predict request with multimodal content

<a name="Provider.PredictStream"></a>
### func \(\*Provider\) PredictStream

```go
func (p *Provider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream streams a predict response from OpenAI

<a name="Provider.SupportsStreamInput"></a>
### func \(\*Provider\) SupportsStreamInput

```go
func (p *Provider) SupportsStreamInput() []string
```

SupportsStreamInput returns the media types supported for streaming input.

<a name="RateLimit"></a>
## type RateLimit

RateLimit contains rate limit details.

```go
type RateLimit struct {
    Name         string  `json:"name"`
    Limit        int     `json:"limit"`
    Remaining    int     `json:"remaining"`
    ResetSeconds float64 `json:"reset_seconds"`
}
```

<a name="RateLimitsUpdatedEvent"></a>
## type RateLimitsUpdatedEvent

RateLimitsUpdatedEvent provides rate limit information.

```go
type RateLimitsUpdatedEvent struct {
    ServerEvent
    RateLimits []RateLimit `json:"rate_limits"`
}
```

<a name="RealtimeSession"></a>
## type RealtimeSession

RealtimeSession implements StreamInputSession for OpenAI Realtime API.

```go
type RealtimeSession struct {
    // contains filtered or unexported fields
}
```

<a name="NewRealtimeSession"></a>
### func NewRealtimeSession

```go
func NewRealtimeSession(ctx context.Context, apiKey string, config *RealtimeSessionConfig) (*RealtimeSession, error)
```

NewRealtimeSession creates a new OpenAI Realtime streaming session.

<a name="RealtimeSession.CancelResponse"></a>
### func \(\*RealtimeSession\) CancelResponse

```go
func (s *RealtimeSession) CancelResponse() error
```

CancelResponse cancels an in\-progress response.

<a name="RealtimeSession.ClearAudioBuffer"></a>
### func \(\*RealtimeSession\) ClearAudioBuffer

```go
func (s *RealtimeSession) ClearAudioBuffer() error
```

ClearAudioBuffer clears the current audio buffer.

<a name="RealtimeSession.Close"></a>
### func \(\*RealtimeSession\) Close

```go
func (s *RealtimeSession) Close() error
```

Close closes the session.

<a name="RealtimeSession.CommitAudioBuffer"></a>
### func \(\*RealtimeSession\) CommitAudioBuffer

```go
func (s *RealtimeSession) CommitAudioBuffer() error
```

CommitAudioBuffer commits the current audio buffer for processing.

<a name="RealtimeSession.Done"></a>
### func \(\*RealtimeSession\) Done

```go
func (s *RealtimeSession) Done() <-chan struct{}
```

Done returns a channel that's closed when the session ends.

<a name="RealtimeSession.EndInput"></a>
### func \(\*RealtimeSession\) EndInput

```go
func (s *RealtimeSession) EndInput()
```

EndInput signals the end of user input. For OpenAI Realtime with server VAD, this commits the audio buffer. For manual turn control, this commits and triggers a response.

<a name="RealtimeSession.Error"></a>
### func \(\*RealtimeSession\) Error

```go
func (s *RealtimeSession) Error() error
```

Error returns any error that occurred during the session.

<a name="RealtimeSession.Response"></a>
### func \(\*RealtimeSession\) Response

```go
func (s *RealtimeSession) Response() <-chan providers.StreamChunk
```

Response returns the channel for receiving responses.

<a name="RealtimeSession.SendChunk"></a>
### func \(\*RealtimeSession\) SendChunk

```go
func (s *RealtimeSession) SendChunk(ctx context.Context, chunk *types.MediaChunk) error
```

SendChunk sends an audio chunk to the server.

<a name="RealtimeSession.SendSystemContext"></a>
### func \(\*RealtimeSession\) SendSystemContext

```go
func (s *RealtimeSession) SendSystemContext(ctx context.Context, text string) error
```

SendSystemContext sends a text message as context without completing the turn.

<a name="RealtimeSession.SendText"></a>
### func \(\*RealtimeSession\) SendText

```go
func (s *RealtimeSession) SendText(ctx context.Context, text string) error
```

SendText sends a text message and triggers a response.

<a name="RealtimeSession.SendToolResponse"></a>
### func \(\*RealtimeSession\) SendToolResponse

```go
func (s *RealtimeSession) SendToolResponse(ctx context.Context, toolCallID, result string) error
```

SendToolResponse sends the result of a tool execution back to the model.

<a name="RealtimeSession.SendToolResponses"></a>
### func \(\*RealtimeSession\) SendToolResponses

```go
func (s *RealtimeSession) SendToolResponses(ctx context.Context, responses []providers.ToolResponse) error
```

SendToolResponses sends multiple tool results at once \(for parallel tool calls\).

<a name="RealtimeSession.TriggerResponse"></a>
### func \(\*RealtimeSession\) TriggerResponse

```go
func (s *RealtimeSession) TriggerResponse(config *ResponseConfig) error
```

TriggerResponse manually triggers a response from the model.

<a name="RealtimeSessionConfig"></a>
## type RealtimeSessionConfig

RealtimeSessionConfig configures a new OpenAI Realtime streaming session.

```go
type RealtimeSessionConfig struct {
    // Model specifies the model to use (e.g., "gpt-4o-realtime-preview").
    Model string

    // Modalities specifies the input/output modalities.
    // Valid values: "text", "audio"
    // Default: ["text", "audio"]
    Modalities []string

    // Instructions is the system prompt for the session.
    Instructions string

    // Voice selects the voice for audio output.
    // Options: "alloy", "echo", "fable", "onyx", "nova", "shimmer"
    // Default: "alloy"
    Voice string

    // InputAudioFormat specifies the format for input audio.
    // Options: "pcm16", "g711_ulaw", "g711_alaw"
    // Default: "pcm16"
    InputAudioFormat string

    // OutputAudioFormat specifies the format for output audio.
    // Options: "pcm16", "g711_ulaw", "g711_alaw"
    // Default: "pcm16"
    OutputAudioFormat string

    // InputAudioTranscription configures transcription of input audio.
    // If nil, input transcription is disabled.
    InputAudioTranscription *TranscriptionConfig

    // TurnDetection configures server-side voice activity detection.
    // If nil, VAD is disabled and turn management is manual.
    TurnDetection *TurnDetectionConfig

    // Tools defines available functions for the session.
    Tools []RealtimeToolDefinition

    // Temperature controls randomness (0.6-1.2, default 0.8).
    Temperature float64

    // MaxResponseOutputTokens limits response length.
    // Use "inf" for unlimited, or a specific number.
    MaxResponseOutputTokens interface{}
}
```

<a name="DefaultRealtimeSessionConfig"></a>
### func DefaultRealtimeSessionConfig

```go
func DefaultRealtimeSessionConfig() RealtimeSessionConfig
```

DefaultRealtimeSessionConfig returns sensible defaults for a Realtime session.

<a name="RealtimeToolDef"></a>
## type RealtimeToolDef

RealtimeToolDef is the tool definition format for session config.

```go
type RealtimeToolDef struct {
    Type        string                 `json:"type"`
    Name        string                 `json:"name"`
    Description string                 `json:"description,omitempty"`
    Parameters  map[string]interface{} `json:"parameters,omitempty"`
}
```

<a name="RealtimeToolDefinition"></a>
## type RealtimeToolDefinition

RealtimeToolDefinition defines a function available in the session.

```go
type RealtimeToolDefinition struct {
    // Type is always "function" for function tools.
    Type string `json:"type"`

    // Name is the function name.
    Name string `json:"name"`

    // Description explains what the function does.
    Description string `json:"description,omitempty"`

    // Parameters is the JSON Schema for function parameters.
    Parameters map[string]interface{} `json:"parameters,omitempty"`
}
```

<a name="RealtimeWebSocket"></a>
## type RealtimeWebSocket

RealtimeWebSocket manages WebSocket connections for OpenAI Realtime API.

```go
type RealtimeWebSocket struct {
    // contains filtered or unexported fields
}
```

<a name="NewRealtimeWebSocket"></a>
### func NewRealtimeWebSocket

```go
func NewRealtimeWebSocket(model, apiKey string) *RealtimeWebSocket
```

NewRealtimeWebSocket creates a new WebSocket manager for OpenAI Realtime API.

<a name="RealtimeWebSocket.Close"></a>
### func \(\*RealtimeWebSocket\) Close

```go
func (ws *RealtimeWebSocket) Close() error
```

Close closes the WebSocket connection gracefully.

<a name="RealtimeWebSocket.Connect"></a>
### func \(\*RealtimeWebSocket\) Connect

```go
func (ws *RealtimeWebSocket) Connect(ctx context.Context) error
```

Connect establishes a WebSocket connection to the OpenAI Realtime API.

<a name="RealtimeWebSocket.ConnectWithRetry"></a>
### func \(\*RealtimeWebSocket\) ConnectWithRetry

```go
func (ws *RealtimeWebSocket) ConnectWithRetry(ctx context.Context) error
```

ConnectWithRetry attempts to connect with exponential backoff.

<a name="RealtimeWebSocket.IsClosed"></a>
### func \(\*RealtimeWebSocket\) IsClosed

```go
func (ws *RealtimeWebSocket) IsClosed() bool
```

IsClosed returns whether the WebSocket is closed.

<a name="RealtimeWebSocket.Receive"></a>
### func \(\*RealtimeWebSocket\) Receive

```go
func (ws *RealtimeWebSocket) Receive(ctx context.Context) ([]byte, error)
```

Receive reads a message from the WebSocket with context support.

<a name="RealtimeWebSocket.ReceiveLoop"></a>
### func \(\*RealtimeWebSocket\) ReceiveLoop

```go
func (ws *RealtimeWebSocket) ReceiveLoop(ctx context.Context, msgCh chan<- []byte) error
```

ReceiveLoop continuously reads messages and sends them to the provided channel. It returns when the connection is closed or an error occurs.

<a name="RealtimeWebSocket.Send"></a>
### func \(\*RealtimeWebSocket\) Send

```go
func (ws *RealtimeWebSocket) Send(msg interface{}) error
```

Send sends a message to the WebSocket.

<a name="RealtimeWebSocket.StartHeartbeat"></a>
### func \(\*RealtimeWebSocket\) StartHeartbeat

```go
func (ws *RealtimeWebSocket) StartHeartbeat(ctx context.Context, interval time.Duration)
```

StartHeartbeat starts a goroutine that sends ping messages periodically.

<a name="ResponseAudioDeltaEvent"></a>
## type ResponseAudioDeltaEvent

ResponseAudioDeltaEvent provides streaming audio.

```go
type ResponseAudioDeltaEvent struct {
    ServerEvent
    ResponseID   string `json:"response_id"`
    ItemID       string `json:"item_id"`
    OutputIndex  int    `json:"output_index"`
    ContentIndex int    `json:"content_index"`
    Delta        string `json:"delta"` // Base64-encoded audio
}
```

<a name="ResponseAudioDoneEvent"></a>
## type ResponseAudioDoneEvent

ResponseAudioDoneEvent indicates audio streaming completed.

```go
type ResponseAudioDoneEvent struct {
    ServerEvent
    ResponseID   string `json:"response_id"`
    ItemID       string `json:"item_id"`
    OutputIndex  int    `json:"output_index"`
    ContentIndex int    `json:"content_index"`
}
```

<a name="ResponseAudioTranscriptDeltaEvent"></a>
## type ResponseAudioTranscriptDeltaEvent

ResponseAudioTranscriptDeltaEvent provides streaming transcript.

```go
type ResponseAudioTranscriptDeltaEvent struct {
    ServerEvent
    ResponseID   string `json:"response_id"`
    ItemID       string `json:"item_id"`
    OutputIndex  int    `json:"output_index"`
    ContentIndex int    `json:"content_index"`
    Delta        string `json:"delta"`
}
```

<a name="ResponseAudioTranscriptDoneEvent"></a>
## type ResponseAudioTranscriptDoneEvent

ResponseAudioTranscriptDoneEvent indicates transcript completed.

```go
type ResponseAudioTranscriptDoneEvent struct {
    ServerEvent
    ResponseID   string `json:"response_id"`
    ItemID       string `json:"item_id"`
    OutputIndex  int    `json:"output_index"`
    ContentIndex int    `json:"content_index"`
    Transcript   string `json:"transcript"`
}
```

<a name="ResponseCancelEvent"></a>
## type ResponseCancelEvent

ResponseCancelEvent cancels an in\-progress response.

```go
type ResponseCancelEvent struct {
    ClientEvent
}
```

<a name="ResponseConfig"></a>
## type ResponseConfig

ResponseConfig configures a response.

```go
type ResponseConfig struct {
    Modalities        []string          `json:"modalities,omitempty"`
    Instructions      string            `json:"instructions,omitempty"`
    Voice             string            `json:"voice,omitempty"`
    OutputAudioFormat string            `json:"output_audio_format,omitempty"`
    Tools             []RealtimeToolDef `json:"tools,omitempty"`
    ToolChoice        interface{}       `json:"tool_choice,omitempty"`
    Temperature       float64           `json:"temperature,omitempty"`
    MaxOutputTokens   interface{}       `json:"max_output_tokens,omitempty"`
}
```

<a name="ResponseContentPartAddedEvent"></a>
## type ResponseContentPartAddedEvent

ResponseContentPartAddedEvent indicates content was added.

```go
type ResponseContentPartAddedEvent struct {
    ServerEvent
    ResponseID   string              `json:"response_id"`
    ItemID       string              `json:"item_id"`
    OutputIndex  int                 `json:"output_index"`
    ContentIndex int                 `json:"content_index"`
    Part         ConversationContent `json:"part"`
}
```

<a name="ResponseContentPartDoneEvent"></a>
## type ResponseContentPartDoneEvent

ResponseContentPartDoneEvent indicates content part completed.

```go
type ResponseContentPartDoneEvent struct {
    ServerEvent
    ResponseID   string              `json:"response_id"`
    ItemID       string              `json:"item_id"`
    OutputIndex  int                 `json:"output_index"`
    ContentIndex int                 `json:"content_index"`
    Part         ConversationContent `json:"part"`
}
```

<a name="ResponseCreateEvent"></a>
## type ResponseCreateEvent

ResponseCreateEvent triggers a response from the model.

```go
type ResponseCreateEvent struct {
    ClientEvent
    Response *ResponseConfig `json:"response,omitempty"`
}
```

<a name="ResponseCreatedEvent"></a>
## type ResponseCreatedEvent

ResponseCreatedEvent indicates a response is starting.

```go
type ResponseCreatedEvent struct {
    ServerEvent
    Response ResponseInfo `json:"response"`
}
```

<a name="ResponseDoneEvent"></a>
## type ResponseDoneEvent

ResponseDoneEvent indicates a response completed.

```go
type ResponseDoneEvent struct {
    ServerEvent
    Response ResponseInfo `json:"response"`
}
```

<a name="ResponseFunctionCallArgumentsDeltaEvent"></a>
## type ResponseFunctionCallArgumentsDeltaEvent

ResponseFunctionCallArgumentsDeltaEvent provides streaming function args.

```go
type ResponseFunctionCallArgumentsDeltaEvent struct {
    ServerEvent
    ResponseID  string `json:"response_id"`
    ItemID      string `json:"item_id"`
    OutputIndex int    `json:"output_index"`
    CallID      string `json:"call_id"`
    Delta       string `json:"delta"`
}
```

<a name="ResponseFunctionCallArgumentsDoneEvent"></a>
## type ResponseFunctionCallArgumentsDoneEvent

ResponseFunctionCallArgumentsDoneEvent indicates function args completed.

```go
type ResponseFunctionCallArgumentsDoneEvent struct {
    ServerEvent
    ResponseID  string `json:"response_id"`
    ItemID      string `json:"item_id"`
    OutputIndex int    `json:"output_index"`
    CallID      string `json:"call_id"`
    Name        string `json:"name"`
    Arguments   string `json:"arguments"`
}
```

<a name="ResponseInfo"></a>
## type ResponseInfo

ResponseInfo contains response details.

```go
type ResponseInfo struct {
    ID            string             `json:"id"`
    Object        string             `json:"object"`
    Status        string             `json:"status"`
    StatusDetails interface{}        `json:"status_details"`
    Output        []ConversationItem `json:"output"`
    Usage         *UsageInfo         `json:"usage"`
}
```

<a name="ResponseOutputItemAddedEvent"></a>
## type ResponseOutputItemAddedEvent

ResponseOutputItemAddedEvent indicates an output item was added.

```go
type ResponseOutputItemAddedEvent struct {
    ServerEvent
    ResponseID  string           `json:"response_id"`
    OutputIndex int              `json:"output_index"`
    Item        ConversationItem `json:"item"`
}
```

<a name="ResponseOutputItemDoneEvent"></a>
## type ResponseOutputItemDoneEvent

ResponseOutputItemDoneEvent indicates an output item completed.

```go
type ResponseOutputItemDoneEvent struct {
    ServerEvent
    ResponseID  string           `json:"response_id"`
    OutputIndex int              `json:"output_index"`
    Item        ConversationItem `json:"item"`
}
```

<a name="ResponseTextDeltaEvent"></a>
## type ResponseTextDeltaEvent

ResponseTextDeltaEvent provides streaming text.

```go
type ResponseTextDeltaEvent struct {
    ServerEvent
    ResponseID   string `json:"response_id"`
    ItemID       string `json:"item_id"`
    OutputIndex  int    `json:"output_index"`
    ContentIndex int    `json:"content_index"`
    Delta        string `json:"delta"`
}
```

<a name="ResponseTextDoneEvent"></a>
## type ResponseTextDoneEvent

ResponseTextDoneEvent indicates text streaming completed.

```go
type ResponseTextDoneEvent struct {
    ServerEvent
    ResponseID   string `json:"response_id"`
    ItemID       string `json:"item_id"`
    OutputIndex  int    `json:"output_index"`
    ContentIndex int    `json:"content_index"`
    Text         string `json:"text"`
}
```

<a name="ServerEvent"></a>
## type ServerEvent

ServerEvent is the base structure for all server events.

```go
type ServerEvent struct {
    EventID string `json:"event_id"`
    Type    string `json:"type"`
}
```

<a name="SessionConfig"></a>
## type SessionConfig

SessionConfig is the session configuration sent in session.update. Note: TurnDetection uses a pointer without omitempty so we can explicitly send null to disable VAD. Omitting it causes OpenAI to use default \(server\_vad\).

```go
type SessionConfig struct {
    Modalities              []string             `json:"modalities,omitempty"`
    Instructions            string               `json:"instructions,omitempty"`
    Voice                   string               `json:"voice,omitempty"`
    InputAudioFormat        string               `json:"input_audio_format,omitempty"`
    OutputAudioFormat       string               `json:"output_audio_format,omitempty"`
    InputAudioTranscription *TranscriptionConfig `json:"input_audio_transcription,omitempty"`
    TurnDetection           *TurnDetectionConfig `json:"turn_detection"` // No omitempty - null disables VAD
    Tools                   []RealtimeToolDef    `json:"tools,omitempty"`
    ToolChoice              interface{}          `json:"tool_choice,omitempty"`
    Temperature             float64              `json:"temperature,omitempty"`
    MaxResponseOutputTokens interface{}          `json:"max_response_output_tokens,omitempty"`
}
```

<a name="SessionCreatedEvent"></a>
## type SessionCreatedEvent

SessionCreatedEvent is sent when the session is established.

```go
type SessionCreatedEvent struct {
    ServerEvent
    Session SessionInfo `json:"session"`
}
```

<a name="SessionInfo"></a>
## type SessionInfo

SessionInfo contains session details.

```go
type SessionInfo struct {
    ID                      string               `json:"id"`
    Object                  string               `json:"object"`
    Model                   string               `json:"model"`
    Modalities              []string             `json:"modalities"`
    Instructions            string               `json:"instructions"`
    Voice                   string               `json:"voice"`
    InputAudioFormat        string               `json:"input_audio_format"`
    OutputAudioFormat       string               `json:"output_audio_format"`
    InputAudioTranscription *TranscriptionConfig `json:"input_audio_transcription"`
    TurnDetection           *TurnDetectionConfig `json:"turn_detection"`
    Tools                   []RealtimeToolDef    `json:"tools"`
    Temperature             float64              `json:"temperature"`
    MaxResponseOutputTokens interface{}          `json:"max_response_output_tokens"`
}
```

<a name="SessionUpdateEvent"></a>
## type SessionUpdateEvent

SessionUpdateEvent updates session configuration.

```go
type SessionUpdateEvent struct {
    ClientEvent
    Session SessionConfig `json:"session"`
}
```

<a name="SessionUpdatedEvent"></a>
## type SessionUpdatedEvent

SessionUpdatedEvent confirms a session update.

```go
type SessionUpdatedEvent struct {
    ServerEvent
    Session SessionInfo `json:"session"`
}
```

<a name="ToolProvider"></a>
## type ToolProvider

ToolProvider extends OpenAIProvider with tool support

```go
type ToolProvider struct {
    *Provider
}
```

<a name="NewToolProvider"></a>
### func NewToolProvider

```go
func NewToolProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool, additionalConfig map[string]interface{}) *ToolProvider
```

NewToolProvider creates a new OpenAI provider with tool support

<a name="ToolProvider.BuildTooling"></a>
### func \(\*ToolProvider\) BuildTooling

```go
func (p *ToolProvider) BuildTooling(descriptors []*providers.ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to OpenAI format

<a name="ToolProvider.PredictMultimodalWithTools"></a>
### func \(\*ToolProvider\) PredictMultimodalWithTools

```go
func (p *ToolProvider) PredictMultimodalWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictMultimodalWithTools implements providers.MultimodalToolSupport interface for ToolProvider This allows combining multimodal content \(images\) with tool calls in a single request

<a name="ToolProvider.PredictStreamWithTools"></a>
### func \(\*ToolProvider\) PredictStreamWithTools

```go
func (p *ToolProvider) PredictStreamWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (<-chan providers.StreamChunk, error)
```

PredictStreamWithTools performs a streaming predict request with tool support

<a name="ToolProvider.PredictWithTools"></a>
### func \(\*ToolProvider\) PredictWithTools

```go
func (p *ToolProvider) PredictWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictWithTools performs a prediction request with tool support

<a name="TranscriptionConfig"></a>
## type TranscriptionConfig

TranscriptionConfig configures audio transcription.

```go
type TranscriptionConfig struct {
    // Model specifies the transcription model.
    // Default: "whisper-1"
    Model string `json:"model,omitempty"`
}
```

<a name="TurnDetectionConfig"></a>
## type TurnDetectionConfig

TurnDetectionConfig configures server\-side VAD.

```go
type TurnDetectionConfig struct {
    // Type specifies the VAD type.
    // Options: "server_vad", "semantic_vad"
    Type string `json:"type"`

    // Threshold is the activation threshold (0.0-1.0).
    // Default: 0.5
    Threshold float64 `json:"threshold,omitempty"`

    // PrefixPaddingMs is audio padding before speech in milliseconds.
    // Default: 300
    PrefixPaddingMs int `json:"prefix_padding_ms,omitempty"`

    // SilenceDurationMs is silence duration to detect end of speech.
    // Default: 500
    SilenceDurationMs int `json:"silence_duration_ms,omitempty"`

    // CreateResponse determines if a response is automatically created
    // when speech ends. Default: true
    CreateResponse bool `json:"create_response,omitempty"`
}
```

<a name="UsageInfo"></a>
## type UsageInfo

UsageInfo contains token usage information.

```go
type UsageInfo struct {
    TotalTokens       int `json:"total_tokens"`
    InputTokens       int `json:"input_tokens"`
    OutputTokens      int `json:"output_tokens"`
    InputTokenDetails struct {
        CachedTokens int `json:"cached_tokens"`
        TextTokens   int `json:"text_tokens"`
        AudioTokens  int `json:"audio_tokens"`
    }   `json:"input_token_details"`
    OutputTokenDetails struct {
        TextTokens  int `json:"text_tokens"`
        AudioTokens int `json:"audio_tokens"`
    }   `json:"output_token_details"`
}
```

# voyageai

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/voyageai"
```

Package voyageai provides embedding generation via the Voyage AI API. Voyage AI is recommended by Anthropic for embeddings with Claude\-based systems.

## Index

- [Constants](<#constants>)
- [type EmbeddingOption](<#EmbeddingOption>)
  - [func WithAPIKey\(key string\) EmbeddingOption](<#WithAPIKey>)
  - [func WithBaseURL\(url string\) EmbeddingOption](<#WithBaseURL>)
  - [func WithDimensions\(dims int\) EmbeddingOption](<#WithDimensions>)
  - [func WithHTTPClient\(client \*http.Client\) EmbeddingOption](<#WithHTTPClient>)
  - [func WithInputType\(inputType string\) EmbeddingOption](<#WithInputType>)
  - [func WithModel\(model string\) EmbeddingOption](<#WithModel>)
- [type EmbeddingProvider](<#EmbeddingProvider>)
  - [func NewEmbeddingProvider\(opts ...EmbeddingOption\) \(\*EmbeddingProvider, error\)](<#NewEmbeddingProvider>)
  - [func \(p \*EmbeddingProvider\) Embed\(ctx context.Context, req providers.EmbeddingRequest\) \(providers.EmbeddingResponse, error\)](<#EmbeddingProvider.Embed>)


## Constants

<a name="DefaultModel"></a>Model constants for Voyage AI embeddings.

```go
const (
    // DefaultModel is the recommended general-purpose model.
    DefaultModel = "voyage-3.5"

    // ModelVoyage35 is the latest general-purpose model for best performance.
    ModelVoyage35 = "voyage-3.5"

    // ModelVoyage35Lite is an efficient model with lower latency.
    ModelVoyage35Lite = "voyage-3.5-lite"

    // ModelVoyage3Large is a high-capacity model for complex tasks.
    ModelVoyage3Large = "voyage-3-large"

    // ModelVoyageCode3 is optimized for code embeddings.
    ModelVoyageCode3 = "voyage-code-3"

    // ModelVoyageFinance2 is optimized for finance domain.
    ModelVoyageFinance2 = "voyage-finance-2"

    // ModelVoyageLaw2 is optimized for legal domain.
    ModelVoyageLaw2 = "voyage-law-2"
)
```

<a name="Dimensions2048"></a>Dimension constants for Voyage AI embeddings.

```go
const (
    Dimensions2048 = 2048
    Dimensions1024 = 1024 // Default
    Dimensions512  = 512
    Dimensions256  = 256
)
```

<a name="InputTypeQuery"></a>InputType constants for retrieval optimization.

```go
const (
    // InputTypeQuery indicates the input is a search query.
    InputTypeQuery = "query"

    // InputTypeDocument indicates the input is a document to be indexed.
    InputTypeDocument = "document"
)
```

<a name="EmbeddingOption"></a>
## type EmbeddingOption

EmbeddingOption configures the EmbeddingProvider.

```go
type EmbeddingOption func(*EmbeddingProvider)
```

<a name="WithAPIKey"></a>
### func WithAPIKey

```go
func WithAPIKey(key string) EmbeddingOption
```

WithAPIKey sets the API key explicitly.

<a name="WithBaseURL"></a>
### func WithBaseURL

```go
func WithBaseURL(url string) EmbeddingOption
```

WithBaseURL sets a custom base URL.

<a name="WithDimensions"></a>
### func WithDimensions

```go
func WithDimensions(dims int) EmbeddingOption
```

WithDimensions sets the output embedding dimensions.

<a name="WithHTTPClient"></a>
### func WithHTTPClient

```go
func WithHTTPClient(client *http.Client) EmbeddingOption
```

WithHTTPClient sets a custom HTTP client.

<a name="WithInputType"></a>
### func WithInputType

```go
func WithInputType(inputType string) EmbeddingOption
```

WithInputType sets the input type for retrieval optimization. Use "query" for search queries and "document" for documents to be indexed.

<a name="WithModel"></a>
### func WithModel

```go
func WithModel(model string) EmbeddingOption
```

WithModel sets the embedding model.

<a name="EmbeddingProvider"></a>
## type EmbeddingProvider

EmbeddingProvider implements embedding generation via Voyage AI API.

```go
type EmbeddingProvider struct {
    *providers.BaseEmbeddingProvider
    // contains filtered or unexported fields
}
```

<a name="NewEmbeddingProvider"></a>
### func NewEmbeddingProvider

```go
func NewEmbeddingProvider(opts ...EmbeddingOption) (*EmbeddingProvider, error)
```

NewEmbeddingProvider creates a Voyage AI embedding provider.

<a name="EmbeddingProvider.Embed"></a>
### func \(\*EmbeddingProvider\) Embed

```go
func (p *EmbeddingProvider) Embed(ctx context.Context, req providers.EmbeddingRequest) (providers.EmbeddingResponse, error)
```

Embed generates embeddings for the given texts.

# local

```go
import "github.com/AltairaLabs/PromptKit/runtime/storage/local"
```

Package local provides local filesystem\-based storage implementation.

## Index

- [type FileStore](<#FileStore>)
  - [func NewFileStore\(config FileStoreConfig\) \(\*FileStore, error\)](<#NewFileStore>)
  - [func \(fs \*FileStore\) DeleteMedia\(ctx context.Context, reference storage.Reference\) error](<#FileStore.DeleteMedia>)
  - [func \(fs \*FileStore\) GetURL\(ctx context.Context, reference storage.Reference, expiry time.Duration\) \(string, error\)](<#FileStore.GetURL>)
  - [func \(fs \*FileStore\) RetrieveMedia\(ctx context.Context, reference storage.Reference\) \(\*types.MediaContent, error\)](<#FileStore.RetrieveMedia>)
  - [func \(fs \*FileStore\) StoreMedia\(ctx context.Context, content \*types.MediaContent, metadata \*storage.MediaMetadata\) \(storage.Reference, error\)](<#FileStore.StoreMedia>)
- [type FileStoreConfig](<#FileStoreConfig>)


<a name="FileStore"></a>
## type FileStore

FileStore implements MediaStorageService using local filesystem storage.

```go
type FileStore struct {
    // contains filtered or unexported fields
}
```

<a name="NewFileStore"></a>
### func NewFileStore

```go
func NewFileStore(config FileStoreConfig) (*FileStore, error)
```

NewFileStore creates a new local filesystem storage backend.

<a name="FileStore.DeleteMedia"></a>
### func \(\*FileStore\) DeleteMedia

```go
func (fs *FileStore) DeleteMedia(ctx context.Context, reference storage.Reference) error
```

DeleteMedia implements MediaStorageService.DeleteMedia

<a name="FileStore.GetURL"></a>
### func \(\*FileStore\) GetURL

```go
func (fs *FileStore) GetURL(ctx context.Context, reference storage.Reference, expiry time.Duration) (string, error)
```

GetURL implements MediaStorageService.GetURL

<a name="FileStore.RetrieveMedia"></a>
### func \(\*FileStore\) RetrieveMedia

```go
func (fs *FileStore) RetrieveMedia(ctx context.Context, reference storage.Reference) (*types.MediaContent, error)
```

RetrieveMedia implements MediaStorageService.RetrieveMedia

<a name="FileStore.StoreMedia"></a>
### func \(\*FileStore\) StoreMedia

```go
func (fs *FileStore) StoreMedia(ctx context.Context, content *types.MediaContent, metadata *storage.MediaMetadata) (storage.Reference, error)
```

StoreMedia implements MediaStorageService.StoreMedia

<a name="FileStoreConfig"></a>
## type FileStoreConfig

FileStoreConfig configures the local filesystem storage backend.

```go
type FileStoreConfig struct {
    // BaseDir is the root directory for media storage
    BaseDir string

    // Organization determines how files are organized in directories
    Organization storage.OrganizationMode

    // EnableDeduplication enables content-based deduplication using SHA-256 hashing
    EnableDeduplication bool

    // DefaultPolicy is the default retention policy to apply to new media
    DefaultPolicy string
}
```

# policy

```go
import "github.com/AltairaLabs/PromptKit/runtime/storage/policy"
```

Package policy provides storage retention and cleanup policy management.

## Index

- [func ParsePolicyName\(name string\) \(string, time.Duration, error\)](<#ParsePolicyName>)
- [type Config](<#Config>)
  - [func \(p \*Config\) Validate\(\) error](<#Config.Validate>)
- [type Metadata](<#Metadata>)
- [type TimeBasedPolicyHandler](<#TimeBasedPolicyHandler>)
  - [func NewTimeBasedPolicyHandler\(enforcementInterval time.Duration\) \*TimeBasedPolicyHandler](<#NewTimeBasedPolicyHandler>)
  - [func \(h \*TimeBasedPolicyHandler\) ApplyPolicy\(ctx context.Context, metadata \*storage.MediaMetadata\) error](<#TimeBasedPolicyHandler.ApplyPolicy>)
  - [func \(h \*TimeBasedPolicyHandler\) EnforcePolicy\(ctx context.Context, baseDir string\) error](<#TimeBasedPolicyHandler.EnforcePolicy>)
  - [func \(h \*TimeBasedPolicyHandler\) RegisterPolicy\(policy Config\) error](<#TimeBasedPolicyHandler.RegisterPolicy>)
  - [func \(h \*TimeBasedPolicyHandler\) StartEnforcement\(ctx context.Context, baseDir string\)](<#TimeBasedPolicyHandler.StartEnforcement>)
  - [func \(h \*TimeBasedPolicyHandler\) Stop\(\)](<#TimeBasedPolicyHandler.Stop>)


<a name="ParsePolicyName"></a>
## func ParsePolicyName

```go
func ParsePolicyName(name string) (string, time.Duration, error)
```

ParsePolicyName extracts policy type and parameters from a policy name. Supported formats:

- "delete\-after\-Xmin" \- Delete after X minutes
- "retain\-Xdays" \- Retain for X days
- "retain\-Xhours" \- Retain for X hours

Returns \(policyType, duration, error\)

<a name="Config"></a>
## type Config

PolicyConfig defines a retention policy for media storage. Policies control how long media should be retained and when it should be deleted.

```go
type Config struct {
    // Name is a unique identifier for this policy (e.g., "delete-after-5min", "retain-30days")
    Name string `json:"name" yaml:"name"`

    // Description provides human-readable documentation for this policy
    Description string `json:"description,omitempty" yaml:"description,omitempty"`

    // Rules contains policy-specific configuration (e.g., retention duration)
    Rules map[string]interface{} `json:"rules,omitempty" yaml:"rules,omitempty"`
}
```

<a name="Config.Validate"></a>
### func \(\*Config\) Validate

```go
func (p *Config) Validate() error
```

Validate checks if a policy configuration is valid.

<a name="Metadata"></a>
## type Metadata

PolicyMetadata stores policy information in .meta files alongside media. This metadata is used by the enforcement system to determine when to delete files.

```go
type Metadata struct {
    // PolicyName identifies the policy applied to this media
    PolicyName string `json:"policy_name"`

    // ExpiresAt is when this media should be deleted (nil = never expires)
    ExpiresAt *time.Time `json:"expires_at,omitempty"`

    // CreatedAt is when the policy was applied
    CreatedAt time.Time `json:"created_at"`
}
```

<a name="TimeBasedPolicyHandler"></a>
## type TimeBasedPolicyHandler

TimeBasedPolicyHandler implements PolicyHandler for time\-based retention policies. It applies expiration times to media based on policy names and enforces deletion of expired media through background scanning.

```go
type TimeBasedPolicyHandler struct {
    // contains filtered or unexported fields
}
```

<a name="NewTimeBasedPolicyHandler"></a>
### func NewTimeBasedPolicyHandler

```go
func NewTimeBasedPolicyHandler(enforcementInterval time.Duration) *TimeBasedPolicyHandler
```

NewTimeBasedPolicyHandler creates a new time\-based policy handler.

<a name="TimeBasedPolicyHandler.ApplyPolicy"></a>
### func \(\*TimeBasedPolicyHandler\) ApplyPolicy

```go
func (h *TimeBasedPolicyHandler) ApplyPolicy(ctx context.Context, metadata *storage.MediaMetadata) error
```

ApplyPolicy implements storage.PolicyHandler.ApplyPolicy

<a name="TimeBasedPolicyHandler.EnforcePolicy"></a>
### func \(\*TimeBasedPolicyHandler\) EnforcePolicy

```go
func (h *TimeBasedPolicyHandler) EnforcePolicy(ctx context.Context, baseDir string) error
```

EnforcePolicy implements storage.PolicyHandler.EnforcePolicy

<a name="TimeBasedPolicyHandler.RegisterPolicy"></a>
### func \(\*TimeBasedPolicyHandler\) RegisterPolicy

```go
func (h *TimeBasedPolicyHandler) RegisterPolicy(policy Config) error
```

RegisterPolicy adds a policy configuration to the handler.

<a name="TimeBasedPolicyHandler.StartEnforcement"></a>
### func \(\*TimeBasedPolicyHandler\) StartEnforcement

```go
func (h *TimeBasedPolicyHandler) StartEnforcement(ctx context.Context, baseDir string)
```

StartEnforcement starts a background goroutine that periodically enforces policies.

<a name="TimeBasedPolicyHandler.Stop"></a>
### func \(\*TimeBasedPolicyHandler\) Stop

```go
func (h *TimeBasedPolicyHandler) Stop()
```

Stop signals the enforcement goroutine to stop and waits for it to finish.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
