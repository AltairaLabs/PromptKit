---
layout: page
title: "Runtime API Reference"
permalink: /docs/api/runtime/
nav_order: 3
---
<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# logger

```go
import "github.com/AltairaLabs/PromptKit/runtime/logger"
```

Package logger provides structured logging with automatic PII redaction.

This package wraps Go's standard log/slog with convenience functions for:

- LLM API call logging \(requests, responses, errors\)
- Tool execution logging
- Automatic API key and sensitive data redaction
- Contextual logging with request tracing
- Level\-based verbosity control

All exported functions use the global DefaultLogger which can be configured for different output formats and log levels.

## Index

- [Variables](<#variables>)
- [func APIRequest\(provider, method, url string, headers map\[string\]string, body interface\{\}\)](<#APIRequest>)
- [func APIResponse\(provider string, statusCode int, body string, err error\)](<#APIResponse>)
- [func Debug\(msg string, args ...any\)](<#Debug>)
- [func DebugContext\(ctx context.Context, msg string, args ...any\)](<#DebugContext>)
- [func Error\(msg string, args ...any\)](<#Error>)
- [func ErrorContext\(ctx context.Context, msg string, args ...any\)](<#ErrorContext>)
- [func Info\(msg string, args ...any\)](<#Info>)
- [func InfoContext\(ctx context.Context, msg string, args ...any\)](<#InfoContext>)
- [func LLMCall\(provider, role string, messages int, temperature float64, attrs ...any\)](<#LLMCall>)
- [func LLMError\(provider, role string, err error, attrs ...any\)](<#LLMError>)
- [func LLMResponse\(provider, role string, tokensIn, tokensOut int, cost float64, attrs ...any\)](<#LLMResponse>)
- [func RedactSensitiveData\(input string\) string](<#RedactSensitiveData>)
- [func SetLevel\(level slog.Level\)](<#SetLevel>)
- [func SetVerbose\(verbose bool\)](<#SetVerbose>)
- [func ToolCall\(provider string, messages, tools int, choice string, attrs ...any\)](<#ToolCall>)
- [func ToolResponse\(provider string, tokensIn, tokensOut, toolCalls int, cost float64, attrs ...any\)](<#ToolResponse>)
- [func Warn\(msg string, args ...any\)](<#Warn>)
- [func WarnContext\(ctx context.Context, msg string, args ...any\)](<#WarnContext>)


## Variables

<a name="DefaultLogger"></a>

```go
var (
    // DefaultLogger is the global structured logger instance.
    // It is safe for concurrent use and initialized with slog.LevelInfo by default.
    DefaultLogger *slog.Logger
)
```

<a name="APIRequest"></a>
## func APIRequest

```go
func APIRequest(provider, method, url string, headers map[string]string, body interface{})
```

APIRequest logs HTTP API request details at debug level with automatic PII redaction. This function is a no\-op when debug logging is disabled for performance.

Parameters:

- provider: The API provider name \(e.g., "OpenAI", "Anthropic"\)
- method: HTTP method \(GET, POST, etc.\)
- url: Request URL \(will be redacted for sensitive data\)
- headers: HTTP headers map \(will be redacted\)
- body: Request body \(will be marshaled to JSON and redacted\)

Sensitive data in URL, headers, and body are automatically redacted.

<a name="APIResponse"></a>
## func APIResponse

```go
func APIResponse(provider string, statusCode int, body string, err error)
```

APIResponse logs HTTP API response details at debug level with automatic PII redaction. This function is a no\-op when debug logging is disabled for performance.

Parameters:

- provider: The API provider name
- statusCode: HTTP status code
- body: Response body as string \(will be redacted\)
- err: Error if the request failed \(takes precedence over body logging\)

Response bodies are attempted to be parsed as JSON for pretty formatting. Status codes are logged with emoji indicators: ðŸŸ¢ \(2xx\), ðŸŸ¡ \(3xx\), ðŸ”´ \(4xx/5xx\).

<a name="Debug"></a>
## func Debug

```go
func Debug(msg string, args ...any)
```

Debug logs a debug\-level message with structured attributes. Debug messages are only output when the log level is set to LevelDebug or lower.

<a name="DebugContext"></a>
## func DebugContext

```go
func DebugContext(ctx context.Context, msg string, args ...any)
```

DebugContext logs a debug message with context and structured attributes.

<a name="Error"></a>
## func Error

```go
func Error(msg string, args ...any)
```

Error logs an error message with structured attributes. Use for errors that affect operation but don't cause complete failure.

<a name="ErrorContext"></a>
## func ErrorContext

```go
func ErrorContext(ctx context.Context, msg string, args ...any)
```

ErrorContext logs an error message with context and structured attributes.

<a name="Info"></a>
## func Info

```go
func Info(msg string, args ...any)
```

Info logs an informational message with structured key\-value attributes. Args should be provided in key\-value pairs: key1, value1, key2, value2, ...

<a name="InfoContext"></a>
## func InfoContext

```go
func InfoContext(ctx context.Context, msg string, args ...any)
```

InfoContext logs an informational message with context and structured attributes. The context can be used for request tracing and cancellation.

<a name="LLMCall"></a>
## func LLMCall

```go
func LLMCall(provider, role string, messages int, temperature float64, attrs ...any)
```

LLMCall logs an LLM API call with structured fields for observability. Additional attributes can be passed as key\-value pairs after the required parameters.

<a name="LLMError"></a>
## func LLMError

```go
func LLMError(provider, role string, err error, attrs ...any)
```

LLMError logs an LLM API error for debugging and monitoring.

<a name="LLMResponse"></a>
## func LLMResponse

```go
func LLMResponse(provider, role string, tokensIn, tokensOut int, cost float64, attrs ...any)
```

LLMResponse logs an LLM API response with token usage and cost tracking. Cost should be provided in USD \(e.g., 0.0001 for $0.0001\).

<a name="RedactSensitiveData"></a>
## func RedactSensitiveData

```go
func RedactSensitiveData(input string) string
```

RedactSensitiveData removes API keys and other sensitive information from strings. It replaces matched patterns with a redacted form that preserves the first few characters for debugging while hiding the sensitive portion.

Supported patterns:

- OpenAI keys \(sk\-...\): Shows first 4 chars
- Google keys \(AIza...\): Shows first 4 chars
- Bearer tokens: Shows only "Bearer \[REDACTED\]"

This function is safe for concurrent use as it only reads from the compiled patterns.

<a name="SetLevel"></a>
## func SetLevel

```go
func SetLevel(level slog.Level)
```

SetLevel changes the logging level for all subsequent log operations. This is safe for concurrent use as it replaces the entire logger instance.

<a name="SetVerbose"></a>
## func SetVerbose

```go
func SetVerbose(verbose bool)
```

SetVerbose enables debug\-level logging when verbose is true, otherwise sets info\-level. This is a convenience wrapper around SetLevel for command\-line verbose flags.

<a name="ToolCall"></a>
## func ToolCall

```go
func ToolCall(provider string, messages, tools int, choice string, attrs ...any)
```

ToolCall logs a tool execution request with context about available tools. The choice parameter indicates the tool selection mode \(e.g., "auto", "required", "none"\).

<a name="ToolResponse"></a>
## func ToolResponse

```go
func ToolResponse(provider string, tokensIn, tokensOut, toolCalls int, cost float64, attrs ...any)
```

ToolResponse logs the result of tool executions with token usage and cost.

<a name="Warn"></a>
## func Warn

```go
func Warn(msg string, args ...any)
```

Warn logs a warning message with structured attributes. Use for recoverable errors or unexpected but non\-critical situations.

<a name="WarnContext"></a>
## func WarnContext

```go
func WarnContext(ctx context.Context, msg string, args ...any)
```

WarnContext logs a warning message with context and structured attributes.

# mcp

```go
import "github.com/AltairaLabs/PromptKit/runtime/mcp"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [type Client](<#Client>)
- [type ClientCapabilities](<#ClientCapabilities>)
- [type ClientOptions](<#ClientOptions>)
  - [func DefaultClientOptions\(\) ClientOptions](<#DefaultClientOptions>)
- [type Content](<#Content>)
- [type ElicitationCapability](<#ElicitationCapability>)
- [type Implementation](<#Implementation>)
- [type InitializeRequest](<#InitializeRequest>)
- [type InitializeResponse](<#InitializeResponse>)
- [type JSONRPCError](<#JSONRPCError>)
- [type JSONRPCMessage](<#JSONRPCMessage>)
- [type LoggingCapability](<#LoggingCapability>)
- [type PromptsCapability](<#PromptsCapability>)
- [type Registry](<#Registry>)
- [type RegistryImpl](<#RegistryImpl>)
  - [func NewRegistry\(\) \*RegistryImpl](<#NewRegistry>)
  - [func NewRegistryWithServers\(serverConfigs \[\]ServerConfigData\) \(\*RegistryImpl, error\)](<#NewRegistryWithServers>)
  - [func \(r \*RegistryImpl\) Close\(\) error](<#RegistryImpl.Close>)
  - [func \(r \*RegistryImpl\) GetClient\(ctx context.Context, serverName string\) \(Client, error\)](<#RegistryImpl.GetClient>)
  - [func \(r \*RegistryImpl\) GetClientForTool\(ctx context.Context, toolName string\) \(Client, error\)](<#RegistryImpl.GetClientForTool>)
  - [func \(r \*RegistryImpl\) GetToolSchema\(ctx context.Context, toolName string\) \(\*Tool, error\)](<#RegistryImpl.GetToolSchema>)
  - [func \(r \*RegistryImpl\) ListAllTools\(ctx context.Context\) \(map\[string\]\[\]Tool, error\)](<#RegistryImpl.ListAllTools>)
  - [func \(r \*RegistryImpl\) ListServers\(\) \[\]string](<#RegistryImpl.ListServers>)
  - [func \(r \*RegistryImpl\) RegisterServer\(config ServerConfig\) error](<#RegistryImpl.RegisterServer>)
- [type ResourcesCapability](<#ResourcesCapability>)
- [type SamplingCapability](<#SamplingCapability>)
- [type ServerCapabilities](<#ServerCapabilities>)
- [type ServerConfig](<#ServerConfig>)
- [type ServerConfigData](<#ServerConfigData>)
- [type StdioClient](<#StdioClient>)
  - [func NewStdioClient\(config ServerConfig\) \*StdioClient](<#NewStdioClient>)
  - [func NewStdioClientWithOptions\(config ServerConfig, options ClientOptions\) \*StdioClient](<#NewStdioClientWithOptions>)
  - [func \(c \*StdioClient\) CallTool\(ctx context.Context, name string, arguments json.RawMessage\) \(\*ToolCallResponse, error\)](<#StdioClient.CallTool>)
  - [func \(c \*StdioClient\) Close\(\) error](<#StdioClient.Close>)
  - [func \(c \*StdioClient\) Initialize\(ctx context.Context\) \(\*InitializeResponse, error\)](<#StdioClient.Initialize>)
  - [func \(c \*StdioClient\) IsAlive\(\) bool](<#StdioClient.IsAlive>)
  - [func \(c \*StdioClient\) ListTools\(ctx context.Context\) \(\[\]Tool, error\)](<#StdioClient.ListTools>)
- [type Tool](<#Tool>)
- [type ToolCallRequest](<#ToolCallRequest>)
- [type ToolCallResponse](<#ToolCallResponse>)
- [type ToolsCapability](<#ToolsCapability>)
- [type ToolsListRequest](<#ToolsListRequest>)
- [type ToolsListResponse](<#ToolsListResponse>)


## Constants

<a name="ProtocolVersion"></a>Protocol version \(as of 2025\-06\-18\)

```go
const ProtocolVersion = "2025-06-18"
```

## Variables

<a name="ErrClientNotInitialized"></a>

```go
var (
    // ErrClientNotInitialized is returned when attempting operations on uninitialized client
    ErrClientNotInitialized = errors.New("mcp: client not initialized")
    // ErrClientClosed is returned when attempting operations on closed client
    ErrClientClosed = errors.New("mcp: client closed")
    // ErrServerUnresponsive is returned when server doesn't respond
    ErrServerUnresponsive = errors.New("mcp: server unresponsive")
    // ErrProcessDied is returned when server process dies unexpectedly
    ErrProcessDied = errors.New("mcp: server process died")
)
```

<a name="Client"></a>
## type Client

Client interface defines the MCP client operations

```go
type Client interface {
    // Initialize establishes the MCP connection and negotiates capabilities
    Initialize(ctx context.Context) (*InitializeResponse, error)

    // ListTools retrieves all available tools from the server
    ListTools(ctx context.Context) ([]Tool, error)

    // CallTool executes a tool with the given arguments
    CallTool(ctx context.Context, name string, arguments json.RawMessage) (*ToolCallResponse, error)

    // Close terminates the connection to the MCP server
    Close() error

    // IsAlive checks if the connection is still active
    IsAlive() bool
}
```

<a name="ClientCapabilities"></a>
## type ClientCapabilities

ClientCapabilities describes what the client supports

```go
type ClientCapabilities struct {
    Elicitation *ElicitationCapability `json:"elicitation,omitempty"`
    Sampling    *SamplingCapability    `json:"sampling,omitempty"`
    Logging     *LoggingCapability     `json:"logging,omitempty"`
}
```

<a name="ClientOptions"></a>
## type ClientOptions

ClientOptions configures MCP client behavior

```go
type ClientOptions struct {
    // RequestTimeout is the default timeout for RPC requests
    RequestTimeout time.Duration
    // InitTimeout is the timeout for the initialization handshake
    InitTimeout time.Duration
    // MaxRetries is the number of times to retry failed requests
    MaxRetries int
    // RetryDelay is the initial delay between retries (exponential backoff)
    RetryDelay time.Duration
    // EnableGracefulDegradation allows operations to continue even if MCP is unavailable
    EnableGracefulDegradation bool
}
```

<a name="DefaultClientOptions"></a>
### func DefaultClientOptions

```go
func DefaultClientOptions() ClientOptions
```

DefaultClientOptions returns sensible defaults

<a name="Content"></a>
## type Content

Content represents a content item in MCP responses

```go
type Content struct {
    Type     string `json:"type"` // "text", "image", "resource", etc.
    Text     string `json:"text,omitempty"`
    Data     string `json:"data,omitempty"`     // Base64 encoded data
    MimeType string `json:"mimeType,omitempty"` // MIME type for data
    URI      string `json:"uri,omitempty"`      // URI for resources
}
```

<a name="ElicitationCapability"></a>
## type ElicitationCapability

ElicitationCapability indicates the client supports elicitation

```go
type ElicitationCapability struct{}
```

<a name="Implementation"></a>
## type Implementation

Implementation describes client or server implementation details

```go
type Implementation struct {
    Name    string `json:"name"`
    Version string `json:"version"`
}
```

<a name="InitializeRequest"></a>
## type InitializeRequest

InitializeRequest represents the initialization request params

```go
type InitializeRequest struct {
    ProtocolVersion string             `json:"protocolVersion"`
    Capabilities    ClientCapabilities `json:"capabilities"`
    ClientInfo      Implementation     `json:"clientInfo"`
}
```

<a name="InitializeResponse"></a>
## type InitializeResponse

InitializeResponse represents the initialization response

```go
type InitializeResponse struct {
    ProtocolVersion string             `json:"protocolVersion"`
    Capabilities    ServerCapabilities `json:"capabilities"`
    ServerInfo      Implementation     `json:"serverInfo"`
}
```

<a name="JSONRPCError"></a>
## type JSONRPCError

JSONRPCError represents a JSON\-RPC 2.0 error

```go
type JSONRPCError struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
}
```

<a name="JSONRPCMessage"></a>
## type JSONRPCMessage

JSONRPCMessage represents a JSON\-RPC 2.0 message

```go
type JSONRPCMessage struct {
    JSONRPC string          `json:"jsonrpc"`
    ID      interface{}     `json:"id,omitempty"`     // Request ID (number or string)
    Method  string          `json:"method,omitempty"` // Method name for requests/notifications
    Params  json.RawMessage `json:"params,omitempty"` // Parameters for method
    Result  json.RawMessage `json:"result,omitempty"` // Result for responses
    Error   *JSONRPCError   `json:"error,omitempty"`  // Error for error responses
}
```

<a name="LoggingCapability"></a>
## type LoggingCapability

LoggingCapability indicates the client supports logging

```go
type LoggingCapability struct{}
```

<a name="PromptsCapability"></a>
## type PromptsCapability

PromptsCapability indicates the server supports prompts

```go
type PromptsCapability struct {
    ListChanged bool `json:"listChanged,omitempty"`
}
```

<a name="Registry"></a>
## type Registry

Registry interface defines the MCP server registry operations

```go
type Registry interface {
    // RegisterServer adds a new MCP server configuration
    RegisterServer(config ServerConfig) error

    // GetClient returns an active client for the given server name
    GetClient(ctx context.Context, serverName string) (Client, error)

    // GetClientForTool returns the client that provides the specified tool
    GetClientForTool(ctx context.Context, toolName string) (Client, error)

    // ListServers returns all registered server names
    ListServers() []string

    // ListAllTools returns all tools from all connected servers
    ListAllTools(ctx context.Context) (map[string][]Tool, error)

    // Close shuts down all MCP servers and connections
    Close() error
}
```

<a name="RegistryImpl"></a>
## type RegistryImpl

RegistryImpl implements the Registry interface

```go
type RegistryImpl struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *RegistryImpl
```

NewRegistry creates a new MCP server registry

<a name="NewRegistryWithServers"></a>
### func NewRegistryWithServers

```go
func NewRegistryWithServers(serverConfigs []ServerConfigData) (*RegistryImpl, error)
```

NewRegistryWithServers creates a registry and registers multiple servers. Returns error if any server registration fails.

<a name="RegistryImpl.Close"></a>
### func \(\*RegistryImpl\) Close

```go
func (r *RegistryImpl) Close() error
```

Close shuts down all MCP servers and connections

<a name="RegistryImpl.GetClient"></a>
### func \(\*RegistryImpl\) GetClient

```go
func (r *RegistryImpl) GetClient(ctx context.Context, serverName string) (Client, error)
```

GetClient returns an active client for the given server name

<a name="RegistryImpl.GetClientForTool"></a>
### func \(\*RegistryImpl\) GetClientForTool

```go
func (r *RegistryImpl) GetClientForTool(ctx context.Context, toolName string) (Client, error)
```

GetClientForTool returns the client that provides the specified tool

<a name="RegistryImpl.GetToolSchema"></a>
### func \(\*RegistryImpl\) GetToolSchema

```go
func (r *RegistryImpl) GetToolSchema(ctx context.Context, toolName string) (*Tool, error)
```

GetToolSchema returns the schema for a specific tool

<a name="RegistryImpl.ListAllTools"></a>
### func \(\*RegistryImpl\) ListAllTools

```go
func (r *RegistryImpl) ListAllTools(ctx context.Context) (map[string][]Tool, error)
```

ListAllTools returns all tools from all connected servers

<a name="RegistryImpl.ListServers"></a>
### func \(\*RegistryImpl\) ListServers

```go
func (r *RegistryImpl) ListServers() []string
```

ListServers returns all registered server names

<a name="RegistryImpl.RegisterServer"></a>
### func \(\*RegistryImpl\) RegisterServer

```go
func (r *RegistryImpl) RegisterServer(config ServerConfig) error
```

RegisterServer adds a new MCP server configuration

<a name="ResourcesCapability"></a>
## type ResourcesCapability

ResourcesCapability indicates the server supports resources

```go
type ResourcesCapability struct {
    ListChanged bool `json:"listChanged,omitempty"`
}
```

<a name="SamplingCapability"></a>
## type SamplingCapability

SamplingCapability indicates the client supports sampling

```go
type SamplingCapability struct{}
```

<a name="ServerCapabilities"></a>
## type ServerCapabilities

ServerCapabilities describes what the server supports

```go
type ServerCapabilities struct {
    Tools     *ToolsCapability     `json:"tools,omitempty"`
    Resources *ResourcesCapability `json:"resources,omitempty"`
    Prompts   *PromptsCapability   `json:"prompts,omitempty"`
}
```

<a name="ServerConfig"></a>
## type ServerConfig

ServerConfig represents configuration for an MCP server

```go
type ServerConfig struct {
    Name    string            `json:"name" yaml:"name"`       // Unique identifier for this server
    Command string            `json:"command" yaml:"command"` // Command to execute
    Args    []string          `json:"args,omitempty" yaml:"args,omitempty"`
    Env     map[string]string `json:"env,omitempty" yaml:"env,omitempty"`
}
```

<a name="ServerConfigData"></a>
## type ServerConfigData

ServerConfigData holds MCP server configuration matching config.MCPServerConfig

```go
type ServerConfigData struct {
    Name    string
    Command string
    Args    []string
    Env     map[string]string
}
```

<a name="StdioClient"></a>
## type StdioClient

StdioClient implements the MCP Client interface using stdio transport

```go
type StdioClient struct {
    // contains filtered or unexported fields
}
```

<a name="NewStdioClient"></a>
### func NewStdioClient

```go
func NewStdioClient(config ServerConfig) *StdioClient
```

NewStdioClient creates a new MCP client using stdio transport

<a name="NewStdioClientWithOptions"></a>
### func NewStdioClientWithOptions

```go
func NewStdioClientWithOptions(config ServerConfig, options ClientOptions) *StdioClient
```

NewStdioClientWithOptions creates a client with custom options

<a name="StdioClient.CallTool"></a>
### func \(\*StdioClient\) CallTool

```go
func (c *StdioClient) CallTool(ctx context.Context, name string, arguments json.RawMessage) (*ToolCallResponse, error)
```

CallTool executes a tool with the given arguments

<a name="StdioClient.Close"></a>
### func \(\*StdioClient\) Close

```go
func (c *StdioClient) Close() error
```

Close terminates the connection to the MCP server

<a name="StdioClient.Initialize"></a>
### func \(\*StdioClient\) Initialize

```go
func (c *StdioClient) Initialize(ctx context.Context) (*InitializeResponse, error)
```

Initialize establishes the MCP connection and negotiates capabilities

<a name="StdioClient.IsAlive"></a>
### func \(\*StdioClient\) IsAlive

```go
func (c *StdioClient) IsAlive() bool
```

IsAlive checks if the connection is still active

<a name="StdioClient.ListTools"></a>
### func \(\*StdioClient\) ListTools

```go
func (c *StdioClient) ListTools(ctx context.Context) ([]Tool, error)
```

ListTools retrieves all available tools from the server

<a name="Tool"></a>
## type Tool

Tool represents an MCP tool definition

```go
type Tool struct {
    Name        string          `json:"name"`
    Description string          `json:"description,omitempty"`
    InputSchema json.RawMessage `json:"inputSchema"` // JSON Schema for tool input
}
```

<a name="ToolCallRequest"></a>
## type ToolCallRequest

ToolCallRequest represents a request to execute a tool

```go
type ToolCallRequest struct {
    Name      string          `json:"name"`
    Arguments json.RawMessage `json:"arguments,omitempty"`
}
```

<a name="ToolCallResponse"></a>
## type ToolCallResponse

ToolCallResponse represents the response from a tool execution

```go
type ToolCallResponse struct {
    Content []Content `json:"content"`
    IsError bool      `json:"isError,omitempty"`
}
```

<a name="ToolsCapability"></a>
## type ToolsCapability

ToolsCapability indicates the server supports tools

```go
type ToolsCapability struct {
    ListChanged bool `json:"listChanged,omitempty"` // Server can send notifications
}
```

<a name="ToolsListRequest"></a>
## type ToolsListRequest

ToolsListRequest represents a request to list available tools

```go
type ToolsListRequest struct {
}
```

<a name="ToolsListResponse"></a>
## type ToolsListResponse

ToolsListResponse represents the response to a tools/list request

```go
type ToolsListResponse struct {
    Tools []Tool `json:"tools"`
}
```

# persistence

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence"
```

Package persistence provides abstract persistence layer for Runtime components.

This package implements the Repository Pattern to decouple Runtime from storage implementations. It provides interfaces for loading prompts, tools, and fragments from various backends \(YAML files, JSON files, memory, packs, etc.\).

## Index

- [type PromptRepository](<#PromptRepository>)
- [type ToolRepository](<#ToolRepository>)


<a name="PromptRepository"></a>
## type PromptRepository

PromptRepository provides abstract access to prompt configurations

```go
type PromptRepository interface {
    // LoadPrompt loads a prompt configuration by task type
    LoadPrompt(taskType string) (*prompt.PromptConfig, error)

    // LoadFragment loads a fragment by name and optional path
    LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)

    // ListPrompts returns all available prompt task types
    ListPrompts() ([]string, error)

    // SavePrompt saves a prompt configuration (for future write support)
    SavePrompt(config *prompt.PromptConfig) error
}
```

<a name="ToolRepository"></a>
## type ToolRepository

ToolRepository provides abstract access to tool descriptors

```go
type ToolRepository interface {
    // LoadTool loads a tool descriptor by name
    LoadTool(name string) (*tools.ToolDescriptor, error)

    // ListTools returns all available tool names
    ListTools() ([]string, error)

    // SaveTool saves a tool descriptor (for future write support)
    SaveTool(descriptor *tools.ToolDescriptor) error
}
```

# pipeline

```go
import "github.com/AltairaLabs/PromptKit/runtime/pipeline"
```

## Index

- [type ExecutionConfig](<#ExecutionConfig>)
- [type ExecutionContext](<#ExecutionContext>)
  - [func \(ctx \*ExecutionContext\) AddPendingToolCall\(toolCall types.MessageToolCall\)](<#ExecutionContext.AddPendingToolCall>)
  - [func \(ctx \*ExecutionContext\) ClearPendingToolCalls\(\)](<#ExecutionContext.ClearPendingToolCalls>)
  - [func \(ctx \*ExecutionContext\) EmitStreamChunk\(chunk providers.StreamChunk\) bool](<#ExecutionContext.EmitStreamChunk>)
  - [func \(ctx \*ExecutionContext\) GetPendingToolCall\(id string\) \*types.MessageToolCall](<#ExecutionContext.GetPendingToolCall>)
  - [func \(ctx \*ExecutionContext\) HasPendingToolCalls\(\) bool](<#ExecutionContext.HasPendingToolCalls>)
  - [func \(ctx \*ExecutionContext\) InterruptStream\(reason string\)](<#ExecutionContext.InterruptStream>)
  - [func \(ctx \*ExecutionContext\) IsStreaming\(\) bool](<#ExecutionContext.IsStreaming>)
  - [func \(ctx \*ExecutionContext\) RemovePendingToolCall\(id string\) bool](<#ExecutionContext.RemovePendingToolCall>)
- [type ExecutionResult](<#ExecutionResult>)
- [type ExecutionTrace](<#ExecutionTrace>)
- [type LLMCall](<#LLMCall>)
- [type Middleware](<#Middleware>)
- [type MiddlewareConfig](<#MiddlewareConfig>)
- [type Pipeline](<#Pipeline>)
  - [func NewPipeline\(middleware ...Middleware\) \*Pipeline](<#NewPipeline>)
  - [func NewPipelineWithConfig\(config \*PipelineRuntimeConfig, middleware ...Middleware\) \*Pipeline](<#NewPipelineWithConfig>)
  - [func \(p \*Pipeline\) Execute\(ctx context.Context, role string, content string\) \(\*ExecutionResult, error\)](<#Pipeline.Execute>)
  - [func \(p \*Pipeline\) ExecuteStream\(ctx context.Context, role string, content string\) \(\<\-chan providers.StreamChunk, error\)](<#Pipeline.ExecuteStream>)
  - [func \(p \*Pipeline\) ExecuteStreamWithMessage\(ctx context.Context, message types.Message\) \(\<\-chan providers.StreamChunk, error\)](<#Pipeline.ExecuteStreamWithMessage>)
  - [func \(p \*Pipeline\) ExecuteWithMessage\(ctx context.Context, message types.Message\) \(\*ExecutionResult, error\)](<#Pipeline.ExecuteWithMessage>)
  - [func \(p \*Pipeline\) Shutdown\(ctx context.Context\) error](<#Pipeline.Shutdown>)
- [type PipelineConfig](<#PipelineConfig>)
- [type PipelineRuntimeConfig](<#PipelineRuntimeConfig>)
  - [func DefaultPipelineRuntimeConfig\(\) \*PipelineRuntimeConfig](<#DefaultPipelineRuntimeConfig>)
- [type ProviderMiddlewareConfig](<#ProviderMiddlewareConfig>)
- [type Response](<#Response>)
- [type ResponseMetadata](<#ResponseMetadata>)
- [type RetryPolicy](<#RetryPolicy>)
- [type StateStoreConfig](<#StateStoreConfig>)
- [type TemplateMiddlewareConfig](<#TemplateMiddlewareConfig>)
- [type ToolPolicy](<#ToolPolicy>)
- [type TraceEvent](<#TraceEvent>)
- [type ValidationError](<#ValidationError>)
  - [func \(e \*ValidationError\) Error\(\) string](<#ValidationError.Error>)
- [type ValidatorMiddlewareConfig](<#ValidatorMiddlewareConfig>)


<a name="ExecutionConfig"></a>
## type ExecutionConfig

ExecutionConfig contains configuration for pipeline execution.

```go
type ExecutionConfig struct {
    Provider     providers.Provider
    ToolRegistry *tools.Registry
    Temperature  float32
    MaxTokens    int
    Seed         *int
    ToolPolicy   *ToolPolicy
}
```

<a name="ExecutionContext"></a>
## type ExecutionContext

ExecutionContext is the execution state passed through the middleware chain. It contains all the data needed for pipeline execution and is modified by middleware.

```go
type ExecutionContext struct {
    // Context for cancellation, deadlines, and request-scoped values
    Context context.Context

    // State (mutable by middleware)
    SystemPrompt     string                    // Populated by PromptAssemblyMiddleware
    Variables        map[string]string         // Populated by PromptAssemblyMiddleware and ContextExtractionMiddleware
    AllowedTools     []string                  // Populated by PromptAssemblyMiddleware
    Messages         []types.Message           // Conversation history + current messages
    Tools            []types.ToolDef           // Available tool definitions
    ToolResults      []types.MessageToolResult // Executed tool results
    PendingToolCalls []types.MessageToolCall   // Tool calls awaiting external completion (human-in-the-loop)
    Prompt           string                    // Assembled prompt (after variable substitution by TemplateMiddleware)

    // Output (populated by middleware)
    Trace       ExecutionTrace // Complete trace of all LLM calls and events
    Response    *Response      // Convenience pointer to the most recent response (= Trace.LLMCalls[len-1].Response)
    RawResponse interface{}    // Convenience pointer to most recent raw response (= Trace.LLMCalls[len-1].RawResponse)

    // Error tracking (middleware can check this to see if an error occurred earlier in the chain)
    Error error // First error encountered during execution (subsequent middleware still run)

    // Metadata (for passing data between middleware)
    Metadata map[string]interface{}

    // Cost tracking (aggregate across all calls)
    CostInfo types.CostInfo

    // Streaming support
    StreamMode        bool                       // If true, use streaming execution
    StreamOutput      chan providers.StreamChunk // Output channel for streaming chunks
    StreamInterrupted bool                       // Set to true by middleware to stop streaming
    InterruptReason   string                     // Reason for interruption
    // contains filtered or unexported fields
}
```

<a name="ExecutionContext.AddPendingToolCall"></a>
### func \(\*ExecutionContext\) AddPendingToolCall

```go
func (ctx *ExecutionContext) AddPendingToolCall(toolCall types.MessageToolCall)
```

AddPendingToolCall adds a tool call to the pending list. Used by middleware when a tool returns ToolStatusPending.

<a name="ExecutionContext.ClearPendingToolCalls"></a>
### func \(\*ExecutionContext\) ClearPendingToolCalls

```go
func (ctx *ExecutionContext) ClearPendingToolCalls()
```

ClearPendingToolCalls removes all pending tool calls.

<a name="ExecutionContext.EmitStreamChunk"></a>
### func \(\*ExecutionContext\) EmitStreamChunk

```go
func (ctx *ExecutionContext) EmitStreamChunk(chunk providers.StreamChunk) bool
```

EmitStreamChunk emits a stream chunk to the output channel. Returns false if the stream has been interrupted or the channel is closed. Middleware that produces chunks should check the return value to know when to stop.

<a name="ExecutionContext.GetPendingToolCall"></a>
### func \(\*ExecutionContext\) GetPendingToolCall

```go
func (ctx *ExecutionContext) GetPendingToolCall(id string) *types.MessageToolCall
```

GetPendingToolCall retrieves a pending tool call by ID. Returns nil if not found.

<a name="ExecutionContext.HasPendingToolCalls"></a>
### func \(\*ExecutionContext\) HasPendingToolCalls

```go
func (ctx *ExecutionContext) HasPendingToolCalls() bool
```

HasPendingToolCalls returns true if there are any pending tool calls.

<a name="ExecutionContext.InterruptStream"></a>
### func \(\*ExecutionContext\) InterruptStream

```go
func (ctx *ExecutionContext) InterruptStream(reason string)
```

InterruptStream interrupts the stream with the given reason. Middleware should call this to stop streaming when validation fails, rate limits are hit, etc.

<a name="ExecutionContext.IsStreaming"></a>
### func \(\*ExecutionContext\) IsStreaming

```go
func (ctx *ExecutionContext) IsStreaming() bool
```

IsStreaming returns true if the execution context is in streaming mode.

<a name="ExecutionContext.RemovePendingToolCall"></a>
### func \(\*ExecutionContext\) RemovePendingToolCall

```go
func (ctx *ExecutionContext) RemovePendingToolCall(id string) bool
```

RemovePendingToolCall removes a tool call from the pending list by ID. Returns true if the tool call was found and removed.

<a name="ExecutionResult"></a>
## type ExecutionResult

ExecutionResult is the output of a pipeline execution. It contains the final state after all middleware has been executed.

```go
type ExecutionResult struct {
    Messages []types.Message        `json:"messages"`  // All messages including history and responses
    Response *Response              `json:"response"`  // The final response (convenience field)
    Trace    ExecutionTrace         `json:"trace"`     // Complete execution trace with all LLM calls
    CostInfo types.CostInfo         `json:"cost_info"` // Aggregate cost across all LLM calls
    Metadata map[string]interface{} `json:"metadata"`  // Metadata populated by middleware
}
```

<a name="ExecutionTrace"></a>
## type ExecutionTrace

ExecutionTrace captures the complete execution history of a pipeline run. This includes all LLM calls, tool executions, and other significant events.

```go
type ExecutionTrace struct {
    LLMCalls    []LLMCall    `json:"llm_calls"`              // All LLM API calls made during execution
    Events      []TraceEvent `json:"events,omitempty"`       // Other trace events (tool execution, context truncation, etc.)
    StartedAt   time.Time    `json:"started_at"`             // When pipeline execution started
    CompletedAt *time.Time   `json:"completed_at,omitempty"` // When pipeline execution completed (nil if still running)
}
```

<a name="LLMCall"></a>
## type LLMCall

LLMCall represents a single LLM API call within a pipeline execution. In tool\-enabled scenarios, multiple calls may occur in sequence.

```go
type LLMCall struct {
    Sequence     int                     `json:"sequence"`               // Call number in sequence (1, 2, 3...)
    MessageIndex int                     `json:"message_index"`          // Index into ExecutionResult.Messages where assistant response is stored
    Request      interface{}             `json:"request,omitempty"`      // Raw request (if debugging enabled)
    Response     *Response               `json:"response"`               // Parsed response
    RawResponse  interface{}             `json:"raw_response,omitempty"` // Raw provider response (if debugging enabled)
    StartedAt    time.Time               `json:"started_at"`             // When call started
    Duration     time.Duration           `json:"duration"`               // How long the call took
    Cost         types.CostInfo          `json:"cost"`                   // Cost information for this call
    ToolCalls    []types.MessageToolCall `json:"tool_calls,omitempty"`   // If this call triggered tool execution
    Error        error                   `json:"error,omitempty"`        // If the call failed
}
```

<a name="Middleware"></a>
## type Middleware

Middleware defines the execution interface for pipeline steps.

Middleware executes in a nested chain where each middleware explicitly calls next\(\) to continue the pipeline. This makes the execution flow clear and explicit.

Given middleware chain: \[A, B, C\] Execution order is:

```
A.Process(ctx, func() {
  return B.Process(ctx, func() {
    return C.Process(ctx, func() {
      return nil // End of chain
    })
  })
})
```

Example implementation:

```
func (m *ProviderMiddleware) Process(ctx *ExecutionContext, next func() error) error {
  // Setup/processing logic
  response, err := m.provider.Generate(ctx)
  if err != nil {
    return err
  }
  ctx.Response = response

  // Continue to next middleware
  if err := next(); err != nil {
    return err
  }

  // Optional cleanup logic
  return nil
}
```

Error Handling:

- If Process\(\) returns an error, the error is captured in ExecutionContext.Error
- Errors stop the chain \- subsequent middleware do not execute
- Middleware can check ExecutionContext.Error to see if earlier steps failed

ExecutionContext is used internally by middleware but users should not create it directly.

```go
type Middleware interface {
    Process(ctx *ExecutionContext, next func() error) error
    // StreamChunk is called for each chunk during streaming execution (if StreamMode is true).
    // Middleware can inspect, validate, or modify chunks. Return an error or call ctx.InterruptStream()
    // to stop streaming. Most middleware should return nil (no-op).
    StreamChunk(ctx *ExecutionContext, chunk *providers.StreamChunk) error
}
```

<a name="MiddlewareConfig"></a>
## type MiddlewareConfig

MiddlewareConfig represents configuration for a specific middleware

```go
type MiddlewareConfig struct {
    Type   string                 `json:"type"`             // Middleware type (e.g., "template", "provider", "validator")
    Config map[string]interface{} `json:"config,omitempty"` // Type-specific configuration
}
```

<a name="Pipeline"></a>
## type Pipeline

Pipeline chains middleware together in sequence.

```go
type Pipeline struct {
    // contains filtered or unexported fields
}
```

<a name="NewPipeline"></a>
### func NewPipeline

```go
func NewPipeline(middleware ...Middleware) *Pipeline
```

NewPipeline creates a new pipeline with the given middleware. Uses default runtime configuration.

<a name="NewPipelineWithConfig"></a>
### func NewPipelineWithConfig

```go
func NewPipelineWithConfig(config *PipelineRuntimeConfig, middleware ...Middleware) *Pipeline
```

NewPipelineWithConfig creates a new pipeline with the given configuration and middleware. If config is nil, uses default configuration.

<a name="Pipeline.Execute"></a>
### func \(\*Pipeline\) Execute

```go
func (p *Pipeline) Execute(ctx context.Context, role string, content string) (*ExecutionResult, error)
```

Execute runs the pipeline with the given role and content, returning the execution result. It creates a fresh internal ExecutionContext for each call, preventing state contamination. The role and content parameters are used to create the initial user message. If role is empty, no message is appended \(useful for testing\). Returns the ExecutionResult containing messages, response, trace, and metadata.

<a name="Pipeline.ExecuteStream"></a>
### func \(\*Pipeline\) ExecuteStream

```go
func (p *Pipeline) ExecuteStream(ctx context.Context, role string, content string) (<-chan providers.StreamChunk, error)
```

ExecuteStream runs the pipeline in streaming mode, returning a channel of stream chunks. It creates a fresh internal ExecutionContext for each call, preventing state contamination. The role and content parameters are used to create the initial user message. If role is empty, no message is appended \(useful for testing\). The pipeline executes in the background and closes the channel when complete. The final chunk will contain the ExecutionResult in the FinalResult field.

<a name="Pipeline.ExecuteStreamWithMessage"></a>
### func \(\*Pipeline\) ExecuteStreamWithMessage

```go
func (p *Pipeline) ExecuteStreamWithMessage(ctx context.Context, message types.Message) (<-chan providers.StreamChunk, error)
```

ExecuteStreamWithMessage runs the pipeline in streaming mode with a complete Message object. This method allows callers to provide a fully\-populated message with all fields \(Meta, Timestamp, etc.\) rather than just role and content. The message is added to the execution context as\-is, preserving all fields including Meta, Timestamp, ToolCalls, CostInfo, and Validations.

The pipeline executes in the background and closes the channel when complete. The final chunk will contain the ExecutionResult in the FinalResult field. Returns a channel of StreamChunk objects that will be closed when execution completes.

<a name="Pipeline.ExecuteWithMessage"></a>
### func \(\*Pipeline\) ExecuteWithMessage

```go
func (p *Pipeline) ExecuteWithMessage(ctx context.Context, message types.Message) (*ExecutionResult, error)
```

ExecuteWithMessage runs the pipeline with a complete Message object, returning the execution result. This method allows callers to provide a fully\-populated message with all fields \(Meta, Timestamp, etc.\) rather than just role and content. This is useful when you need to preserve metadata or other message properties through the pipeline execution.

The message is added to the execution context as\-is, preserving all fields including: \- Meta \(metadata, raw responses, validation info\) \- Timestamp \- ToolCalls \- CostInfo \- Validations

Middleware can still modify the message during execution if needed. Returns the ExecutionResult containing messages, response, trace, and metadata.

<a name="Pipeline.Shutdown"></a>
### func \(\*Pipeline\) Shutdown

```go
func (p *Pipeline) Shutdown(ctx context.Context) error
```

Shutdown gracefully shuts down the pipeline, waiting for in\-flight executions to complete. Returns an error if shutdown times out according to GracefulShutdownTimeout.

<a name="PipelineConfig"></a>
## type PipelineConfig

PipelineConfig represents the complete pipeline configuration for pack format

```go
type PipelineConfig struct {
    Stages     []string           `json:"stages"`               // Pipeline stages in order (e.g., ["template", "provider", "validator"])
    Middleware []MiddlewareConfig `json:"middleware,omitempty"` // Middleware configurations
}
```

<a name="PipelineRuntimeConfig"></a>
## type PipelineRuntimeConfig

PipelineRuntimeConfig defines runtime configuration options for pipeline execution. All fields have sensible defaults and are optional.

```go
type PipelineRuntimeConfig struct {
    // MaxConcurrentExecutions limits the number of concurrent pipeline executions.
    // Default: 100
    MaxConcurrentExecutions int

    // StreamBufferSize sets the buffer size for streaming output channels.
    // Default: 100
    StreamBufferSize int

    // ExecutionTimeout sets the maximum duration for a single pipeline execution.
    // Set to 0 to disable timeout.
    // Default: 30 seconds
    ExecutionTimeout time.Duration

    // GracefulShutdownTimeout sets the maximum time to wait for in-flight executions during shutdown.
    // Default: 10 seconds
    GracefulShutdownTimeout time.Duration
}
```

<a name="DefaultPipelineRuntimeConfig"></a>
### func DefaultPipelineRuntimeConfig

```go
func DefaultPipelineRuntimeConfig() *PipelineRuntimeConfig
```

DefaultPipelineRuntimeConfig returns a PipelineRuntimeConfig with sensible default values.

<a name="ProviderMiddlewareConfig"></a>
## type ProviderMiddlewareConfig

ProviderMiddlewareConfig contains configuration for provider middleware

```go
type ProviderMiddlewareConfig struct {
    RetryPolicy  *RetryPolicy `json:"retry_policy,omitempty"`  // Retry policy
    TimeoutMs    int          `json:"timeout_ms,omitempty"`    // Request timeout in milliseconds
    DisableTrace bool         `json:"disable_trace,omitempty"` // Disable execution tracing (default: false = tracing enabled)
}
```

<a name="Response"></a>
## type Response

Response represents the final output from a pipeline execution.

```go
type Response struct {
    Role          string
    Content       string
    ToolCalls     []types.MessageToolCall
    FinalResponse string // If tools were used, this is the final response after tools
    Metadata      ResponseMetadata
}
```

<a name="ResponseMetadata"></a>
## type ResponseMetadata

ResponseMetadata contains metadata about the response.

```go
type ResponseMetadata struct {
    Provider     string
    Model        string
    Latency      time.Duration
    TokensInput  int
    TokensOutput int
    Cost         float64
}
```

<a name="RetryPolicy"></a>
## type RetryPolicy

RetryPolicy defines retry behavior for provider middleware

```go
type RetryPolicy struct {
    MaxRetries     int    `json:"max_retries"`                // Maximum retry attempts
    Backoff        string `json:"backoff"`                    // Backoff strategy ("fixed", "exponential")
    InitialDelayMs int    `json:"initial_delay_ms,omitempty"` // Initial delay in milliseconds
}
```

<a name="StateStoreConfig"></a>
## type StateStoreConfig

StateStoreConfig contains configuration for state store middleware

```go
type StateStoreConfig struct {
    Store          interface{}            // State store implementation (statestore.Store)
    ConversationID string                 // Unique conversation identifier
    UserID         string                 // User identifier (optional)
    Metadata       map[string]interface{} // Additional metadata to store (optional)
}
```

<a name="TemplateMiddlewareConfig"></a>
## type TemplateMiddlewareConfig

TemplateMiddlewareConfig contains configuration for template middleware

```go
type TemplateMiddlewareConfig struct {
    StrictMode     bool `json:"strict_mode"`     // Fail on undefined variables
    AllowUndefined bool `json:"allow_undefined"` // Allow undefined variables (opposite of strict_mode)
}
```

<a name="ToolPolicy"></a>
## type ToolPolicy

ToolPolicy defines constraints on tool usage.

```go
type ToolPolicy struct {
    ToolChoice          string   `json:"tool_choice,omitempty"` // "auto", "required", "none", or specific tool name
    MaxRounds           int      `json:"max_rounds,omitempty"`
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="TraceEvent"></a>
## type TraceEvent

TraceEvent represents a significant event during pipeline execution.

```go
type TraceEvent struct {
    Type      string      `json:"type"`              // Event type (e.g., "tool_execution", "context_truncation", "validation_failed")
    Timestamp time.Time   `json:"timestamp"`         // When the event occurred
    Data      interface{} `json:"data"`              // Event-specific data
    Message   string      `json:"message,omitempty"` // Human-readable description
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a validation failure.

```go
type ValidationError struct {
    Type    string
    Details string
}
```

<a name="ValidationError.Error"></a>
### func \(\*ValidationError\) Error

```go
func (e *ValidationError) Error() string
```



<a name="ValidatorMiddlewareConfig"></a>
## type ValidatorMiddlewareConfig

ValidatorMiddlewareConfig contains configuration for validator middleware

```go
type ValidatorMiddlewareConfig struct {
    FailFast         bool `json:"fail_fast"`          // Stop on first validation error
    CollectAllErrors bool `json:"collect_all_errors"` // Collect all errors before failing
}
```

# prompt

```go
import "github.com/AltairaLabs/PromptKit/runtime/prompt"
```

Package prompt provides template\-based prompt management and assembly.

This package implements a registry system for loading, caching, and assembling prompt templates via repository interfaces:

- Fragment\-based prompt composition
- Variable substitution with required/optional vars
- Model\-specific overrides \(template modifications only\)
- Tool allowlist integration
- Version tracking and content hashing

The Registry uses the repository pattern to load prompt configs, avoiding direct file I/O. It resolves fragment references, performs template variable substitution, and generates AssembledPrompt objects ready for LLM execution.

### Architecture

For system architecture and design patterns, see:

- Architecture overview: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/architecture.md
- Prompt assembly pipeline: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/prompt-assembly.md
- Repository pattern: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/persistence-layer-proposal.md

### Usage

Create a registry with a repository \(config\-first pattern\):

```
repo := memory.NewPromptRepository()
registry := prompt.NewRegistryWithRepository(repo)
assembled := registry.LoadWithVars("task_type", vars, "gpt-4")
```

See package github.com/AltairaLabs/PromptKit/sdk for higher\-level APIs.

## Index

- [func ExtractVariablesFromTemplate\(template string\) \[\]string](<#ExtractVariablesFromTemplate>)
- [func GetDefaultPipelineConfig\(\) map\[string\]interface\{\}](<#GetDefaultPipelineConfig>)
- [func GetUsedVars\(vars map\[string\]string\) \[\]string](<#GetUsedVars>)
- [type AssembledPrompt](<#AssembledPrompt>)
  - [func \(ap \*AssembledPrompt\) UsesTools\(\) bool](<#AssembledPrompt.UsesTools>)
- [type ChangelogEntry](<#ChangelogEntry>)
- [type CompilationInfo](<#CompilationInfo>)
- [type CostEstimate](<#CostEstimate>)
- [type Fragment](<#Fragment>)
- [type FragmentRef](<#FragmentRef>)
- [type FragmentRepository](<#FragmentRepository>)
- [type FragmentResolver](<#FragmentResolver>)
  - [func NewFragmentResolverWithRepository\(repository FragmentRepository\) \*FragmentResolver](<#NewFragmentResolverWithRepository>)
  - [func \(fr \*FragmentResolver\) AssembleFragments\(fragments \[\]FragmentRef, vars map\[string\]string, configFilePath string\) \(map\[string\]string, error\)](<#FragmentResolver.AssembleFragments>)
  - [func \(fr \*FragmentResolver\) LoadFragment\(name string, relativePath string, configFilePath string\) \(\*Fragment, error\)](<#FragmentResolver.LoadFragment>)
- [type MetadataBuilder](<#MetadataBuilder>)
  - [func NewMetadataBuilder\(spec \*PromptSpec\) \*MetadataBuilder](<#NewMetadataBuilder>)
  - [func \(mb \*MetadataBuilder\) AddChangelogEntry\(version string, author string, description string\)](<#MetadataBuilder.AddChangelogEntry>)
  - [func \(mb \*MetadataBuilder\) BuildCompilationInfo\(compilerVersion string\) \*CompilationInfo](<#MetadataBuilder.BuildCompilationInfo>)
  - [func \(mb \*MetadataBuilder\) BuildPromptMetadata\(domain string, language string, tags \[\]string, testResults \[\]TestResultSummary\) \*PromptMetadata](<#MetadataBuilder.BuildPromptMetadata>)
  - [func \(mb \*MetadataBuilder\) SetDomain\(domain string\)](<#MetadataBuilder.SetDomain>)
  - [func \(mb \*MetadataBuilder\) SetLanguage\(language string\)](<#MetadataBuilder.SetLanguage>)
  - [func \(mb \*MetadataBuilder\) SetTags\(tags \[\]string\)](<#MetadataBuilder.SetTags>)
  - [func \(mb \*MetadataBuilder\) UpdateFromCostInfo\(costs \[\]types.CostInfo\)](<#MetadataBuilder.UpdateFromCostInfo>)
  - [func \(mb \*MetadataBuilder\) ValidateMetadata\(\) \[\]string](<#MetadataBuilder.ValidateMetadata>)
- [type ModelOverride](<#ModelOverride>)
- [type ModelTestResultRef](<#ModelTestResultRef>)
  - [func AggregateTestResults\(results \[\]TestResultSummary, provider string, model string\) \*ModelTestResultRef](<#AggregateTestResults>)
- [type Pack](<#Pack>)
  - [func LoadPack\(filePath string\) \(\*Pack, error\)](<#LoadPack>)
  - [func \(p \*Pack\) GetOptionalVariables\(taskType string\) map\[string\]string](<#Pack.GetOptionalVariables>)
  - [func \(p \*Pack\) GetPrompt\(taskType string\) \*PackPrompt](<#Pack.GetPrompt>)
  - [func \(p \*Pack\) GetRequiredVariables\(taskType string\) \[\]string](<#Pack.GetRequiredVariables>)
  - [func \(p \*Pack\) GetToolNames\(taskType string\) \[\]string](<#Pack.GetToolNames>)
  - [func \(p \*Pack\) ListPrompts\(\) \[\]string](<#Pack.ListPrompts>)
  - [func \(p \*Pack\) Summary\(\) string](<#Pack.Summary>)
  - [func \(p \*Pack\) Validate\(\) \[\]string](<#Pack.Validate>)
- [type PackCompiler](<#PackCompiler>)
  - [func NewPackCompiler\(registry \*Registry\) \*PackCompiler](<#NewPackCompiler>)
  - [func \(pc \*PackCompiler\) Compile\(taskType string, compilerVersion string\) \(\*Pack, error\)](<#PackCompiler.Compile>)
  - [func \(pc \*PackCompiler\) CompileFromRegistry\(packID string, compilerVersion string\) \(\*Pack, error\)](<#PackCompiler.CompileFromRegistry>)
  - [func \(pc \*PackCompiler\) CompileToFile\(taskType string, outputPath string, compilerVersion string\) error](<#PackCompiler.CompileToFile>)
- [type PackPrompt](<#PackPrompt>)
- [type ParametersPack](<#ParametersPack>)
- [type PerformanceMetrics](<#PerformanceMetrics>)
- [type PromptConfig](<#PromptConfig>)
  - [func ParsePromptConfig\(data \[\]byte\) \(\*PromptConfig, error\)](<#ParsePromptConfig>)
- [type PromptInfo](<#PromptInfo>)
- [type PromptMetadata](<#PromptMetadata>)
- [type PromptRepository](<#PromptRepository>)
- [type PromptSpec](<#PromptSpec>)
- [type Registry](<#Registry>)
  - [func NewRegistryWithRepository\(repository PromptRepository\) \*Registry](<#NewRegistryWithRepository>)
  - [func \(r \*Registry\) ClearCache\(\)](<#Registry.ClearCache>)
  - [func \(r \*Registry\) GetAvailableRegions\(\) \[\]string](<#Registry.GetAvailableRegions>)
  - [func \(r \*Registry\) GetAvailableTaskTypes\(\) \[\]string](<#Registry.GetAvailableTaskTypes>)
  - [func \(r \*Registry\) GetCachedFragments\(\) \[\]string](<#Registry.GetCachedFragments>)
  - [func \(r \*Registry\) GetCachedPrompts\(\) \[\]string](<#Registry.GetCachedPrompts>)
  - [func \(r \*Registry\) GetLoadedFragments\(\) \[\]string](<#Registry.GetLoadedFragments>)
  - [func \(r \*Registry\) GetLoadedPrompts\(\) \[\]string](<#Registry.GetLoadedPrompts>)
  - [func \(r \*Registry\) GetPromptInfo\(taskType string\) \(\*PromptInfo, error\)](<#Registry.GetPromptInfo>)
  - [func \(r \*Registry\) ListTaskTypes\(\) \[\]string](<#Registry.ListTaskTypes>)
  - [func \(r \*Registry\) Load\(activity string\) \*AssembledPrompt](<#Registry.Load>)
  - [func \(r \*Registry\) LoadConfig\(activity string\) \(\*PromptConfig, error\)](<#Registry.LoadConfig>)
  - [func \(r \*Registry\) LoadWithVars\(activity string, vars map\[string\]string, model string\) \*AssembledPrompt](<#Registry.LoadWithVars>)
  - [func \(r \*Registry\) RegisterConfig\(taskType string, config \*PromptConfig\) error](<#Registry.RegisterConfig>)
- [type TemplateEngineInfo](<#TemplateEngineInfo>)
- [type TestResultSummary](<#TestResultSummary>)
  - [func ConvertFromEngineResults\(engineResults \[\]interface\{\}\) \[\]TestResultSummary](<#ConvertFromEngineResults>)
- [type ToolPolicyPack](<#ToolPolicyPack>)
- [type ValidatorConfig](<#ValidatorConfig>)
- [type VariableMetadata](<#VariableMetadata>)
- [type VariableValidation](<#VariableValidation>)


<a name="ExtractVariablesFromTemplate"></a>
## func ExtractVariablesFromTemplate

```go
func ExtractVariablesFromTemplate(template string) []string
```

ExtractVariablesFromTemplate analyzes a template string and extracts variable names This helps auto\-generate variable metadata when not explicitly specified

<a name="GetDefaultPipelineConfig"></a>
## func GetDefaultPipelineConfig

```go
func GetDefaultPipelineConfig() map[string]interface{}
```

GetDefaultPipelineConfig returns the default Arena pipeline configuration Returns as map to avoid import cycle with pipeline package

<a name="GetUsedVars"></a>
## func GetUsedVars

```go
func GetUsedVars(vars map[string]string) []string
```

GetUsedVars returns a list of variable names that had non\-empty values Deprecated: Use template.GetUsedVars instead

<a name="AssembledPrompt"></a>
## type AssembledPrompt

AssembledPrompt represents a complete prompt ready for LLM execution.

```go
type AssembledPrompt struct {
    TaskType     string            `json:"task_type"`
    SystemPrompt string            `json:"system_prompt"`
    AllowedTools []string          `json:"allowed_tools,omitempty"` // Tools this prompt can use
    Validators   []ValidatorConfig `json:"validators,omitempty"`    // Validators to apply at runtime
}
```

<a name="AssembledPrompt.UsesTools"></a>
### func \(\*AssembledPrompt\) UsesTools

```go
func (ap *AssembledPrompt) UsesTools() bool
```

UsesTools returns true if this prompt has tools configured

<a name="ChangelogEntry"></a>
## type ChangelogEntry

ChangelogEntry records a change in the prompt configuration

```go
type ChangelogEntry struct {
    Version     string `yaml:"version"`          // Version number
    Date        string `yaml:"date"`             // Date of change (YYYY-MM-DD)
    Author      string `yaml:"author,omitempty"` // Author of change
    Description string `yaml:"description"`      // Description of change
}
```

<a name="CompilationInfo"></a>
## type CompilationInfo

CompilationInfo contains information about prompt compilation

```go
type CompilationInfo struct {
    CompiledWith string `yaml:"compiled_with"`    // Compiler version
    CreatedAt    string `yaml:"created_at"`       // Timestamp (RFC3339)
    Schema       string `yaml:"schema,omitempty"` // Pack schema version (e.g., "v1")
}
```

<a name="CostEstimate"></a>
## type CostEstimate

CostEstimate provides estimated costs for prompt execution

```go
type CostEstimate struct {
    MinCostUSD float64 `yaml:"min_cost_usd"` // Minimum cost per execution
    MaxCostUSD float64 `yaml:"max_cost_usd"` // Maximum cost per execution
    AvgCostUSD float64 `yaml:"avg_cost_usd"` // Average cost per execution
}
```

<a name="Fragment"></a>
## type Fragment

Fragment represents a reusable prompt fragment

```go
type Fragment struct {
    Type              string `yaml:"fragment_type"`
    Version           string `yaml:"version"`
    Description       string `yaml:"description"`
    Content           string `yaml:"content"`
    SourceFile        string `yaml:"source_file,omitempty"`         // Source file path (for pack compilation)
    ResolvedAtCompile bool   `yaml:"resolved_at_compile,omitempty"` // Whether resolved at compile time
}
```

<a name="FragmentRef"></a>
## type FragmentRef

FragmentRef references a prompt fragment for assembly

```go
type FragmentRef struct {
    Name     string `yaml:"name"`
    Path     string `yaml:"path,omitempty"` // Optional: relative path to fragment file
    Required bool   `yaml:"required"`
}
```

<a name="FragmentRepository"></a>
## type FragmentRepository

FragmentRepository interface for loading fragments \(to avoid import cycles\)

```go
type FragmentRepository interface {
    LoadFragment(name string, relativePath string, baseDir string) (*Fragment, error)
}
```

<a name="FragmentResolver"></a>
## type FragmentResolver

FragmentResolver handles fragment loading, resolution, and variable substitution using the repository pattern

```go
type FragmentResolver struct {
    // contains filtered or unexported fields
}
```

<a name="NewFragmentResolverWithRepository"></a>
### func NewFragmentResolverWithRepository

```go
func NewFragmentResolverWithRepository(repository FragmentRepository) *FragmentResolver
```

NewFragmentResolverWithRepository creates a new fragment resolver with a repository

<a name="FragmentResolver.AssembleFragments"></a>
### func \(\*FragmentResolver\) AssembleFragments

```go
func (fr *FragmentResolver) AssembleFragments(fragments []FragmentRef, vars map[string]string, configFilePath string) (map[string]string, error)
```

AssembleFragments loads and assembles prompt fragments into variables. Resolves dynamic names and paths using the provided variable map.

<a name="FragmentResolver.LoadFragment"></a>
### func \(\*FragmentResolver\) LoadFragment

```go
func (fr *FragmentResolver) LoadFragment(name string, relativePath string, configFilePath string) (*Fragment, error)
```

LoadFragment loads a fragment from the repository with caching. Uses name as cache key, or path if provided.

<a name="MetadataBuilder"></a>
## type MetadataBuilder

MetadataBuilder helps construct pack format metadata from prompt configs and test results

```go
type MetadataBuilder struct {
    // contains filtered or unexported fields
}
```

<a name="NewMetadataBuilder"></a>
### func NewMetadataBuilder

```go
func NewMetadataBuilder(spec *PromptSpec) *MetadataBuilder
```

NewMetadataBuilder creates a new metadata builder for a prompt spec

<a name="MetadataBuilder.AddChangelogEntry"></a>
### func \(\*MetadataBuilder\) AddChangelogEntry

```go
func (mb *MetadataBuilder) AddChangelogEntry(version string, author string, description string)
```

AddChangelogEntry adds a new entry to the prompt's changelog

<a name="MetadataBuilder.BuildCompilationInfo"></a>
### func \(\*MetadataBuilder\) BuildCompilationInfo

```go
func (mb *MetadataBuilder) BuildCompilationInfo(compilerVersion string) *CompilationInfo
```

BuildCompilationInfo generates compilation metadata

<a name="MetadataBuilder.BuildPromptMetadata"></a>
### func \(\*MetadataBuilder\) BuildPromptMetadata

```go
func (mb *MetadataBuilder) BuildPromptMetadata(domain string, language string, tags []string, testResults []TestResultSummary) *PromptMetadata
```

BuildPromptMetadata generates PromptMetadata from test execution results

<a name="MetadataBuilder.SetDomain"></a>
### func \(\*MetadataBuilder\) SetDomain

```go
func (mb *MetadataBuilder) SetDomain(domain string)
```

SetDomain sets the domain for the prompt metadata

<a name="MetadataBuilder.SetLanguage"></a>
### func \(\*MetadataBuilder\) SetLanguage

```go
func (mb *MetadataBuilder) SetLanguage(language string)
```

SetLanguage sets the language for the prompt metadata

<a name="MetadataBuilder.SetTags"></a>
### func \(\*MetadataBuilder\) SetTags

```go
func (mb *MetadataBuilder) SetTags(tags []string)
```

SetTags sets the tags for the prompt metadata

<a name="MetadataBuilder.UpdateFromCostInfo"></a>
### func \(\*MetadataBuilder\) UpdateFromCostInfo

```go
func (mb *MetadataBuilder) UpdateFromCostInfo(costs []types.CostInfo)
```

UpdateFromCostInfo updates cost estimate from types.CostInfo

<a name="MetadataBuilder.ValidateMetadata"></a>
### func \(\*MetadataBuilder\) ValidateMetadata

```go
func (mb *MetadataBuilder) ValidateMetadata() []string
```

ValidateMetadata checks that metadata fields are properly populated

<a name="ModelOverride"></a>
## type ModelOverride

ModelOverride contains model\-specific template modifications. Note: Temperature and MaxTokens should be configured at the scenario or provider level, not in the prompt configuration.

```go
type ModelOverride struct {
    SystemTemplate       string `yaml:"system_template,omitempty"`
    SystemTemplateSuffix string `yaml:"system_template_suffix,omitempty"`
}
```

<a name="ModelTestResultRef"></a>
## type ModelTestResultRef

ModelTestResultRef is a simplified reference to model test results The full ModelTestResult type is in pkg/engine for tracking test execution

```go
type ModelTestResultRef struct {
    Provider     string  `yaml:"provider"`
    Model        string  `yaml:"model"`
    Date         string  `yaml:"date"`
    SuccessRate  float64 `yaml:"success_rate"`
    AvgTokens    int     `yaml:"avg_tokens,omitempty"`
    AvgCost      float64 `yaml:"avg_cost,omitempty"`
    AvgLatencyMs int     `yaml:"avg_latency_ms,omitempty"`
}
```

<a name="AggregateTestResults"></a>
### func AggregateTestResults

```go
func AggregateTestResults(results []TestResultSummary, provider string, model string) *ModelTestResultRef
```

AggregateTestResults computes ModelTestResultRef from test execution summaries

<a name="Pack"></a>
## type Pack

Pack represents the complete JSON pack format containing MULTIPLE prompts for different task types.

DESIGN DECISION: Why separate Pack types in runtime vs sdk?

This runtime Pack is optimized for COMPILATION:

- Created by PackCompiler from prompt registry
- Includes Compilation and Metadata for tracking provenance
- Returns validation warnings \(\[\]string\) for compiler feedback
- No thread\-safety needed \(single\-threaded compilation\)
- Simple types \(VariableMetadata, ValidatorConfig\) for JSON serialization

The sdk.Pack is optimized for LOADING & EXECUTION:

- Loaded from .pack.json files for application use
- Includes Tools map and filePath for execution context
- Thread\-safe with sync.RWMutex for concurrent access
- Returns validation errors for application error handling
- Rich types \(\*Variable, \*Validator\) with additional methods
- Has CreateRegistry\(\) to convert back to runtime.Registry for pipeline

Both serialize to/from the SAME JSON format \(.pack.json files\), ensuring full interoperability. The type duplication is intentional and prevents circular dependencies while allowing each module to evolve independently.

See sdk/pack.go for the corresponding SDK\-side documentation.

```go
type Pack struct {
    // Identity
    ID          string `json:"id"`          // Pack ID (e.g., "customer-support")
    Name        string `json:"name"`        // Human-readable name
    Version     string `json:"version"`     // Pack version
    Description string `json:"description"` // Pack description

    // Template Engine (shared across all prompts in pack)
    TemplateEngine *TemplateEngineInfo `json:"template_engine"`

    // Prompts - Map of task_type -> PackPrompt
    Prompts map[string]*PackPrompt `json:"prompts"`

    // Shared fragments (can be referenced by any prompt)
    Fragments map[string]string `json:"fragments,omitempty"` // Resolved fragments: name -> content

    // Metadata
    Metadata    *PromptMetadata  `json:"metadata,omitempty"`
    Compilation *CompilationInfo `json:"compilation,omitempty"`
}
```

<a name="LoadPack"></a>
### func LoadPack

```go
func LoadPack(filePath string) (*Pack, error)
```

LoadPack loads a pack from a JSON file

<a name="Pack.GetOptionalVariables"></a>
### func \(\*Pack\) GetOptionalVariables

```go
func (p *Pack) GetOptionalVariables(taskType string) map[string]string
```

GetOptionalVariables returns all optional variable names with defaults for a specific prompt

<a name="Pack.GetPrompt"></a>
### func \(\*Pack\) GetPrompt

```go
func (p *Pack) GetPrompt(taskType string) *PackPrompt
```

GetPrompt returns a specific prompt by task type

<a name="Pack.GetRequiredVariables"></a>
### func \(\*Pack\) GetRequiredVariables

```go
func (p *Pack) GetRequiredVariables(taskType string) []string
```

GetRequiredVariables returns all required variable names for a specific prompt

<a name="Pack.GetToolNames"></a>
### func \(\*Pack\) GetToolNames

```go
func (p *Pack) GetToolNames(taskType string) []string
```

GetToolNames returns the list of allowed tool names for a specific prompt

<a name="Pack.ListPrompts"></a>
### func \(\*Pack\) ListPrompts

```go
func (p *Pack) ListPrompts() []string
```

ListPrompts returns all prompt task types in the pack

<a name="Pack.Summary"></a>
### func \(\*Pack\) Summary

```go
func (p *Pack) Summary() string
```

Summary returns a brief summary of the pack

<a name="Pack.Validate"></a>
### func \(\*Pack\) Validate

```go
func (p *Pack) Validate() []string
```

Validate validates a pack format

<a name="PackCompiler"></a>
## type PackCompiler

PackCompiler compiles PromptConfig to Pack format

```go
type PackCompiler struct {
    // contains filtered or unexported fields
}
```

<a name="NewPackCompiler"></a>
### func NewPackCompiler

```go
func NewPackCompiler(registry *Registry) *PackCompiler
```

NewPackCompiler creates a new pack compiler

<a name="PackCompiler.Compile"></a>
### func \(\*PackCompiler\) Compile

```go
func (pc *PackCompiler) Compile(taskType string, compilerVersion string) (*Pack, error)
```

Compile compiles a single prompt config to Pack format \(for backward compatibility\)

<a name="PackCompiler.CompileFromRegistry"></a>
### func \(\*PackCompiler\) CompileFromRegistry

```go
func (pc *PackCompiler) CompileFromRegistry(packID string, compilerVersion string) (*Pack, error)
```

CompileFromRegistry compiles ALL prompts from the registry into a single Pack

<a name="PackCompiler.CompileToFile"></a>
### func \(\*PackCompiler\) CompileToFile

```go
func (pc *PackCompiler) CompileToFile(taskType string, outputPath string, compilerVersion string) error
```

CompileToFile compiles a prompt config to a JSON pack file

<a name="PackPrompt"></a>
## type PackPrompt

PackPrompt represents a single prompt configuration within a pack

```go
type PackPrompt struct {
    // Identity
    ID          string `json:"id"`          // Prompt ID (task_type)
    Name        string `json:"name"`        // Human-readable name
    Description string `json:"description"` // Prompt description
    Version     string `json:"version"`     // Prompt version

    // Prompt
    SystemTemplate string `json:"system_template"`

    // Variables
    Variables []VariableMetadata `json:"variables,omitempty"`

    // Tools
    Tools      []string        `json:"tools,omitempty"`       // Allowed tool names
    ToolPolicy *ToolPolicyPack `json:"tool_policy,omitempty"` // Tool usage policy

    // Pipeline
    Pipeline map[string]interface{} `json:"pipeline,omitempty"` // Pipeline configuration

    // Parameters
    Parameters *ParametersPack `json:"parameters,omitempty"` // Model-specific parameters

    // Validators
    Validators []ValidatorConfig `json:"validators,omitempty"`

    // Model Testing
    TestedModels []ModelTestResultRef `json:"tested_models,omitempty"`

    // Model Overrides
    ModelOverrides map[string]ModelOverride `json:"model_overrides,omitempty"`
}
```

<a name="ParametersPack"></a>
## type ParametersPack

ParametersPack represents model parameters in pack format

```go
type ParametersPack struct {
    Temperature *float64 `json:"temperature,omitempty"`
    MaxTokens   *int     `json:"max_tokens,omitempty"`
    TopP        *float64 `json:"top_p,omitempty"`
    TopK        *int     `json:"top_k,omitempty"`
}
```

<a name="PerformanceMetrics"></a>
## type PerformanceMetrics

PerformanceMetrics provides performance benchmarks

```go
type PerformanceMetrics struct {
    AvgLatencyMs int     `yaml:"avg_latency_ms"` // Average latency in milliseconds
    P95LatencyMs int     `yaml:"p95_latency_ms"` // 95th percentile latency
    AvgTokens    int     `yaml:"avg_tokens"`     // Average tokens used
    SuccessRate  float64 `yaml:"success_rate"`   // Success rate (0.0-1.0)
}
```

<a name="PromptConfig"></a>
## type PromptConfig

PromptConfig represents a YAML prompt configuration file in K8s\-style manifest format

```go
type PromptConfig struct {
    APIVersion string            `yaml:"apiVersion"`
    Kind       string            `yaml:"kind"`
    Metadata   metav1.ObjectMeta `yaml:"metadata,omitempty"`
    Spec       PromptSpec        `yaml:"spec"`
}
```

<a name="ParsePromptConfig"></a>
### func ParsePromptConfig

```go
func ParsePromptConfig(data []byte) (*PromptConfig, error)
```

ParsePromptConfig parses a prompt config from YAML data. This is a package\-level utility function for parsing prompt configs in the config layer. The config layer should read files using os.ReadFile and pass the data to this function. Returns the parsed PromptConfig or an error if parsing/validation fails.

<a name="PromptInfo"></a>
## type PromptInfo

PromptInfo provides summary information about a prompt configuration

```go
type PromptInfo struct {
    TaskType       string
    Version        string
    Description    string
    FragmentCount  int
    RequiredVars   []string
    OptionalVars   []string
    ToolAllowlist  []string
    ModelOverrides []string
}
```

<a name="PromptMetadata"></a>
## type PromptMetadata

PromptMetadata contains additional metadata for the pack format

```go
type PromptMetadata struct {
    Domain       string              `yaml:"domain,omitempty"`        // Domain/category (e.g., "customer-support")
    Language     string              `yaml:"language,omitempty"`      // Primary language (e.g., "en")
    Tags         []string            `yaml:"tags,omitempty"`          // Tags for categorization
    CostEstimate *CostEstimate       `yaml:"cost_estimate,omitempty"` // Estimated cost per execution
    Performance  *PerformanceMetrics `yaml:"performance,omitempty"`   // Performance benchmarks
    Changelog    []ChangelogEntry    `yaml:"changelog,omitempty"`     // Version history
}
```

<a name="PromptRepository"></a>
## type PromptRepository

PromptRepository interface defines methods for loading prompts \(to avoid import cycles\) This should match persistence.PromptRepository interface

```go
type PromptRepository interface {
    LoadPrompt(taskType string) (*PromptConfig, error)
    LoadFragment(name string, relativePath string, baseDir string) (*Fragment, error)
    ListPrompts() ([]string, error)
    SavePrompt(config *PromptConfig) error
}
```

<a name="PromptSpec"></a>
## type PromptSpec

PromptSpec contains the actual prompt configuration

```go
type PromptSpec struct {
    TaskType       string                   `yaml:"task_type"`
    Version        string                   `yaml:"version"`
    Description    string                   `yaml:"description"`
    TemplateEngine *TemplateEngineInfo      `yaml:"template_engine,omitempty"` // Template engine configuration
    Fragments      []FragmentRef            `yaml:"fragments,omitempty"`       // New: fragment assembly
    SystemTemplate string                   `yaml:"system_template"`
    RequiredVars   []string                 `yaml:"required_vars"`
    OptionalVars   map[string]string        `yaml:"optional_vars"`
    Variables      []VariableMetadata       `yaml:"variables,omitempty"` // Enhanced variable metadata
    ModelOverrides map[string]ModelOverride `yaml:"model_overrides"`
    AllowedTools   []string                 `yaml:"allowed_tools,omitempty"` // Tools this prompt can use
    Validators     []ValidatorConfig        `yaml:"validators,omitempty"`    // Validators/Guardrails for production runtime
    TestedModels   []ModelTestResultRef     `yaml:"tested_models,omitempty"` // Model testing metadata
    Metadata       *PromptMetadata          `yaml:"metadata,omitempty"`      // Additional metadata for pack format
    Compilation    *CompilationInfo         `yaml:"compilation,omitempty"`   // Compilation information
}
```

<a name="Registry"></a>
## type Registry

Registry manages prompt templates, versions, and variable substitution.

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistryWithRepository"></a>
### func NewRegistryWithRepository

```go
func NewRegistryWithRepository(repository PromptRepository) *Registry
```

NewRegistryWithRepository creates a registry with a repository \(new preferred method\). This constructor uses the repository pattern for loading prompts, avoiding direct file I/O.

<a name="Registry.ClearCache"></a>
### func \(\*Registry\) ClearCache

```go
func (r *Registry) ClearCache()
```

ClearCache clears all cached prompts and fragments

<a name="Registry.GetAvailableRegions"></a>
### func \(\*Registry\) GetAvailableRegions

```go
func (r *Registry) GetAvailableRegions() []string
```

GetAvailableRegions returns a list of all available regions from prompt fragments

<a name="Registry.GetAvailableTaskTypes"></a>
### func \(\*Registry\) GetAvailableTaskTypes

```go
func (r *Registry) GetAvailableTaskTypes() []string
```

GetAvailableTaskTypes is deprecated: use ListTaskTypes instead

<a name="Registry.GetCachedFragments"></a>
### func \(\*Registry\) GetCachedFragments

```go
func (r *Registry) GetCachedFragments() []string
```

GetCachedFragments returns a list of currently cached fragment keys.

<a name="Registry.GetCachedPrompts"></a>
### func \(\*Registry\) GetCachedPrompts

```go
func (r *Registry) GetCachedPrompts() []string
```

GetCachedPrompts returns a list of currently cached prompt task types. For a complete list including uncached prompts, use ListTaskTypes instead.

<a name="Registry.GetLoadedFragments"></a>
### func \(\*Registry\) GetLoadedFragments

```go
func (r *Registry) GetLoadedFragments() []string
```

GetLoadedFragments is deprecated: use GetCachedFragments instead

<a name="Registry.GetLoadedPrompts"></a>
### func \(\*Registry\) GetLoadedPrompts

```go
func (r *Registry) GetLoadedPrompts() []string
```

GetLoadedPrompts is deprecated: use GetCachedPrompts instead

<a name="Registry.GetPromptInfo"></a>
### func \(\*Registry\) GetPromptInfo

```go
func (r *Registry) GetPromptInfo(taskType string) (*PromptInfo, error)
```

GetPromptInfo returns detailed information about a prompt configuration

<a name="Registry.ListTaskTypes"></a>
### func \(\*Registry\) ListTaskTypes

```go
func (r *Registry) ListTaskTypes() []string
```

ListTaskTypes returns all available task types from the repository. Falls back to cached task types if repository is unavailable or returns empty.

<a name="Registry.Load"></a>
### func \(\*Registry\) Load

```go
func (r *Registry) Load(activity string) *AssembledPrompt
```

Load returns an assembled prompt for the specified activity with variable substitution.

<a name="Registry.LoadConfig"></a>
### func \(\*Registry\) LoadConfig

```go
func (r *Registry) LoadConfig(activity string) (*PromptConfig, error)
```

LoadConfig is deprecated: use loadConfig directly \(internal use\) or use Load/LoadWithVars

<a name="Registry.LoadWithVars"></a>
### func \(\*Registry\) LoadWithVars

```go
func (r *Registry) LoadWithVars(activity string, vars map[string]string, model string) *AssembledPrompt
```

LoadWithVars loads a prompt with variable substitution and optional model override.

<a name="Registry.RegisterConfig"></a>
### func \(\*Registry\) RegisterConfig

```go
func (r *Registry) RegisterConfig(taskType string, config *PromptConfig) error
```

RegisterConfig registers a PromptConfig directly into the registry. This allows programmatic registration of prompts without requiring disk files. Useful for loading prompts from compiled packs or other in\-memory sources. If a repository is configured, the config is persisted there as well.

<a name="TemplateEngineInfo"></a>
## type TemplateEngineInfo

TemplateEngineInfo describes the template engine used for variable substitution

```go
type TemplateEngineInfo struct {
    Version  string   `yaml:"version"`            // Template engine version (e.g., "v1")
    Syntax   string   `yaml:"syntax"`             // Template syntax (e.g., "{{variable}}")
    Features []string `yaml:"features,omitempty"` // Supported features (e.g., "conditionals", "loops")
}
```

<a name="TestResultSummary"></a>
## type TestResultSummary

TestResultSummary contains summarized test execution data

```go
type TestResultSummary struct {
    Success   bool
    Cost      float64
    LatencyMs int
    Tokens    int
}
```

<a name="ConvertFromEngineResults"></a>
### func ConvertFromEngineResults

```go
func ConvertFromEngineResults(engineResults []interface{}) []TestResultSummary
```

ConvertFromEngineResults converts engine RunResults to TestResultSummary This is a helper to bridge between engine execution and metadata generation

<a name="ToolPolicyPack"></a>
## type ToolPolicyPack

ToolPolicyPack represents tool policy in pack format

```go
type ToolPolicyPack struct {
    ToolChoice          string   `json:"tool_choice,omitempty"`
    MaxRounds           int      `json:"max_rounds,omitempty"`
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="ValidatorConfig"></a>
## type ValidatorConfig

ValidatorConfig extends validators.ValidatorConfig with prompt\-pack specific fields

```go
type ValidatorConfig struct {
    validators.ValidatorConfig `yaml:",inline"` // Embed base config (Type, Params)
    Enabled                    *bool            `yaml:"enabled,omitempty"`           // Enable/disable validator (default: true)
    FailOnViolation            *bool            `yaml:"fail_on_violation,omitempty"` // Fail execution on violation (default: true)
}
```

<a name="VariableMetadata"></a>
## type VariableMetadata

VariableMetadata contains enhanced metadata for a variable

```go
type VariableMetadata struct {
    Name        string              `yaml:"name"`                  // Variable name
    Type        string              `yaml:"type,omitempty"`        // Variable type (string, int, etc.)
    Required    bool                `yaml:"required"`              // Whether variable is required
    Default     string              `yaml:"default,omitempty"`     // Default value if optional
    Description string              `yaml:"description,omitempty"` // Human-readable description
    Example     string              `yaml:"example,omitempty"`     // Example value
    Enum        []string            `yaml:"enum,omitempty"`        // Allowed values
    Validation  *VariableValidation `yaml:"validation,omitempty"`  // Validation rules
}
```

<a name="VariableValidation"></a>
## type VariableValidation

VariableValidation contains validation rules for a variable

```go
type VariableValidation struct {
    Pattern   string `yaml:"pattern,omitempty"`    // Regex pattern
    MinLength int    `yaml:"min_length,omitempty"` // Minimum length
    MaxLength int    `yaml:"max_length,omitempty"` // Maximum length
}
```

# providers

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers"
```

Package providers implements multi\-LLM provider support with unified interfaces.

This package provides a common abstraction for chat\-based LLM providers including OpenAI, Anthropic Claude, and Google Gemini. It handles:

- Chat completion requests with streaming support
- Tool/function calling with provider\-specific formats
- Cost tracking and token usage calculation
- Rate limiting and error handling

All providers implement the Provider interface for basic chat, and ToolSupport interface for function calling capabilities.

## Index

- [func IsValidationAbort\(err error\) bool](<#IsValidationAbort>)
- [type ChatRequest](<#ChatRequest>)
- [type ChatResponse](<#ChatResponse>)
- [type ClaudeProvider](<#ClaudeProvider>)
  - [func NewClaudeProvider\(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool\) \*ClaudeProvider](<#NewClaudeProvider>)
  - [func \(p \*ClaudeProvider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#ClaudeProvider.CalculateCost>)
  - [func \(p \*ClaudeProvider\) Chat\(ctx context.Context, req ChatRequest\) \(ChatResponse, error\)](<#ClaudeProvider.Chat>)
  - [func \(p \*ClaudeProvider\) ChatStream\(ctx context.Context, req ChatRequest\) \(\<\-chan StreamChunk, error\)](<#ClaudeProvider.ChatStream>)
  - [func \(p \*ClaudeProvider\) Close\(\) error](<#ClaudeProvider.Close>)
  - [func \(p \*ClaudeProvider\) ID\(\) string](<#ClaudeProvider.ID>)
  - [func \(p \*ClaudeProvider\) ShouldIncludeRawOutput\(\) bool](<#ClaudeProvider.ShouldIncludeRawOutput>)
  - [func \(p \*ClaudeProvider\) SupportsStreaming\(\) bool](<#ClaudeProvider.SupportsStreaming>)
- [type ClaudeToolProvider](<#ClaudeToolProvider>)
  - [func NewClaudeToolProvider\(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool\) \*ClaudeToolProvider](<#NewClaudeToolProvider>)
  - [func \(p \*ClaudeToolProvider\) BuildTooling\(descriptors \[\]\*ToolDescriptor\) \(interface\{\}, error\)](<#ClaudeToolProvider.BuildTooling>)
  - [func \(p \*ClaudeToolProvider\) ChatWithTools\(ctx context.Context, req ChatRequest, tools interface\{\}, toolChoice string\) \(ChatResponse, \[\]types.MessageToolCall, error\)](<#ClaudeToolProvider.ChatWithTools>)
  - [func \(p \*ClaudeToolProvider\) ContinueWithToolResults\(ctx context.Context, req ChatRequest, prior ChatResponse, tools interface\{\}, toolChoice string, results \[\]types.MessageToolResult\) \(ChatResponse, \[\]types.MessageToolCall, error\)](<#ClaudeToolProvider.ContinueWithToolResults>)
- [type ExecutionResult](<#ExecutionResult>)
- [type GeminiProvider](<#GeminiProvider>)
  - [func NewGeminiProvider\(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool\) \*GeminiProvider](<#NewGeminiProvider>)
  - [func \(p \*GeminiProvider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#GeminiProvider.CalculateCost>)
  - [func \(p \*GeminiProvider\) Chat\(ctx context.Context, req ChatRequest\) \(ChatResponse, error\)](<#GeminiProvider.Chat>)
  - [func \(p \*GeminiProvider\) ChatStream\(ctx context.Context, req ChatRequest\) \(\<\-chan StreamChunk, error\)](<#GeminiProvider.ChatStream>)
  - [func \(p \*GeminiProvider\) Close\(\) error](<#GeminiProvider.Close>)
  - [func \(p \*GeminiProvider\) ID\(\) string](<#GeminiProvider.ID>)
  - [func \(p \*GeminiProvider\) ShouldIncludeRawOutput\(\) bool](<#GeminiProvider.ShouldIncludeRawOutput>)
  - [func \(p \*GeminiProvider\) SupportsStreaming\(\) bool](<#GeminiProvider.SupportsStreaming>)
- [type GeminiToolProvider](<#GeminiToolProvider>)
  - [func NewGeminiToolProvider\(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool\) \*GeminiToolProvider](<#NewGeminiToolProvider>)
  - [func \(p \*GeminiToolProvider\) BuildTooling\(descriptors \[\]\*ToolDescriptor\) \(interface\{\}, error\)](<#GeminiToolProvider.BuildTooling>)
  - [func \(p \*GeminiToolProvider\) ChatWithTools\(ctx context.Context, req ChatRequest, tools interface\{\}, toolChoice string\) \(ChatResponse, \[\]types.MessageToolCall, error\)](<#GeminiToolProvider.ChatWithTools>)
  - [func \(p \*GeminiToolProvider\) ContinueWithToolResults\(ctx context.Context, req ChatRequest, prior ChatResponse, tools interface\{\}, toolChoice string, results \[\]types.MessageToolResult\) \(ChatResponse, \[\]types.MessageToolCall, error\)](<#GeminiToolProvider.ContinueWithToolResults>)
- [type MockProvider](<#MockProvider>)
  - [func NewMockProvider\(id, model string, includeRawOutput bool\) \*MockProvider](<#NewMockProvider>)
  - [func \(m \*MockProvider\) CalculateCost\(inputTokens, outputTokens, cachedTokens int\) types.CostInfo](<#MockProvider.CalculateCost>)
  - [func \(m \*MockProvider\) Chat\(ctx context.Context, req ChatRequest\) \(ChatResponse, error\)](<#MockProvider.Chat>)
  - [func \(m \*MockProvider\) ChatStream\(ctx context.Context, req ChatRequest\) \(\<\-chan StreamChunk, error\)](<#MockProvider.ChatStream>)
  - [func \(m \*MockProvider\) Close\(\) error](<#MockProvider.Close>)
  - [func \(m \*MockProvider\) ID\(\) string](<#MockProvider.ID>)
  - [func \(m \*MockProvider\) ShouldIncludeRawOutput\(\) bool](<#MockProvider.ShouldIncludeRawOutput>)
  - [func \(m \*MockProvider\) SupportsStreaming\(\) bool](<#MockProvider.SupportsStreaming>)
- [type OpenAIProvider](<#OpenAIProvider>)
  - [func NewOpenAIProvider\(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool\) \*OpenAIProvider](<#NewOpenAIProvider>)
  - [func \(p \*OpenAIProvider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#OpenAIProvider.CalculateCost>)
  - [func \(p \*OpenAIProvider\) Chat\(ctx context.Context, req ChatRequest\) \(ChatResponse, error\)](<#OpenAIProvider.Chat>)
  - [func \(p \*OpenAIProvider\) ChatStream\(ctx context.Context, req ChatRequest\) \(\<\-chan StreamChunk, error\)](<#OpenAIProvider.ChatStream>)
  - [func \(p \*OpenAIProvider\) Close\(\) error](<#OpenAIProvider.Close>)
  - [func \(p \*OpenAIProvider\) ID\(\) string](<#OpenAIProvider.ID>)
  - [func \(p \*OpenAIProvider\) ShouldIncludeRawOutput\(\) bool](<#OpenAIProvider.ShouldIncludeRawOutput>)
  - [func \(p \*OpenAIProvider\) SupportsStreaming\(\) bool](<#OpenAIProvider.SupportsStreaming>)
- [type OpenAIToolProvider](<#OpenAIToolProvider>)
  - [func NewOpenAIToolProvider\(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool\) \*OpenAIToolProvider](<#NewOpenAIToolProvider>)
  - [func \(p \*OpenAIToolProvider\) BuildTooling\(descriptors \[\]\*ToolDescriptor\) \(interface\{\}, error\)](<#OpenAIToolProvider.BuildTooling>)
  - [func \(p \*OpenAIToolProvider\) ChatWithTools\(ctx context.Context, req ChatRequest, tools interface\{\}, toolChoice string\) \(ChatResponse, \[\]types.MessageToolCall, error\)](<#OpenAIToolProvider.ChatWithTools>)
  - [func \(p \*OpenAIToolProvider\) ContinueWithToolResults\(ctx context.Context, req ChatRequest, prior ChatResponse, tools interface\{\}, toolChoice string, results \[\]types.MessageToolResult\) \(ChatResponse, \[\]types.MessageToolCall, error\)](<#OpenAIToolProvider.ContinueWithToolResults>)
- [type Pricing](<#Pricing>)
- [type Provider](<#Provider>)
  - [func CreateProviderFromSpec\(spec ProviderSpec\) \(Provider, error\)](<#CreateProviderFromSpec>)
- [type ProviderDefaults](<#ProviderDefaults>)
- [type ProviderSpec](<#ProviderSpec>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func \(r \*Registry\) Close\(\) error](<#Registry.Close>)
  - [func \(r \*Registry\) Get\(id string\) \(Provider, bool\)](<#Registry.Get>)
  - [func \(r \*Registry\) List\(\) \[\]string](<#Registry.List>)
  - [func \(r \*Registry\) Register\(provider Provider\)](<#Registry.Register>)
- [type SSEScanner](<#SSEScanner>)
  - [func NewSSEScanner\(r io.Reader\) \*SSEScanner](<#NewSSEScanner>)
  - [func \(s \*SSEScanner\) Data\(\) string](<#SSEScanner.Data>)
  - [func \(s \*SSEScanner\) Err\(\) error](<#SSEScanner.Err>)
  - [func \(s \*SSEScanner\) Scan\(\) bool](<#SSEScanner.Scan>)
- [type StreamChunk](<#StreamChunk>)
- [type StreamEvent](<#StreamEvent>)
- [type StreamObserver](<#StreamObserver>)
- [type ToolDescriptor](<#ToolDescriptor>)
- [type ToolResult](<#ToolResult>)
- [type ToolSupport](<#ToolSupport>)
- [type UnsupportedProviderError](<#UnsupportedProviderError>)
  - [func \(e \*UnsupportedProviderError\) Error\(\) string](<#UnsupportedProviderError.Error>)
- [type ValidationAbortError](<#ValidationAbortError>)
  - [func \(e \*ValidationAbortError\) Error\(\) string](<#ValidationAbortError.Error>)


<a name="IsValidationAbort"></a>
## func IsValidationAbort

```go
func IsValidationAbort(err error) bool
```

IsValidationAbort checks if an error is a validation abort

<a name="ChatRequest"></a>
## type ChatRequest

ChatRequest represents a request to a chat provider

```go
type ChatRequest struct {
    System      string          `json:"system"`
    Messages    []types.Message `json:"messages"`
    Temperature float32         `json:"temperature"`
    TopP        float32         `json:"top_p"`
    MaxTokens   int             `json:"max_tokens"`
    Seed        *int            `json:"seed,omitempty"`
}
```

<a name="ChatResponse"></a>
## type ChatResponse

ChatResponse represents a response from a chat provider

```go
type ChatResponse struct {
    Content    string                  `json:"content"`
    CostInfo   *types.CostInfo         `json:"cost_info,omitempty"` // Cost breakdown for this response (includes token counts)
    Latency    time.Duration           `json:"latency"`
    Raw        []byte                  `json:"raw,omitempty"`
    RawRequest interface{}             `json:"raw_request,omitempty"` // Raw API request (for debugging)
    ToolCalls  []types.MessageToolCall `json:"tool_calls,omitempty"`  // Tools called in this response
}
```

<a name="ClaudeProvider"></a>
## type ClaudeProvider

ClaudeProvider implements the Provider interface for Anthropic Claude

```go
type ClaudeProvider struct {
    // contains filtered or unexported fields
}
```

<a name="NewClaudeProvider"></a>
### func NewClaudeProvider

```go
func NewClaudeProvider(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool) *ClaudeProvider
```

NewClaudeProvider creates a new Claude provider

<a name="ClaudeProvider.CalculateCost"></a>
### func \(\*ClaudeProvider\) CalculateCost

```go
func (p *ClaudeProvider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="ClaudeProvider.Chat"></a>
### func \(\*ClaudeProvider\) Chat

```go
func (p *ClaudeProvider) Chat(ctx context.Context, req ChatRequest) (ChatResponse, error)
```

Chat sends a chat request to Claude

<a name="ClaudeProvider.ChatStream"></a>
### func \(\*ClaudeProvider\) ChatStream

```go
func (p *ClaudeProvider) ChatStream(ctx context.Context, req ChatRequest) (<-chan StreamChunk, error)
```

ChatStream streams a chat response from Claude

<a name="ClaudeProvider.Close"></a>
### func \(\*ClaudeProvider\) Close

```go
func (p *ClaudeProvider) Close() error
```

Close closes the HTTP client and cleans up idle connections

<a name="ClaudeProvider.ID"></a>
### func \(\*ClaudeProvider\) ID

```go
func (p *ClaudeProvider) ID() string
```

ID returns the provider ID

<a name="ClaudeProvider.ShouldIncludeRawOutput"></a>
### func \(\*ClaudeProvider\) ShouldIncludeRawOutput

```go
func (p *ClaudeProvider) ShouldIncludeRawOutput() bool
```

ShouldIncludeRawOutput returns whether to include raw API requests in output

<a name="ClaudeProvider.SupportsStreaming"></a>
### func \(\*ClaudeProvider\) SupportsStreaming

```go
func (p *ClaudeProvider) SupportsStreaming() bool
```

SupportsStreaming returns true for Claude

<a name="ClaudeToolProvider"></a>
## type ClaudeToolProvider

ClaudeToolProvider extends ClaudeProvider with tool support

```go
type ClaudeToolProvider struct {
    *ClaudeProvider
}
```

<a name="NewClaudeToolProvider"></a>
### func NewClaudeToolProvider

```go
func NewClaudeToolProvider(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool) *ClaudeToolProvider
```

NewClaudeToolProvider creates a new Claude provider with tool support

<a name="ClaudeToolProvider.BuildTooling"></a>
### func \(\*ClaudeToolProvider\) BuildTooling

```go
func (p *ClaudeToolProvider) BuildTooling(descriptors []*ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to Claude format

<a name="ClaudeToolProvider.ChatWithTools"></a>
### func \(\*ClaudeToolProvider\) ChatWithTools

```go
func (p *ClaudeToolProvider) ChatWithTools(ctx context.Context, req ChatRequest, tools interface{}, toolChoice string) (ChatResponse, []types.MessageToolCall, error)
```

ChatWithTools performs a chat request with tool support

<a name="ClaudeToolProvider.ContinueWithToolResults"></a>
### func \(\*ClaudeToolProvider\) ContinueWithToolResults

```go
func (p *ClaudeToolProvider) ContinueWithToolResults(ctx context.Context, req ChatRequest, prior ChatResponse, tools interface{}, toolChoice string, results []types.MessageToolResult) (ChatResponse, []types.MessageToolCall, error)
```

ContinueWithToolResults continues conversation with tool results

<a name="ExecutionResult"></a>
## type ExecutionResult

Forward declare ExecutionResult to avoid circular import

```go
type ExecutionResult interface{}
```

<a name="GeminiProvider"></a>
## type GeminiProvider

GeminiProvider implements the Provider interface for Google Gemini

```go
type GeminiProvider struct {
    Model    string
    BaseURL  string
    ApiKey   string
    Defaults ProviderDefaults

    Client *http.Client
    // contains filtered or unexported fields
}
```

<a name="NewGeminiProvider"></a>
### func NewGeminiProvider

```go
func NewGeminiProvider(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool) *GeminiProvider
```

NewGeminiProvider creates a new Gemini provider

<a name="GeminiProvider.CalculateCost"></a>
### func \(\*GeminiProvider\) CalculateCost

```go
func (p *GeminiProvider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="GeminiProvider.Chat"></a>
### func \(\*GeminiProvider\) Chat

```go
func (p *GeminiProvider) Chat(ctx context.Context, req ChatRequest) (ChatResponse, error)
```

Chat sends a chat request to Gemini

<a name="GeminiProvider.ChatStream"></a>
### func \(\*GeminiProvider\) ChatStream

```go
func (p *GeminiProvider) ChatStream(ctx context.Context, req ChatRequest) (<-chan StreamChunk, error)
```

ChatStream streams a chat response from Gemini

<a name="GeminiProvider.Close"></a>
### func \(\*GeminiProvider\) Close

```go
func (p *GeminiProvider) Close() error
```

Close closes the HTTP client and cleans up idle connections

<a name="GeminiProvider.ID"></a>
### func \(\*GeminiProvider\) ID

```go
func (p *GeminiProvider) ID() string
```

ID returns the provider ID

<a name="GeminiProvider.ShouldIncludeRawOutput"></a>
### func \(\*GeminiProvider\) ShouldIncludeRawOutput

```go
func (p *GeminiProvider) ShouldIncludeRawOutput() bool
```

ShouldIncludeRawOutput returns whether to include raw API requests in output

<a name="GeminiProvider.SupportsStreaming"></a>
### func \(\*GeminiProvider\) SupportsStreaming

```go
func (p *GeminiProvider) SupportsStreaming() bool
```

SupportsStreaming returns true for Gemini

<a name="GeminiToolProvider"></a>
## type GeminiToolProvider

GeminiToolProvider extends GeminiProvider with tool support

```go
type GeminiToolProvider struct {
    *GeminiProvider
    // contains filtered or unexported fields
}
```

<a name="NewGeminiToolProvider"></a>
### func NewGeminiToolProvider

```go
func NewGeminiToolProvider(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool) *GeminiToolProvider
```

NewGeminiToolProvider creates a new Gemini provider with tool support

<a name="GeminiToolProvider.BuildTooling"></a>
### func \(\*GeminiToolProvider\) BuildTooling

```go
func (p *GeminiToolProvider) BuildTooling(descriptors []*ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to Gemini format

<a name="GeminiToolProvider.ChatWithTools"></a>
### func \(\*GeminiToolProvider\) ChatWithTools

```go
func (p *GeminiToolProvider) ChatWithTools(ctx context.Context, req ChatRequest, tools interface{}, toolChoice string) (ChatResponse, []types.MessageToolCall, error)
```

ChatWithTools performs a chat request with tool support

<a name="GeminiToolProvider.ContinueWithToolResults"></a>
### func \(\*GeminiToolProvider\) ContinueWithToolResults

```go
func (p *GeminiToolProvider) ContinueWithToolResults(ctx context.Context, req ChatRequest, prior ChatResponse, tools interface{}, toolChoice string, results []types.MessageToolResult) (ChatResponse, []types.MessageToolCall, error)
```

ContinueWithToolResults continues conversation with tool results

<a name="MockProvider"></a>
## type MockProvider

MockProvider is a simple mock provider for testing and development. It returns canned responses without making any API calls.

```go
type MockProvider struct {
    // contains filtered or unexported fields
}
```

<a name="NewMockProvider"></a>
### func NewMockProvider

```go
func NewMockProvider(id, model string, includeRawOutput bool) *MockProvider
```

NewMockProvider creates a new mock provider.

<a name="MockProvider.CalculateCost"></a>
### func \(\*MockProvider\) CalculateCost

```go
func (m *MockProvider) CalculateCost(inputTokens, outputTokens, cachedTokens int) types.CostInfo
```

CalculateCost calculates cost breakdown for given token counts.

<a name="MockProvider.Chat"></a>
### func \(\*MockProvider\) Chat

```go
func (m *MockProvider) Chat(ctx context.Context, req ChatRequest) (ChatResponse, error)
```

Chat returns a mock response.

<a name="MockProvider.ChatStream"></a>
### func \(\*MockProvider\) ChatStream

```go
func (m *MockProvider) ChatStream(ctx context.Context, req ChatRequest) (<-chan StreamChunk, error)
```

ChatStream returns a mock streaming response.

<a name="MockProvider.Close"></a>
### func \(\*MockProvider\) Close

```go
func (m *MockProvider) Close() error
```

Close is a no\-op for the mock provider.

<a name="MockProvider.ID"></a>
### func \(\*MockProvider\) ID

```go
func (m *MockProvider) ID() string
```

ID returns the provider ID.

<a name="MockProvider.ShouldIncludeRawOutput"></a>
### func \(\*MockProvider\) ShouldIncludeRawOutput

```go
func (m *MockProvider) ShouldIncludeRawOutput() bool
```

ShouldIncludeRawOutput returns whether raw API responses should be included.

<a name="MockProvider.SupportsStreaming"></a>
### func \(\*MockProvider\) SupportsStreaming

```go
func (m *MockProvider) SupportsStreaming() bool
```

SupportsStreaming indicates whether the provider supports streaming.

<a name="OpenAIProvider"></a>
## type OpenAIProvider

OpenAIProvider implements the Provider interface for OpenAI

```go
type OpenAIProvider struct {
    // contains filtered or unexported fields
}
```

<a name="NewOpenAIProvider"></a>
### func NewOpenAIProvider

```go
func NewOpenAIProvider(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool) *OpenAIProvider
```

NewOpenAIProvider creates a new OpenAI provider

<a name="OpenAIProvider.CalculateCost"></a>
### func \(\*OpenAIProvider\) CalculateCost

```go
func (p *OpenAIProvider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="OpenAIProvider.Chat"></a>
### func \(\*OpenAIProvider\) Chat

```go
func (p *OpenAIProvider) Chat(ctx context.Context, req ChatRequest) (ChatResponse, error)
```

Chat sends a chat request to OpenAI

<a name="OpenAIProvider.ChatStream"></a>
### func \(\*OpenAIProvider\) ChatStream

```go
func (p *OpenAIProvider) ChatStream(ctx context.Context, req ChatRequest) (<-chan StreamChunk, error)
```

ChatStream streams a chat response from OpenAI

<a name="OpenAIProvider.Close"></a>
### func \(\*OpenAIProvider\) Close

```go
func (p *OpenAIProvider) Close() error
```

Close closes the HTTP client and cleans up idle connections

<a name="OpenAIProvider.ID"></a>
### func \(\*OpenAIProvider\) ID

```go
func (p *OpenAIProvider) ID() string
```

ID returns the provider ID

<a name="OpenAIProvider.ShouldIncludeRawOutput"></a>
### func \(\*OpenAIProvider\) ShouldIncludeRawOutput

```go
func (p *OpenAIProvider) ShouldIncludeRawOutput() bool
```

ShouldIncludeRawOutput returns whether to include raw API requests in output

<a name="OpenAIProvider.SupportsStreaming"></a>
### func \(\*OpenAIProvider\) SupportsStreaming

```go
func (p *OpenAIProvider) SupportsStreaming() bool
```

SupportsStreaming returns true for OpenAI

<a name="OpenAIToolProvider"></a>
## type OpenAIToolProvider

OpenAIToolProvider extends OpenAIProvider with tool support

```go
type OpenAIToolProvider struct {
    *OpenAIProvider
}
```

<a name="NewOpenAIToolProvider"></a>
### func NewOpenAIToolProvider

```go
func NewOpenAIToolProvider(id, model, baseURL string, defaults ProviderDefaults, includeRawOutput bool) *OpenAIToolProvider
```

NewOpenAIToolProvider creates a new OpenAI provider with tool support

<a name="OpenAIToolProvider.BuildTooling"></a>
### func \(\*OpenAIToolProvider\) BuildTooling

```go
func (p *OpenAIToolProvider) BuildTooling(descriptors []*ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to OpenAI format

<a name="OpenAIToolProvider.ChatWithTools"></a>
### func \(\*OpenAIToolProvider\) ChatWithTools

```go
func (p *OpenAIToolProvider) ChatWithTools(ctx context.Context, req ChatRequest, tools interface{}, toolChoice string) (ChatResponse, []types.MessageToolCall, error)
```

ChatWithTools performs a chat request with tool support

<a name="OpenAIToolProvider.ContinueWithToolResults"></a>
### func \(\*OpenAIToolProvider\) ContinueWithToolResults

```go
func (p *OpenAIToolProvider) ContinueWithToolResults(ctx context.Context, req ChatRequest, prior ChatResponse, tools interface{}, toolChoice string, results []types.MessageToolResult) (ChatResponse, []types.MessageToolCall, error)
```

ContinueWithToolResults continues conversation with tool results

<a name="Pricing"></a>
## type Pricing

Pricing defines cost per 1K tokens for input and output

```go
type Pricing struct {
    InputCostPer1K  float64
    OutputCostPer1K float64
}
```

<a name="Provider"></a>
## type Provider

Provider interface defines the contract for chat providers

```go
type Provider interface {
    ID() string
    Chat(ctx context.Context, req ChatRequest) (ChatResponse, error)

    // Streaming support
    ChatStream(ctx context.Context, req ChatRequest) (<-chan StreamChunk, error)
    SupportsStreaming() bool

    ShouldIncludeRawOutput() bool
    Close() error // Close cleans up provider resources (e.g., HTTP connections)

    // CalculateCost calculates cost breakdown for given token counts
    CalculateCost(inputTokens, outputTokens, cachedTokens int) types.CostInfo
}
```

<a name="CreateProviderFromSpec"></a>
### func CreateProviderFromSpec

```go
func CreateProviderFromSpec(spec ProviderSpec) (Provider, error)
```

CreateProviderFromSpec creates a provider implementation from a spec. Returns an error if the provider type is unsupported.

<a name="ProviderDefaults"></a>
## type ProviderDefaults

ProviderDefaults holds default parameters for providers

```go
type ProviderDefaults struct {
    Temperature float32
    TopP        float32
    MaxTokens   int
    Pricing     Pricing
}
```

<a name="ProviderSpec"></a>
## type ProviderSpec

ProviderSpec holds the configuration needed to create a provider instance

```go
type ProviderSpec struct {
    ID               string
    Type             string
    Model            string
    BaseURL          string
    Defaults         ProviderDefaults
    IncludeRawOutput bool
}
```

<a name="Registry"></a>
## type Registry

Registry manages available providers

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new provider registry

<a name="Registry.Close"></a>
### func \(\*Registry\) Close

```go
func (r *Registry) Close() error
```

Close closes all registered providers and cleans up their resources

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(id string) (Provider, bool)
```

Get retrieves a provider by ID

<a name="Registry.List"></a>
### func \(\*Registry\) List

```go
func (r *Registry) List() []string
```

List returns all registered provider IDs

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(provider Provider)
```

Register adds a provider to the registry

<a name="SSEScanner"></a>
## type SSEScanner

SSEScanner scans Server\-Sent Events \(SSE\) streams

```go
type SSEScanner struct {
    // contains filtered or unexported fields
}
```

<a name="NewSSEScanner"></a>
### func NewSSEScanner

```go
func NewSSEScanner(r io.Reader) *SSEScanner
```

NewSSEScanner creates a new SSE scanner

<a name="SSEScanner.Data"></a>
### func \(\*SSEScanner\) Data

```go
func (s *SSEScanner) Data() string
```

Data returns the current event data

<a name="SSEScanner.Err"></a>
### func \(\*SSEScanner\) Err

```go
func (s *SSEScanner) Err() error
```

Err returns any scanning error

<a name="SSEScanner.Scan"></a>
### func \(\*SSEScanner\) Scan

```go
func (s *SSEScanner) Scan() bool
```

Scan advances to the next SSE event

<a name="StreamChunk"></a>
## type StreamChunk

StreamChunk represents a batch of tokens with metadata

```go
type StreamChunk struct {
    // Content is the accumulated content so far
    Content string `json:"content"`

    // Delta is the new content in this chunk
    Delta string `json:"delta"`

    // TokenCount is the total number of tokens so far
    TokenCount int `json:"token_count"`

    // DeltaTokens is the number of tokens in this delta
    DeltaTokens int `json:"delta_tokens"`

    // ToolCalls contains accumulated tool calls (for assistant messages that invoke tools)
    ToolCalls []types.MessageToolCall `json:"tool_calls,omitempty"`

    // FinishReason is nil until stream is complete
    // Values: "stop", "length", "content_filter", "tool_calls", "error", "validation_failed", "cancelled"
    FinishReason *string `json:"finish_reason,omitempty"`

    // Error is set if an error occurred during streaming
    Error error `json:"error,omitempty"`

    // Metadata contains provider-specific metadata
    Metadata map[string]interface{} `json:"metadata,omitempty"`

    // FinalResult contains the complete execution result (only set in the final chunk)
    FinalResult ExecutionResult `json:"final_result,omitempty"`

    // CostInfo contains cost breakdown (only present in final chunk when FinishReason != nil)
    CostInfo *types.CostInfo `json:"cost_info,omitempty"`
}
```

<a name="StreamEvent"></a>
## type StreamEvent

StreamEvent is sent to observers for monitoring

```go
type StreamEvent struct {
    // Type is the event type: "chunk", "complete", "error"
    Type string `json:"type"`

    // Chunk contains the stream chunk data
    Chunk *StreamChunk `json:"chunk,omitempty"`

    // Error is set for error events
    Error error `json:"error,omitempty"`

    // Timestamp is when the event occurred
    Timestamp time.Time `json:"timestamp"`
}
```

<a name="StreamObserver"></a>
## type StreamObserver

StreamObserver receives stream events for monitoring

```go
type StreamObserver interface {
    OnChunk(chunk StreamChunk)
    OnComplete(totalTokens int, duration time.Duration)
    OnError(err error)
}
```

<a name="ToolDescriptor"></a>
## type ToolDescriptor

ToolDescriptor represents a tool that can be used by providers

```go
type ToolDescriptor struct {
    Name         string          `json:"name"`
    Description  string          `json:"description"`
    InputSchema  json.RawMessage `json:"input_schema"`
    OutputSchema json.RawMessage `json:"output_schema"`
}
```

<a name="ToolResult"></a>
## type ToolResult

ToolResult represents the result of a tool execution This is an alias to types.MessageToolResult for provider\-specific context

```go
type ToolResult = types.MessageToolResult
```

<a name="ToolSupport"></a>
## type ToolSupport

ToolSupport interface for providers that support tool/function calling

```go
type ToolSupport interface {
    Provider // Extends the base Provider interface

    // BuildTooling converts tool descriptors to provider-native format
    BuildTooling(descriptors []*ToolDescriptor) (interface{}, error)

    // ChatWithTools performs a chat request with tool support
    ChatWithTools(ctx context.Context, req ChatRequest, tools interface{}, toolChoice string) (ChatResponse, []types.MessageToolCall, error)

    // ContinueWithToolResults continues conversation with tool results
    // req contains the original messages, prior is the response with tool calls, results are tool outputs
    ContinueWithToolResults(ctx context.Context, req ChatRequest, prior ChatResponse, tools interface{}, toolChoice string, results []types.MessageToolResult) (ChatResponse, []types.MessageToolCall, error)
}
```

<a name="UnsupportedProviderError"></a>
## type UnsupportedProviderError

UnsupportedProviderError is returned when a provider type is not recognized

```go
type UnsupportedProviderError struct {
    ProviderType string
}
```

<a name="UnsupportedProviderError.Error"></a>
### func \(\*UnsupportedProviderError\) Error

```go
func (e *UnsupportedProviderError) Error() string
```



<a name="ValidationAbortError"></a>
## type ValidationAbortError

ValidationAbortError is returned when a streaming validator aborts a stream

```go
type ValidationAbortError struct {
    Reason string
    Chunk  StreamChunk
}
```

<a name="ValidationAbortError.Error"></a>
### func \(\*ValidationAbortError\) Error

```go
func (e *ValidationAbortError) Error() string
```



# statestore

```go
import "github.com/AltairaLabs/PromptKit/runtime/statestore"
```

## Index

- [Variables](<#variables>)
- [type ConversationState](<#ConversationState>)
- [type ListOptions](<#ListOptions>)
- [type MemoryStore](<#MemoryStore>)
  - [func NewMemoryStore\(\) \*MemoryStore](<#NewMemoryStore>)
  - [func \(s \*MemoryStore\) Delete\(ctx context.Context, id string\) error](<#MemoryStore.Delete>)
  - [func \(s \*MemoryStore\) List\(ctx context.Context, opts ListOptions\) \(\[\]string, error\)](<#MemoryStore.List>)
  - [func \(s \*MemoryStore\) Load\(ctx context.Context, id string\) \(\*ConversationState, error\)](<#MemoryStore.Load>)
  - [func \(s \*MemoryStore\) Save\(ctx context.Context, state \*ConversationState\) error](<#MemoryStore.Save>)
- [type RedisOption](<#RedisOption>)
  - [func WithPrefix\(prefix string\) RedisOption](<#WithPrefix>)
  - [func WithTTL\(ttl time.Duration\) RedisOption](<#WithTTL>)
- [type RedisStore](<#RedisStore>)
  - [func NewRedisStore\(client \*redis.Client, opts ...RedisOption\) \*RedisStore](<#NewRedisStore>)
  - [func \(s \*RedisStore\) Delete\(ctx context.Context, id string\) error](<#RedisStore.Delete>)
  - [func \(s \*RedisStore\) List\(ctx context.Context, opts ListOptions\) \(\[\]string, error\)](<#RedisStore.List>)
  - [func \(s \*RedisStore\) Load\(ctx context.Context, id string\) \(\*ConversationState, error\)](<#RedisStore.Load>)
  - [func \(s \*RedisStore\) Save\(ctx context.Context, state \*ConversationState\) error](<#RedisStore.Save>)
- [type Store](<#Store>)
- [type Summary](<#Summary>)


## Variables

<a name="ErrInvalidID"></a>ErrInvalidID is returned when an invalid conversation ID is provided.

```go
var ErrInvalidID = errors.New("invalid conversation ID")
```

<a name="ErrInvalidState"></a>ErrInvalidState is returned when a conversation state is invalid.

```go
var ErrInvalidState = errors.New("invalid conversation state")
```

<a name="ErrNotFound"></a>ErrNotFound is returned when a conversation doesn't exist in the store.

```go
var ErrNotFound = errors.New("conversation not found")
```

<a name="ConversationState"></a>
## type ConversationState

ConversationState represents stored conversation state in the state store. This is the primary data structure for persisting and loading conversation history.

```go
type ConversationState struct {
    ID             string                 // Unique conversation identifier
    UserID         string                 // User who owns this conversation
    Messages       []types.Message        // Message history (using unified types.Message)
    SystemPrompt   string                 // System prompt for this conversation
    Summaries      []Summary              // Compressed summaries of old turns
    TokenCount     int                    // Total tokens in messages
    LastAccessedAt time.Time              // Last time conversation was accessed
    Metadata       map[string]interface{} // Arbitrary metadata (e.g., extracted context)
}
```

<a name="ListOptions"></a>
## type ListOptions

ListOptions provides filtering and pagination options for listing conversations.

```go
type ListOptions struct {
    // UserID filters conversations by the user who owns them.
    // If empty, all conversations are returned (subject to pagination).
    UserID string

    // Limit is the maximum number of conversation IDs to return.
    // If 0, a default limit (e.g., 100) should be applied.
    Limit int

    // Offset is the number of conversations to skip (for pagination).
    Offset int

    // SortBy specifies the field to sort by (e.g., "created_at", "updated_at").
    // If empty, implementation-specific default sorting is used.
    SortBy string

    // SortOrder specifies sort direction: "asc" or "desc".
    // If empty, defaults to "desc" (newest first).
    SortOrder string
}
```

<a name="MemoryStore"></a>
## type MemoryStore

MemoryStore provides an in\-memory implementation of the Store interface. It is thread\-safe and suitable for development, testing, and single\-instance deployments. For distributed systems, use RedisStore or a database\-backed implementation.

```go
type MemoryStore struct {
    // contains filtered or unexported fields
}
```

<a name="NewMemoryStore"></a>
### func NewMemoryStore

```go
func NewMemoryStore() *MemoryStore
```

NewMemoryStore creates a new in\-memory state store.

<a name="MemoryStore.Delete"></a>
### func \(\*MemoryStore\) Delete

```go
func (s *MemoryStore) Delete(ctx context.Context, id string) error
```

Delete removes a conversation state by ID.

<a name="MemoryStore.List"></a>
### func \(\*MemoryStore\) List

```go
func (s *MemoryStore) List(ctx context.Context, opts ListOptions) ([]string, error)
```

List returns conversation IDs matching the given criteria.

<a name="MemoryStore.Load"></a>
### func \(\*MemoryStore\) Load

```go
func (s *MemoryStore) Load(ctx context.Context, id string) (*ConversationState, error)
```

Load retrieves a conversation state by ID. Returns a deep copy to prevent external mutations.

<a name="MemoryStore.Save"></a>
### func \(\*MemoryStore\) Save

```go
func (s *MemoryStore) Save(ctx context.Context, state *ConversationState) error
```

Save persists a conversation state. If it already exists, it will be updated.

<a name="RedisOption"></a>
## type RedisOption

RedisOption configures a RedisStore.

```go
type RedisOption func(*RedisStore)
```

<a name="WithPrefix"></a>
### func WithPrefix

```go
func WithPrefix(prefix string) RedisOption
```

WithPrefix sets the key prefix for Redis keys. Default is "promptkit".

<a name="WithTTL"></a>
### func WithTTL

```go
func WithTTL(ttl time.Duration) RedisOption
```

WithTTL sets the time\-to\-live for conversation states. After this duration, conversations will be automatically deleted. Default is 24 hours. Set to 0 for no expiration.

<a name="RedisStore"></a>
## type RedisStore

RedisStore provides a Redis\-backed implementation of the Store interface. It uses JSON serialization for state storage and supports automatic TTL\-based cleanup. This implementation is suitable for distributed systems and production deployments.

```go
type RedisStore struct {
    // contains filtered or unexported fields
}
```

<a name="NewRedisStore"></a>
### func NewRedisStore

```go
func NewRedisStore(client *redis.Client, opts ...RedisOption) *RedisStore
```

NewRedisStore creates a new Redis\-backed state store.

Example:

```
store := NewRedisStore(
    redis.NewClient(&redis.Options{Addr: "localhost:6379"}),
    WithTTL(24 * time.Hour),
    WithPrefix("myapp"),
)
```

<a name="RedisStore.Delete"></a>
### func \(\*RedisStore\) Delete

```go
func (s *RedisStore) Delete(ctx context.Context, id string) error
```

Delete removes a conversation state from Redis.

<a name="RedisStore.List"></a>
### func \(\*RedisStore\) List

```go
func (s *RedisStore) List(ctx context.Context, opts ListOptions) ([]string, error)
```

List returns conversation IDs matching the given criteria.

<a name="RedisStore.Load"></a>
### func \(\*RedisStore\) Load

```go
func (s *RedisStore) Load(ctx context.Context, id string) (*ConversationState, error)
```

Load retrieves a conversation state by ID from Redis.

<a name="RedisStore.Save"></a>
### func \(\*RedisStore\) Save

```go
func (s *RedisStore) Save(ctx context.Context, state *ConversationState) error
```

Save persists a conversation state to Redis with TTL.

<a name="Store"></a>
## type Store

Store defines the interface for persistent conversation state storage.

```go
type Store interface {
    // Load retrieves conversation state by ID
    Load(ctx context.Context, id string) (*ConversationState, error)

    // Save persists conversation state
    Save(ctx context.Context, state *ConversationState) error
}
```

<a name="Summary"></a>
## type Summary

Summary represents a compressed version of conversation turns. Used to maintain context while reducing token count for older conversations.

```go
type Summary struct {
    StartTurn  int       // First turn included in this summary
    EndTurn    int       // Last turn included in this summary
    Content    string    // Summarized content
    TokenCount int       // Token count of the summary
    CreatedAt  time.Time // When this summary was created
}
```

# template

```go
import "github.com/AltairaLabs/PromptKit/runtime/template"
```

Package template provides template rendering and variable substitution.

This package implements a flexible template system that can be used by both prompts and personas. It supports:

- Variable substitution with \{\{variable\}\} syntax
- Recursive template resolution \(variables can contain other variables\)
- Validation of required variables
- Detection of unresolved placeholders

Future versions may support more advanced templating engines like Go templates \(similar to Helm charts\) for conditional logic, loops, and functions.

## Index

- [func GetUsedVars\(vars map\[string\]string\) \[\]string](<#GetUsedVars>)
- [type Renderer](<#Renderer>)
  - [func NewRenderer\(\) \*Renderer](<#NewRenderer>)
  - [func \(r \*Renderer\) MergeVars\(varMaps ...map\[string\]string\) map\[string\]string](<#Renderer.MergeVars>)
  - [func \(r \*Renderer\) Render\(templateText string, vars map\[string\]string\) \(string, error\)](<#Renderer.Render>)
  - [func \(r \*Renderer\) ValidateRequiredVars\(requiredVars \[\]string, vars map\[string\]string\) error](<#Renderer.ValidateRequiredVars>)


<a name="GetUsedVars"></a>
## func GetUsedVars

```go
func GetUsedVars(vars map[string]string) []string
```

GetUsedVars returns a list of variable names that had non\-empty values. This is useful for debugging and logging which variables were actually used.

<a name="Renderer"></a>
## type Renderer

Renderer handles variable substitution in templates

```go
type Renderer struct {
}
```

<a name="NewRenderer"></a>
### func NewRenderer

```go
func NewRenderer() *Renderer
```

NewRenderer creates a new template renderer

<a name="Renderer.MergeVars"></a>
### func \(\*Renderer\) MergeVars

```go
func (r *Renderer) MergeVars(varMaps ...map[string]string) map[string]string
```

MergeVars merges multiple variable maps with later maps taking precedence. This is useful for combining default values, context variables, and overrides.

Example:

```
defaults := map[string]string{"color": "blue", "size": "medium"}
overrides := map[string]string{"color": "red"}
result := MergeVars(defaults, overrides)
// result = {"color": "red", "size": "medium"}
```

<a name="Renderer.Render"></a>
### func \(\*Renderer\) Render

```go
func (r *Renderer) Render(templateText string, vars map[string]string) (string, error)
```

Render applies variable substitution to the template with recursive resolution.

The renderer performs multiple passes \(up to maxPasses\) to handle nested variable substitution. For example, if var1="\{\{var2\}\}" and var2="value", the final result will correctly resolve to "value".

Returns an error if any placeholders remain unresolved after all passes.

<a name="Renderer.ValidateRequiredVars"></a>
### func \(\*Renderer\) ValidateRequiredVars

```go
func (r *Renderer) ValidateRequiredVars(requiredVars []string, vars map[string]string) error
```

ValidateRequiredVars checks that all required variables are provided and non\-empty. Returns an error listing any missing variables.

# tools

```go
import "github.com/AltairaLabs/PromptKit/runtime/tools"
```

Package tools provides tool/function calling infrastructure for LLM testing.

This package implements a flexible tool execution system with:

- Tool descriptor registry with JSON Schema validation
- Mock executors for testing \(static and template\-based\)
- HTTP executor for live API calls
- Type coercion and result validation
- Adapter for prompt registry integration

Tools can be loaded from YAML/JSON files and executed with argument validation, result schema checking, and automatic type coercion for common mismatches.

## Index

- [type AsyncToolExecutor](<#AsyncToolExecutor>)
- [type ChatMessage](<#ChatMessage>)
- [type ChatRequest](<#ChatRequest>)
- [type ChatResponse](<#ChatResponse>)
- [type Coercion](<#Coercion>)
- [type Executor](<#Executor>)
- [type HTTPConfig](<#HTTPConfig>)
- [type MCPExecutor](<#MCPExecutor>)
  - [func NewMCPExecutor\(registry mcp.Registry\) \*MCPExecutor](<#NewMCPExecutor>)
  - [func \(e \*MCPExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MCPExecutor.Execute>)
  - [func \(e \*MCPExecutor\) Name\(\) string](<#MCPExecutor.Name>)
- [type MockScriptedExecutor](<#MockScriptedExecutor>)
  - [func NewMockScriptedExecutor\(\) \*MockScriptedExecutor](<#NewMockScriptedExecutor>)
  - [func \(e \*MockScriptedExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MockScriptedExecutor.Execute>)
  - [func \(e \*MockScriptedExecutor\) Name\(\) string](<#MockScriptedExecutor.Name>)
- [type MockStaticExecutor](<#MockStaticExecutor>)
  - [func NewMockStaticExecutor\(\) \*MockStaticExecutor](<#NewMockStaticExecutor>)
  - [func \(e \*MockStaticExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MockStaticExecutor.Execute>)
  - [func \(e \*MockStaticExecutor\) Name\(\) string](<#MockStaticExecutor.Name>)
- [type PendingToolInfo](<#PendingToolInfo>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func NewRegistryWithRepository\(repository ToolRepository\) \*Registry](<#NewRegistryWithRepository>)
  - [func \(r \*Registry\) Execute\(toolName string, args json.RawMessage\) \(\*ToolResult, error\)](<#Registry.Execute>)
  - [func \(r \*Registry\) ExecuteAsync\(toolName string, args json.RawMessage\) \(\*ToolExecutionResult, error\)](<#Registry.ExecuteAsync>)
  - [func \(r \*Registry\) Get\(name string\) \*ToolDescriptor](<#Registry.Get>)
  - [func \(r \*Registry\) GetTool\(name string\) \(\*ToolDescriptor, error\)](<#Registry.GetTool>)
  - [func \(r \*Registry\) GetTools\(\) map\[string\]\*ToolDescriptor](<#Registry.GetTools>)
  - [func \(r \*Registry\) GetToolsByNames\(names \[\]string\) \(\[\]\*ToolDescriptor, error\)](<#Registry.GetToolsByNames>)
  - [func \(r \*Registry\) List\(\) \[\]string](<#Registry.List>)
  - [func \(r \*Registry\) LoadToolFromBytes\(filename string, data \[\]byte\) error](<#Registry.LoadToolFromBytes>)
  - [func \(r \*Registry\) LoadToolsFromData\(tools \[\]ToolData\) error](<#Registry.LoadToolsFromData>)
  - [func \(r \*Registry\) Register\(descriptor \*ToolDescriptor\) error](<#Registry.Register>)
  - [func \(r \*Registry\) RegisterExecutor\(executor Executor\)](<#Registry.RegisterExecutor>)
- [type SchemaValidator](<#SchemaValidator>)
  - [func NewSchemaValidator\(\) \*SchemaValidator](<#NewSchemaValidator>)
  - [func \(sv \*SchemaValidator\) CoerceResult\(descriptor \*ToolDescriptor, result json.RawMessage\) \(json.RawMessage, \[\]Coercion, error\)](<#SchemaValidator.CoerceResult>)
  - [func \(sv \*SchemaValidator\) ValidateArgs\(descriptor \*ToolDescriptor, args json.RawMessage\) error](<#SchemaValidator.ValidateArgs>)
  - [func \(sv \*SchemaValidator\) ValidateResult\(descriptor \*ToolDescriptor, result json.RawMessage\) error](<#SchemaValidator.ValidateResult>)
- [type ToolCall](<#ToolCall>)
- [type ToolConfig](<#ToolConfig>)
- [type ToolData](<#ToolData>)
- [type ToolDescriptor](<#ToolDescriptor>)
- [type ToolExecutionResult](<#ToolExecutionResult>)
- [type ToolExecutionStatus](<#ToolExecutionStatus>)
- [type ToolGuidance](<#ToolGuidance>)
- [type ToolPolicy](<#ToolPolicy>)
- [type ToolRepository](<#ToolRepository>)
- [type ToolResult](<#ToolResult>)
- [type ToolStats](<#ToolStats>)
- [type ToolSupport](<#ToolSupport>)
- [type ValidationError](<#ValidationError>)
  - [func \(e \*ValidationError\) Error\(\) string](<#ValidationError.Error>)


<a name="AsyncToolExecutor"></a>
## type AsyncToolExecutor

AsyncToolExecutor is a tool that can return pending status instead of blocking. Tools that require human approval or external async operations should implement this.

```go
type AsyncToolExecutor interface {
    Executor // Still implements the basic Executor interface

    // ExecuteAsync may return immediately with a pending status
    ExecuteAsync(descriptor *ToolDescriptor, args json.RawMessage) (*ToolExecutionResult, error)
}
```

<a name="ChatMessage"></a>
## type ChatMessage

ChatMessage represents a chat message \(simplified version for tool context\)

```go
type ChatMessage struct {
    Role               string     `json:"role"`
    Content            string     `json:"content"`
    ToolCalls          []ToolCall `json:"tool_calls,omitempty"`
    ToolCallResponseID string     `json:"tool_call_id,omitempty"` // For tool result messages
}
```

<a name="ChatRequest"></a>
## type ChatRequest

ChatRequest represents a chat request \(extending existing type\)

```go
type ChatRequest struct {
    System      string        `json:"system"`
    Messages    []ChatMessage `json:"messages"`
    Temperature float32       `json:"temperature"`
    TopP        float32       `json:"top_p"`
    MaxTokens   int           `json:"max_tokens"`
    Seed        *int          `json:"seed,omitempty"`
}
```

<a name="ChatResponse"></a>
## type ChatResponse

ChatResponse represents a chat response \(extending existing type\)

```go
type ChatResponse struct {
    Content   string        `json:"content"`
    TokensIn  int           `json:"tokens_in"`
    TokensOut int           `json:"tokens_out"`
    Latency   time.Duration `json:"latency"`
    Raw       []byte        `json:"raw,omitempty"`
    ToolCalls []ToolCall    `json:"tool_calls,omitempty"` // Tools called in this response
}
```

<a name="Coercion"></a>
## type Coercion

Coercion represents a type coercion that was performed

```go
type Coercion struct {
    Path string      `json:"path"`
    From interface{} `json:"from"`
    To   interface{} `json:"to"`
}
```

<a name="Executor"></a>
## type Executor

Executor interface defines how tools are executed

```go
type Executor interface {
    Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
    Name() string
}
```

<a name="HTTPConfig"></a>
## type HTTPConfig

HTTPConfig defines configuration for live HTTP tool execution

```go
type HTTPConfig struct {
    URL            string            `json:"url" yaml:"url"`
    Method         string            `json:"method" yaml:"method"`
    HeadersFromEnv []string          `json:"headers_from_env,omitempty" yaml:"headers_from_env,omitempty"`
    TimeoutMs      int               `json:"timeout_ms" yaml:"timeout_ms"`
    Redact         []string          `json:"redact,omitempty" yaml:"redact,omitempty"`
    Headers        map[string]string `json:"headers,omitempty" yaml:"headers,omitempty"`
}
```

<a name="MCPExecutor"></a>
## type MCPExecutor

MCPExecutor executes tools using MCP \(Model Context Protocol\) servers

```go
type MCPExecutor struct {
    // contains filtered or unexported fields
}
```

<a name="NewMCPExecutor"></a>
### func NewMCPExecutor

```go
func NewMCPExecutor(registry mcp.Registry) *MCPExecutor
```

NewMCPExecutor creates a new MCP executor

<a name="MCPExecutor.Execute"></a>
### func \(\*MCPExecutor\) Execute

```go
func (e *MCPExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using an MCP server

<a name="MCPExecutor.Name"></a>
### func \(\*MCPExecutor\) Name

```go
func (e *MCPExecutor) Name() string
```

Name returns the executor name

<a name="MockScriptedExecutor"></a>
## type MockScriptedExecutor

MockScriptedExecutor executes tools using templated mock data

```go
type MockScriptedExecutor struct{}
```

<a name="NewMockScriptedExecutor"></a>
### func NewMockScriptedExecutor

```go
func NewMockScriptedExecutor() *MockScriptedExecutor
```

NewMockScriptedExecutor creates a new scripted mock executor

<a name="MockScriptedExecutor.Execute"></a>
### func \(\*MockScriptedExecutor\) Execute

```go
func (e *MockScriptedExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using templated mock data

<a name="MockScriptedExecutor.Name"></a>
### func \(\*MockScriptedExecutor\) Name

```go
func (e *MockScriptedExecutor) Name() string
```

Name returns the executor name

<a name="MockStaticExecutor"></a>
## type MockStaticExecutor

MockStaticExecutor executes tools using static mock data

```go
type MockStaticExecutor struct{}
```

<a name="NewMockStaticExecutor"></a>
### func NewMockStaticExecutor

```go
func NewMockStaticExecutor() *MockStaticExecutor
```

NewMockStaticExecutor creates a new static mock executor

<a name="MockStaticExecutor.Execute"></a>
### func \(\*MockStaticExecutor\) Execute

```go
func (e *MockStaticExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using static mock data

<a name="MockStaticExecutor.Name"></a>
### func \(\*MockStaticExecutor\) Name

```go
func (e *MockStaticExecutor) Name() string
```

Name returns the executor name

<a name="PendingToolInfo"></a>
## type PendingToolInfo

PendingToolInfo provides context for middleware \(email templates, notifications\)

```go
type PendingToolInfo struct {
    // Reason for pending (e.g., "requires_approval", "waiting_external_api")
    Reason string `json:"reason"`

    // Human-readable description
    Message string `json:"message"`

    // Tool details (for middleware to use in notifications)
    ToolName string          `json:"tool_name"`
    Args     json.RawMessage `json:"args"`

    // Optional: expiration, callback URL, etc.
    ExpiresAt   *time.Time `json:"expires_at,omitempty"`
    CallbackURL string     `json:"callback_url,omitempty"`

    // Arbitrary metadata for custom middleware
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

<a name="Registry"></a>
## type Registry

Registry manages tool descriptors and provides access to executors

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new tool registry without a repository backend \(legacy mode\)

<a name="NewRegistryWithRepository"></a>
### func NewRegistryWithRepository

```go
func NewRegistryWithRepository(repository ToolRepository) *Registry
```

NewRegistryWithRepository creates a new tool registry with a repository backend

<a name="Registry.Execute"></a>
### func \(\*Registry\) Execute

```go
func (r *Registry) Execute(toolName string, args json.RawMessage) (*ToolResult, error)
```

Execute executes a tool with the given arguments

<a name="Registry.ExecuteAsync"></a>
### func \(\*Registry\) ExecuteAsync

```go
func (r *Registry) ExecuteAsync(toolName string, args json.RawMessage) (*ToolExecutionResult, error)
```

ExecuteAsync executes a tool with async support, checking if it implements AsyncToolExecutor. Returns ToolExecutionResult with status \(complete/pending/failed\).

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(name string) *ToolDescriptor
```

Get retrieves a tool descriptor by name with repository fallback

<a name="Registry.GetTool"></a>
### func \(\*Registry\) GetTool

```go
func (r *Registry) GetTool(name string) (*ToolDescriptor, error)
```

GetTool retrieves a tool descriptor by name

<a name="Registry.GetTools"></a>
### func \(\*Registry\) GetTools

```go
func (r *Registry) GetTools() map[string]*ToolDescriptor
```

GetTools returns all loaded tool descriptors

<a name="Registry.GetToolsByNames"></a>
### func \(\*Registry\) GetToolsByNames

```go
func (r *Registry) GetToolsByNames(names []string) ([]*ToolDescriptor, error)
```

GetToolsByNames returns tool descriptors for the specified names

<a name="Registry.List"></a>
### func \(\*Registry\) List

```go
func (r *Registry) List() []string
```

List returns all tool names from repository or cache

<a name="Registry.LoadToolFromBytes"></a>
### func \(\*Registry\) LoadToolFromBytes

```go
func (r *Registry) LoadToolFromBytes(filename string, data []byte) error
```

LoadToolFromBytes loads a tool descriptor from raw bytes data. This is useful when tool data has already been read from a file or received from another source, avoiding redundant file I/O. The filename parameter is used only for error reporting.

<a name="Registry.LoadToolsFromData"></a>
### func \(\*Registry\) LoadToolsFromData

```go
func (r *Registry) LoadToolsFromData(tools []ToolData) error
```

LoadToolsFromData loads tool descriptors from a slice of ToolData. Returns error if any tool fails to load.

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(descriptor *ToolDescriptor) error
```

Register adds a tool descriptor to the registry with validation

<a name="Registry.RegisterExecutor"></a>
### func \(\*Registry\) RegisterExecutor

```go
func (r *Registry) RegisterExecutor(executor Executor)
```

RegisterExecutor registers a tool executor

<a name="SchemaValidator"></a>
## type SchemaValidator

SchemaValidator handles JSON schema validation for tool inputs and outputs

```go
type SchemaValidator struct {
    // contains filtered or unexported fields
}
```

<a name="NewSchemaValidator"></a>
### func NewSchemaValidator

```go
func NewSchemaValidator() *SchemaValidator
```

NewSchemaValidator creates a new schema validator

<a name="SchemaValidator.CoerceResult"></a>
### func \(\*SchemaValidator\) CoerceResult

```go
func (sv *SchemaValidator) CoerceResult(descriptor *ToolDescriptor, result json.RawMessage) (json.RawMessage, []Coercion, error)
```

CoerceResult attempts to coerce simple type mismatches in tool results

<a name="SchemaValidator.ValidateArgs"></a>
### func \(\*SchemaValidator\) ValidateArgs

```go
func (sv *SchemaValidator) ValidateArgs(descriptor *ToolDescriptor, args json.RawMessage) error
```

ValidateArgs validates tool arguments against the input schema

<a name="SchemaValidator.ValidateResult"></a>
### func \(\*SchemaValidator\) ValidateResult

```go
func (sv *SchemaValidator) ValidateResult(descriptor *ToolDescriptor, result json.RawMessage) error
```

ValidateResult validates tool result against the output schema

<a name="ToolCall"></a>
## type ToolCall

ToolCall represents a tool invocation request

```go
type ToolCall struct {
    Name string          `json:"name"`
    Args json.RawMessage `json:"args"`
    ID   string          `json:"id"` // Provider-specific call ID
}
```

<a name="ToolConfig"></a>
## type ToolConfig

ToolConfig represents a K8s\-style tool configuration manifest

```go
type ToolConfig struct {
    APIVersion string            `yaml:"apiVersion"`
    Kind       string            `yaml:"kind"`
    Metadata   metav1.ObjectMeta `yaml:"metadata,omitempty"`
    Spec       ToolDescriptor    `yaml:"spec"`
}
```

<a name="ToolData"></a>
## type ToolData

ToolData holds raw tool configuration data with file path

```go
type ToolData struct {
    FilePath string
    Data     []byte
}
```

<a name="ToolDescriptor"></a>
## type ToolDescriptor

ToolDescriptor represents a normalized tool definition

```go
type ToolDescriptor struct {
    Name         string          `json:"name" yaml:"name"`
    Description  string          `json:"description" yaml:"description"`
    InputSchema  json.RawMessage `json:"input_schema" yaml:"input_schema"`   // JSON Schema Draft-07
    OutputSchema json.RawMessage `json:"output_schema" yaml:"output_schema"` // JSON Schema Draft-07
    Mode         string          `json:"mode" yaml:"mode"`                   // "mock" | "live"
    TimeoutMs    int             `json:"timeout_ms" yaml:"timeout_ms"`
    MockResult   json.RawMessage `json:"mock_result,omitempty" yaml:"mock_result,omitempty"`     // Static mock data
    MockTemplate string          `json:"mock_template,omitempty" yaml:"mock_template,omitempty"` // Template for dynamic mocks
    HTTPConfig   *HTTPConfig     `json:"http,omitempty" yaml:"http,omitempty"`                   // Live HTTP configuration
}
```

<a name="ToolExecutionResult"></a>
## type ToolExecutionResult

ToolExecutionResult includes status and optional pending information

```go
type ToolExecutionResult struct {
    Status  ToolExecutionStatus `json:"status"`
    Content json.RawMessage     `json:"content,omitempty"`
    Error   string              `json:"error,omitempty"`

    // Present when Status == ToolStatusPending
    PendingInfo *PendingToolInfo `json:"pending_info,omitempty"`
}
```

<a name="ToolExecutionStatus"></a>
## type ToolExecutionStatus

ToolExecutionStatus represents whether a tool completed or needs external input

```go
type ToolExecutionStatus string
```

<a name="ToolStatusComplete"></a>

```go
const (
    // ToolStatusComplete indicates the tool finished executing
    ToolStatusComplete ToolExecutionStatus = "complete"
    // ToolStatusPending indicates the tool is waiting for external input (e.g., human approval)
    ToolStatusPending ToolExecutionStatus = "pending"
    // ToolStatusFailed indicates the tool execution failed
    ToolStatusFailed ToolExecutionStatus = "failed"
)
```

<a name="ToolGuidance"></a>
## type ToolGuidance

ToolGuidance provides hints for different interaction modes This is a flexible structure that can be extended with task\-specific guidance

```go
type ToolGuidance struct {
    Support   string `json:"support,omitempty"`
    Assistant string `json:"assistant,omitempty"`
    Generic   string `json:"generic,omitempty"`
}
```

<a name="ToolPolicy"></a>
## type ToolPolicy

ToolPolicy defines constraints for tool usage in scenarios

```go
type ToolPolicy struct {
    ToolChoice          string   `json:"tool_choice"` // "auto" | "required" | "none"
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn"`
    MaxTotalToolCalls   int      `json:"max_total_tool_calls"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="ToolRepository"></a>
## type ToolRepository

ToolRepository provides abstract access to tool descriptors \(local interface to avoid import cycles\)

```go
type ToolRepository interface {
    LoadTool(name string) (*ToolDescriptor, error)
    ListTools() ([]string, error)
    SaveTool(descriptor *ToolDescriptor) error
}
```

<a name="ToolResult"></a>
## type ToolResult

ToolResult represents the result of a tool execution

```go
type ToolResult struct {
    Name      string          `json:"name"`
    ID        string          `json:"id"` // Matches ToolCall.ID
    Result    json.RawMessage `json:"result"`
    LatencyMs int64           `json:"latency_ms"`
    Error     string          `json:"error,omitempty"`
}
```

<a name="ToolStats"></a>
## type ToolStats

ToolStats tracks tool usage statistics

```go
type ToolStats struct {
    TotalCalls int            `json:"total_calls"`
    ByTool     map[string]int `json:"by_tool"`
}
```

<a name="ToolSupport"></a>
## type ToolSupport

ToolSupport interface extends provider capabilities with tool support

```go
type ToolSupport interface {
    // BuildTooling converts tool descriptors to provider-native format
    BuildTooling(descriptors []*ToolDescriptor) (interface{}, error)

    // ChatWithTools performs a chat request with tool support
    ChatWithTools(req ChatRequest, tools interface{}, toolChoice string) (ChatResponse, []ToolCall, error)

    // ContinueWithToolResults continues conversation with tool results
    ContinueWithToolResults(prior ChatResponse, results []ToolResult) (ChatResponse, []ToolCall, error)
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a tool validation failure

```go
type ValidationError struct {
    Type   string `json:"type"` // "args_invalid" | "result_invalid" | "policy_violation"
    Tool   string `json:"tool"`
    Detail string `json:"detail"`
    Path   string `json:"path,omitempty"`
}
```

<a name="ValidationError.Error"></a>
### func \(\*ValidationError\) Error

```go
func (e *ValidationError) Error() string
```

Error implements the error interface

# types

```go
import "github.com/AltairaLabs/PromptKit/runtime/types"
```

## Index

- [type CostInfo](<#CostInfo>)
- [type Message](<#Message>)
- [type MessageToolCall](<#MessageToolCall>)
- [type MessageToolResult](<#MessageToolResult>)
- [type ToolDef](<#ToolDef>)
- [type ToolStats](<#ToolStats>)
- [type ValidationError](<#ValidationError>)
- [type ValidationResult](<#ValidationResult>)


<a name="CostInfo"></a>
## type CostInfo

CostInfo tracks token usage and associated costs for LLM operations. All cost values are in USD. Used for both individual messages and aggregated tracking.

```go
type CostInfo struct {
    InputTokens   int     `json:"input_tokens"`              // Number of input tokens consumed
    OutputTokens  int     `json:"output_tokens"`             // Number of output tokens generated
    CachedTokens  int     `json:"cached_tokens,omitempty"`   // Number of cached tokens used (reduces cost)
    InputCostUSD  float64 `json:"input_cost_usd"`            // Cost of input tokens in USD
    OutputCostUSD float64 `json:"output_cost_usd"`           // Cost of output tokens in USD
    CachedCostUSD float64 `json:"cached_cost_usd,omitempty"` // Cost savings from cached tokens
    TotalCost     float64 `json:"total_cost_usd"`            // Total cost in USD
}
```

<a name="Message"></a>
## type Message

Message represents a single message in a conversation. This is the canonical message type used throughout the system.

```go
type Message struct {
    Role    string `json:"role"`    // "system", "user", "assistant", "tool"
    Content string `json:"content"` // Message content

    // Tool invocations (for assistant messages that call tools)
    ToolCalls []MessageToolCall `json:"tool_calls,omitempty"`

    // Tool result (for tool role messages)
    // When Role="tool", this contains the tool execution result
    ToolResult *MessageToolResult `json:"tool_result,omitempty"`

    // Source indicates where this message originated (runtime-only, not persisted in JSON)
    // Values: "statestore" (loaded from StateStore), "pipeline" (created during execution), "" (user input)
    Source string `json:"-"`

    // Metadata for observability and tracking
    Timestamp time.Time              `json:"timestamp,omitempty"`  // When the message was created
    LatencyMs int64                  `json:"latency_ms,omitempty"` // Time taken to generate (for assistant messages)
    CostInfo  *CostInfo              `json:"cost_info,omitempty"`  // Token usage and cost tracking
    Meta      map[string]interface{} `json:"meta,omitempty"`       // Custom metadata

    // Validation results (for assistant messages)
    Validations []ValidationResult `json:"validations,omitempty"`
}
```

<a name="MessageToolCall"></a>
## type MessageToolCall

MessageToolCall represents a request to call a tool within a Message. The Args field contains the JSON\-encoded arguments for the tool.

```go
type MessageToolCall struct {
    ID   string          `json:"id"`   // Unique identifier for this tool call
    Name string          `json:"name"` // Name of the tool to invoke
    Args json.RawMessage `json:"args"` // JSON-encoded tool arguments
}
```

<a name="MessageToolResult"></a>
## type MessageToolResult

MessageToolResult represents the result of a tool execution in a Message. When embedded in Message, the Message.Role should be "tool".

```go
type MessageToolResult struct {
    ID        string `json:"id"`              // References the MessageToolCall.ID that triggered this result
    Name      string `json:"name"`            // Tool name that was executed
    Content   string `json:"content"`         // Result content or error message
    Error     string `json:"error,omitempty"` // Error message if tool execution failed
    LatencyMs int64  `json:"latency_ms"`      // Tool execution latency in milliseconds
}
```

<a name="ToolDef"></a>
## type ToolDef

ToolDef represents a tool definition that can be provided to an LLM. The InputSchema and OutputSchema use JSON Schema format for validation.

```go
type ToolDef struct {
    Name         string          `json:"name"`                    // Unique tool name
    Description  string          `json:"description"`             // Human-readable description of what the tool does
    InputSchema  json.RawMessage `json:"input_schema"`            // JSON Schema for input validation
    OutputSchema json.RawMessage `json:"output_schema,omitempty"` // Optional JSON Schema for output validation
}
```

<a name="ToolStats"></a>
## type ToolStats

ToolStats tracks tool usage statistics across a conversation or run. Useful for monitoring which tools are being used and how frequently.

```go
type ToolStats struct {
    TotalCalls int            `json:"total_calls"` // Total number of tool calls
    ByTool     map[string]int `json:"by_tool"`     // Count of calls per tool name
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a validation failure in tool usage or message content. Used to provide structured error information when validation fails.

```go
type ValidationError struct {
    Type   string `json:"type"`   // Error type: "args_invalid" | "result_invalid" | "policy_violation"
    Tool   string `json:"tool"`   // Name of the tool that failed validation
    Detail string `json:"detail"` // Human-readable error details
}
```

<a name="ValidationResult"></a>
## type ValidationResult

ValidationResult represents the outcome of a validator check on a message. These are attached to assistant messages to show which validations passed or failed.

```go
type ValidationResult struct {
    ValidatorType string                 `json:"validator_type"`      // Type of validator (e.g., "*validators.BannedWordsValidator")
    Passed        bool                   `json:"passed"`              // Whether the validation passed
    Details       map[string]interface{} `json:"details,omitempty"`   // Validator-specific details about the result
    Timestamp     time.Time              `json:"timestamp,omitempty"` // When the validation was performed
}
```

# validators

```go
import "github.com/AltairaLabs/PromptKit/runtime/validators"
```

Package validators provides content validation for LLM responses and user inputs.

This package implements various validators to ensure conversation quality:

- Length and sentence count limits
- Banned word detection
- Role integrity \(preventing role confusion\)
- Required field presence
- Question and commit block validation

Validators are used during test execution to catch policy violations and ensure LLM responses meet quality standards.

## Index

- [Variables](<#variables>)
- [type BannedWordsValidator](<#BannedWordsValidator>)
  - [func NewBannedWordsValidator\(bannedWords \[\]string\) \*BannedWordsValidator](<#NewBannedWordsValidator>)
  - [func \(v \*BannedWordsValidator\) SupportsStreaming\(\) bool](<#BannedWordsValidator.SupportsStreaming>)
  - [func \(v \*BannedWordsValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#BannedWordsValidator.Validate>)
  - [func \(v \*BannedWordsValidator\) ValidateChunk\(chunk providers.StreamChunk, params ...map\[string\]interface\{\}\) error](<#BannedWordsValidator.ValidateChunk>)
- [type CommitValidator](<#CommitValidator>)
  - [func NewCommitValidator\(\) \*CommitValidator](<#NewCommitValidator>)
  - [func \(v \*CommitValidator\) SupportsStreaming\(\) bool](<#CommitValidator.SupportsStreaming>)
  - [func \(v \*CommitValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#CommitValidator.Validate>)
- [type LengthValidator](<#LengthValidator>)
  - [func NewLengthValidator\(\) \*LengthValidator](<#NewLengthValidator>)
  - [func \(v \*LengthValidator\) SupportsStreaming\(\) bool](<#LengthValidator.SupportsStreaming>)
  - [func \(v \*LengthValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#LengthValidator.Validate>)
  - [func \(v \*LengthValidator\) ValidateChunk\(chunk providers.StreamChunk, params ...map\[string\]interface\{\}\) error](<#LengthValidator.ValidateChunk>)
- [type MaxSentencesValidator](<#MaxSentencesValidator>)
  - [func NewMaxSentencesValidator\(\) \*MaxSentencesValidator](<#NewMaxSentencesValidator>)
  - [func \(v \*MaxSentencesValidator\) SupportsStreaming\(\) bool](<#MaxSentencesValidator.SupportsStreaming>)
  - [func \(v \*MaxSentencesValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#MaxSentencesValidator.Validate>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func \(r \*Registry\) Get\(validatorType string\) \(ValidatorFactory, bool\)](<#Registry.Get>)
  - [func \(r \*Registry\) HasValidator\(validatorType string\) bool](<#Registry.HasValidator>)
  - [func \(r \*Registry\) Register\(validatorType string, factory ValidatorFactory\)](<#Registry.Register>)
- [type RequiredFieldsValidator](<#RequiredFieldsValidator>)
  - [func NewRequiredFieldsValidator\(\) \*RequiredFieldsValidator](<#NewRequiredFieldsValidator>)
  - [func \(v \*RequiredFieldsValidator\) SupportsStreaming\(\) bool](<#RequiredFieldsValidator.SupportsStreaming>)
  - [func \(v \*RequiredFieldsValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#RequiredFieldsValidator.Validate>)
- [type StreamingValidator](<#StreamingValidator>)
- [type ValidationResult](<#ValidationResult>)
- [type Validator](<#Validator>)
- [type ValidatorConfig](<#ValidatorConfig>)
- [type ValidatorFactory](<#ValidatorFactory>)


## Variables

<a name="DefaultRegistry"></a>DefaultRegistry is the global validator registry.

```go
var DefaultRegistry = NewRegistry()
```

<a name="BannedWordsValidator"></a>
## type BannedWordsValidator

BannedWordsValidator checks for banned words

```go
type BannedWordsValidator struct {
    // contains filtered or unexported fields
}
```

<a name="NewBannedWordsValidator"></a>
### func NewBannedWordsValidator

```go
func NewBannedWordsValidator(bannedWords []string) *BannedWordsValidator
```

NewBannedWordsValidator creates a new banned words validator

<a name="BannedWordsValidator.SupportsStreaming"></a>
### func \(\*BannedWordsValidator\) SupportsStreaming

```go
func (v *BannedWordsValidator) SupportsStreaming() bool
```

SupportsStreaming returns true as banned words can be detected incrementally

<a name="BannedWordsValidator.Validate"></a>
### func \(\*BannedWordsValidator\) Validate

```go
func (v *BannedWordsValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for banned words in content

<a name="BannedWordsValidator.ValidateChunk"></a>
### func \(\*BannedWordsValidator\) ValidateChunk

```go
func (v *BannedWordsValidator) ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error
```

ValidateChunk validates a stream chunk for banned words and aborts if found

<a name="CommitValidator"></a>
## type CommitValidator

CommitValidator checks for commit/decision blocks in conversation responses

```go
type CommitValidator struct{}
```

<a name="NewCommitValidator"></a>
### func NewCommitValidator

```go
func NewCommitValidator() *CommitValidator
```

NewCommitValidator creates a new commit validator

<a name="CommitValidator.SupportsStreaming"></a>
### func \(\*CommitValidator\) SupportsStreaming

```go
func (v *CommitValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as commit validation requires complete content

<a name="CommitValidator.Validate"></a>
### func \(\*CommitValidator\) Validate

```go
func (v *CommitValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for commit block with required fields

<a name="LengthValidator"></a>
## type LengthValidator

LengthValidator checks content length limits

```go
type LengthValidator struct{}
```

<a name="NewLengthValidator"></a>
### func NewLengthValidator

```go
func NewLengthValidator() *LengthValidator
```

NewLengthValidator creates a new length validator

<a name="LengthValidator.SupportsStreaming"></a>
### func \(\*LengthValidator\) SupportsStreaming

```go
func (v *LengthValidator) SupportsStreaming() bool
```

SupportsStreaming returns true as length can be checked incrementally

<a name="LengthValidator.Validate"></a>
### func \(\*LengthValidator\) Validate

```go
func (v *LengthValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks content length against limits

<a name="LengthValidator.ValidateChunk"></a>
### func \(\*LengthValidator\) ValidateChunk

```go
func (v *LengthValidator) ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error
```

ValidateChunk validates stream chunk against length limits and aborts if exceeded

<a name="MaxSentencesValidator"></a>
## type MaxSentencesValidator

MaxSentencesValidator checks sentence count limits

```go
type MaxSentencesValidator struct{}
```

<a name="NewMaxSentencesValidator"></a>
### func NewMaxSentencesValidator

```go
func NewMaxSentencesValidator() *MaxSentencesValidator
```

NewMaxSentencesValidator creates a new sentence count validator

<a name="MaxSentencesValidator.SupportsStreaming"></a>
### func \(\*MaxSentencesValidator\) SupportsStreaming

```go
func (v *MaxSentencesValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as sentence counting requires complete content

<a name="MaxSentencesValidator.Validate"></a>
### func \(\*MaxSentencesValidator\) Validate

```go
func (v *MaxSentencesValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks sentence count against max limit

<a name="Registry"></a>
## type Registry

Registry maps validator type names to factory functions. This allows dynamic instantiation of validators from configuration.

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new validator registry with built\-in validators.

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(validatorType string) (ValidatorFactory, bool)
```

Get retrieves a validator factory by type.

<a name="Registry.HasValidator"></a>
### func \(\*Registry\) HasValidator

```go
func (r *Registry) HasValidator(validatorType string) bool
```

HasValidator returns true if a validator type is registered.

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(validatorType string, factory ValidatorFactory)
```

Register adds a validator factory to the registry.

<a name="RequiredFieldsValidator"></a>
## type RequiredFieldsValidator

RequiredFieldsValidator checks for required fields in content

```go
type RequiredFieldsValidator struct{}
```

<a name="NewRequiredFieldsValidator"></a>
### func NewRequiredFieldsValidator

```go
func NewRequiredFieldsValidator() *RequiredFieldsValidator
```

NewRequiredFieldsValidator creates a new required fields validator

<a name="RequiredFieldsValidator.SupportsStreaming"></a>
### func \(\*RequiredFieldsValidator\) SupportsStreaming

```go
func (v *RequiredFieldsValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as required fields must be in complete content

<a name="RequiredFieldsValidator.Validate"></a>
### func \(\*RequiredFieldsValidator\) Validate

```go
func (v *RequiredFieldsValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for required fields in content

<a name="StreamingValidator"></a>
## type StreamingValidator

StreamingValidator interface for validators that can check content incrementally and abort streaming early if validation fails

```go
type StreamingValidator interface {
    Validator

    // ValidateChunk validates a stream chunk and returns error to abort stream
    // Returns nil to continue, ValidationAbortError to abort stream
    ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error

    // SupportsStreaming returns true if this validator can validate incrementally
    SupportsStreaming() bool
}
```

<a name="ValidationResult"></a>
## type ValidationResult

ValidationResult holds the result of a validation check

```go
type ValidationResult struct {
    OK      bool        `json:"ok"`
    Details interface{} `json:"details,omitempty"`
}
```

<a name="Validator"></a>
## type Validator

Validator interface for all validation checks

```go
type Validator interface {
    Validate(content string, params map[string]interface{}) ValidationResult
}
```

<a name="ValidatorConfig"></a>
## type ValidatorConfig

ValidatorConfig defines a validator configuration from a prompt pack. This is just configuration data \- validators are instantiated by the registry.

```go
type ValidatorConfig struct {
    Type   string                 `json:"type" yaml:"type"`
    Params map[string]interface{} `json:"params" yaml:"params"`
}
```

<a name="ValidatorFactory"></a>
## type ValidatorFactory

ValidatorFactory creates a validator instance from configuration params. Params from the config are passed at construction time to allow validators to pre\-compile patterns, build state, etc.

```go
type ValidatorFactory func(params map[string]interface{}) Validator
```

# json

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/json"
```

Package json provides JSON file\-based implementations of persistence repositories.

This package can be used for production environments where JSON is preferred over YAML.

## Index

- [type JSONPromptRepository](<#JSONPromptRepository>)
  - [func NewJSONPromptRepository\(basePath string, taskTypeToFile map\[string\]string\) \*JSONPromptRepository](<#NewJSONPromptRepository>)
  - [func \(r \*JSONPromptRepository\) ListPrompts\(\) \(\[\]string, error\)](<#JSONPromptRepository.ListPrompts>)
  - [func \(r \*JSONPromptRepository\) LoadFragment\(name string, relativePath string, baseDir string\) \(\*prompt.Fragment, error\)](<#JSONPromptRepository.LoadFragment>)
  - [func \(r \*JSONPromptRepository\) LoadPrompt\(taskType string\) \(\*prompt.PromptConfig, error\)](<#JSONPromptRepository.LoadPrompt>)
  - [func \(r \*JSONPromptRepository\) SavePrompt\(config \*prompt.PromptConfig\) error](<#JSONPromptRepository.SavePrompt>)
- [type JSONToolRepository](<#JSONToolRepository>)
  - [func NewJSONToolRepository\(basePath string\) \*JSONToolRepository](<#NewJSONToolRepository>)
  - [func \(r \*JSONToolRepository\) ListTools\(\) \(\[\]string, error\)](<#JSONToolRepository.ListTools>)
  - [func \(r \*JSONToolRepository\) LoadDirectory\(dirPath string\) error](<#JSONToolRepository.LoadDirectory>)
  - [func \(r \*JSONToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#JSONToolRepository.LoadTool>)
  - [func \(r \*JSONToolRepository\) LoadToolFromFile\(filename string\) error](<#JSONToolRepository.LoadToolFromFile>)
  - [func \(r \*JSONToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#JSONToolRepository.RegisterTool>)
  - [func \(r \*JSONToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#JSONToolRepository.SaveTool>)


<a name="JSONPromptRepository"></a>
## type JSONPromptRepository

JSONPromptRepository loads prompts from JSON files on disk

```go
type JSONPromptRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewJSONPromptRepository"></a>
### func NewJSONPromptRepository

```go
func NewJSONPromptRepository(basePath string, taskTypeToFile map[string]string) *JSONPromptRepository
```

NewJSONPromptRepository creates a JSON file\-based prompt repository

<a name="JSONPromptRepository.ListPrompts"></a>
### func \(\*JSONPromptRepository\) ListPrompts

```go
func (r *JSONPromptRepository) ListPrompts() ([]string, error)
```

ListPrompts returns all available prompt task types

<a name="JSONPromptRepository.LoadFragment"></a>
### func \(\*JSONPromptRepository\) LoadFragment

```go
func (r *JSONPromptRepository) LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name

<a name="JSONPromptRepository.LoadPrompt"></a>
### func \(\*JSONPromptRepository\) LoadPrompt

```go
func (r *JSONPromptRepository) LoadPrompt(taskType string) (*prompt.PromptConfig, error)
```

LoadPrompt loads a prompt configuration by task type

<a name="JSONPromptRepository.SavePrompt"></a>
### func \(\*JSONPromptRepository\) SavePrompt

```go
func (r *JSONPromptRepository) SavePrompt(config *prompt.PromptConfig) error
```

SavePrompt saves a prompt configuration \(not yet implemented\)

<a name="JSONToolRepository"></a>
## type JSONToolRepository

JSONToolRepository loads tools from JSON files on disk

```go
type JSONToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewJSONToolRepository"></a>
### func NewJSONToolRepository

```go
func NewJSONToolRepository(basePath string) *JSONToolRepository
```

NewJSONToolRepository creates a JSON file\-based tool repository

<a name="JSONToolRepository.ListTools"></a>
### func \(\*JSONToolRepository\) ListTools

```go
func (r *JSONToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="JSONToolRepository.LoadDirectory"></a>
### func \(\*JSONToolRepository\) LoadDirectory

```go
func (r *JSONToolRepository) LoadDirectory(dirPath string) error
```

LoadDirectory recursively loads all JSON tool files from a directory

<a name="JSONToolRepository.LoadTool"></a>
### func \(\*JSONToolRepository\) LoadTool

```go
func (r *JSONToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="JSONToolRepository.LoadToolFromFile"></a>
### func \(\*JSONToolRepository\) LoadToolFromFile

```go
func (r *JSONToolRepository) LoadToolFromFile(filename string) error
```

LoadToolFromFile loads a tool from a JSON file

<a name="JSONToolRepository.RegisterTool"></a>
### func \(\*JSONToolRepository\) RegisterTool

```go
func (r *JSONToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool descriptor directly

<a name="JSONToolRepository.SaveTool"></a>
### func \(\*JSONToolRepository\) SaveTool

```go
func (r *JSONToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor \(not yet implemented\)

# memory

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/memory"
```

Package memory provides in\-memory implementations of persistence repositories.

This package is primarily for testing and SDK use, allowing prompts and tools to be registered programmatically without file system dependencies.

## Index

- [type MemoryPromptRepository](<#MemoryPromptRepository>)
  - [func NewMemoryPromptRepository\(\) \*MemoryPromptRepository](<#NewMemoryPromptRepository>)
  - [func \(r \*MemoryPromptRepository\) ListPrompts\(\) \(\[\]string, error\)](<#MemoryPromptRepository.ListPrompts>)
  - [func \(r \*MemoryPromptRepository\) LoadFragment\(name string, relativePath string, baseDir string\) \(\*prompt.Fragment, error\)](<#MemoryPromptRepository.LoadFragment>)
  - [func \(r \*MemoryPromptRepository\) LoadPrompt\(taskType string\) \(\*prompt.PromptConfig, error\)](<#MemoryPromptRepository.LoadPrompt>)
  - [func \(r \*MemoryPromptRepository\) RegisterFragment\(name string, fragment \*prompt.Fragment\)](<#MemoryPromptRepository.RegisterFragment>)
  - [func \(r \*MemoryPromptRepository\) RegisterPrompt\(taskType string, config \*prompt.PromptConfig\)](<#MemoryPromptRepository.RegisterPrompt>)
  - [func \(r \*MemoryPromptRepository\) SavePrompt\(config \*prompt.PromptConfig\) error](<#MemoryPromptRepository.SavePrompt>)
- [type MemoryToolRepository](<#MemoryToolRepository>)
  - [func NewMemoryToolRepository\(\) \*MemoryToolRepository](<#NewMemoryToolRepository>)
  - [func \(r \*MemoryToolRepository\) ListTools\(\) \(\[\]string, error\)](<#MemoryToolRepository.ListTools>)
  - [func \(r \*MemoryToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#MemoryToolRepository.LoadTool>)
  - [func \(r \*MemoryToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#MemoryToolRepository.RegisterTool>)
  - [func \(r \*MemoryToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#MemoryToolRepository.SaveTool>)


<a name="MemoryPromptRepository"></a>
## type MemoryPromptRepository

MemoryPromptRepository stores prompts in memory \(for testing/SDK\)

```go
type MemoryPromptRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewMemoryPromptRepository"></a>
### func NewMemoryPromptRepository

```go
func NewMemoryPromptRepository() *MemoryPromptRepository
```

NewMemoryPromptRepository creates a new in\-memory prompt repository

<a name="MemoryPromptRepository.ListPrompts"></a>
### func \(\*MemoryPromptRepository\) ListPrompts

```go
func (r *MemoryPromptRepository) ListPrompts() ([]string, error)
```

ListPrompts returns all available prompt task types

<a name="MemoryPromptRepository.LoadFragment"></a>
### func \(\*MemoryPromptRepository\) LoadFragment

```go
func (r *MemoryPromptRepository) LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name

<a name="MemoryPromptRepository.LoadPrompt"></a>
### func \(\*MemoryPromptRepository\) LoadPrompt

```go
func (r *MemoryPromptRepository) LoadPrompt(taskType string) (*prompt.PromptConfig, error)
```

LoadPrompt loads a prompt configuration by task type

<a name="MemoryPromptRepository.RegisterFragment"></a>
### func \(\*MemoryPromptRepository\) RegisterFragment

```go
func (r *MemoryPromptRepository) RegisterFragment(name string, fragment *prompt.Fragment)
```

RegisterFragment adds a fragment to the in\-memory store

<a name="MemoryPromptRepository.RegisterPrompt"></a>
### func \(\*MemoryPromptRepository\) RegisterPrompt

```go
func (r *MemoryPromptRepository) RegisterPrompt(taskType string, config *prompt.PromptConfig)
```

RegisterPrompt adds a prompt to the in\-memory store

<a name="MemoryPromptRepository.SavePrompt"></a>
### func \(\*MemoryPromptRepository\) SavePrompt

```go
func (r *MemoryPromptRepository) SavePrompt(config *prompt.PromptConfig) error
```

SavePrompt saves a prompt configuration

<a name="MemoryToolRepository"></a>
## type MemoryToolRepository

MemoryToolRepository stores tools in memory \(for testing/SDK\)

```go
type MemoryToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewMemoryToolRepository"></a>
### func NewMemoryToolRepository

```go
func NewMemoryToolRepository() *MemoryToolRepository
```

NewMemoryToolRepository creates a new in\-memory tool repository

<a name="MemoryToolRepository.ListTools"></a>
### func \(\*MemoryToolRepository\) ListTools

```go
func (r *MemoryToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="MemoryToolRepository.LoadTool"></a>
### func \(\*MemoryToolRepository\) LoadTool

```go
func (r *MemoryToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="MemoryToolRepository.RegisterTool"></a>
### func \(\*MemoryToolRepository\) RegisterTool

```go
func (r *MemoryToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool to the in\-memory store

<a name="MemoryToolRepository.SaveTool"></a>
### func \(\*MemoryToolRepository\) SaveTool

```go
func (r *MemoryToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor

# yaml

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/yaml"
```

Package yaml provides YAML file\-based implementations of persistence repositories.

This package is primarily for Arena and development use, loading prompts and tools from YAML configuration files on disk.

## Index

- [type YAMLPromptRepository](<#YAMLPromptRepository>)
  - [func NewYAMLPromptRepository\(basePath string, taskTypeToFile map\[string\]string\) \*YAMLPromptRepository](<#NewYAMLPromptRepository>)
  - [func \(r \*YAMLPromptRepository\) ListPrompts\(\) \(\[\]string, error\)](<#YAMLPromptRepository.ListPrompts>)
  - [func \(r \*YAMLPromptRepository\) LoadFragment\(name string, relativePath string, baseDir string\) \(\*prompt.Fragment, error\)](<#YAMLPromptRepository.LoadFragment>)
  - [func \(r \*YAMLPromptRepository\) LoadPrompt\(taskType string\) \(\*prompt.PromptConfig, error\)](<#YAMLPromptRepository.LoadPrompt>)
  - [func \(r \*YAMLPromptRepository\) SavePrompt\(config \*prompt.PromptConfig\) error](<#YAMLPromptRepository.SavePrompt>)
- [type YAMLToolRepository](<#YAMLToolRepository>)
  - [func NewYAMLToolRepository\(basePath string\) \*YAMLToolRepository](<#NewYAMLToolRepository>)
  - [func \(r \*YAMLToolRepository\) ListTools\(\) \(\[\]string, error\)](<#YAMLToolRepository.ListTools>)
  - [func \(r \*YAMLToolRepository\) LoadDirectory\(dirPath string\) error](<#YAMLToolRepository.LoadDirectory>)
  - [func \(r \*YAMLToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#YAMLToolRepository.LoadTool>)
  - [func \(r \*YAMLToolRepository\) LoadToolFromFile\(filename string\) error](<#YAMLToolRepository.LoadToolFromFile>)
  - [func \(r \*YAMLToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#YAMLToolRepository.RegisterTool>)
  - [func \(r \*YAMLToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#YAMLToolRepository.SaveTool>)


<a name="YAMLPromptRepository"></a>
## type YAMLPromptRepository

YAMLPromptRepository loads prompts from YAML files on disk

```go
type YAMLPromptRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewYAMLPromptRepository"></a>
### func NewYAMLPromptRepository

```go
func NewYAMLPromptRepository(basePath string, taskTypeToFile map[string]string) *YAMLPromptRepository
```

NewYAMLPromptRepository creates a YAML file\-based prompt repository If taskTypeToFile mappings are provided, they will be used for lookups. Otherwise, the repository will search the basePath directory.

<a name="YAMLPromptRepository.ListPrompts"></a>
### func \(\*YAMLPromptRepository\) ListPrompts

```go
func (r *YAMLPromptRepository) ListPrompts() ([]string, error)
```

ListPrompts returns all available prompt task types

<a name="YAMLPromptRepository.LoadFragment"></a>
### func \(\*YAMLPromptRepository\) LoadFragment

```go
func (r *YAMLPromptRepository) LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name and optional path

<a name="YAMLPromptRepository.LoadPrompt"></a>
### func \(\*YAMLPromptRepository\) LoadPrompt

```go
func (r *YAMLPromptRepository) LoadPrompt(taskType string) (*prompt.PromptConfig, error)
```

LoadPrompt loads a prompt configuration by task type

<a name="YAMLPromptRepository.SavePrompt"></a>
### func \(\*YAMLPromptRepository\) SavePrompt

```go
func (r *YAMLPromptRepository) SavePrompt(config *prompt.PromptConfig) error
```

SavePrompt saves a prompt configuration \(not yet implemented\)

<a name="YAMLToolRepository"></a>
## type YAMLToolRepository

YAMLToolRepository loads tools from YAML files on disk

```go
type YAMLToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewYAMLToolRepository"></a>
### func NewYAMLToolRepository

```go
func NewYAMLToolRepository(basePath string) *YAMLToolRepository
```

NewYAMLToolRepository creates a YAML file\-based tool repository

<a name="YAMLToolRepository.ListTools"></a>
### func \(\*YAMLToolRepository\) ListTools

```go
func (r *YAMLToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="YAMLToolRepository.LoadDirectory"></a>
### func \(\*YAMLToolRepository\) LoadDirectory

```go
func (r *YAMLToolRepository) LoadDirectory(dirPath string) error
```

LoadDirectory recursively loads all YAML tool files from a directory

<a name="YAMLToolRepository.LoadTool"></a>
### func \(\*YAMLToolRepository\) LoadTool

```go
func (r *YAMLToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="YAMLToolRepository.LoadToolFromFile"></a>
### func \(\*YAMLToolRepository\) LoadToolFromFile

```go
func (r *YAMLToolRepository) LoadToolFromFile(filename string) error
```

LoadToolFromFile loads a tool from a YAML file and registers it

<a name="YAMLToolRepository.RegisterTool"></a>
### func \(\*YAMLToolRepository\) RegisterTool

```go
func (r *YAMLToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool descriptor directly to the repository

<a name="YAMLToolRepository.SaveTool"></a>
### func \(\*YAMLToolRepository\) SaveTool

```go
func (r *YAMLToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor \(not yet implemented\)

# middleware

```go
import "github.com/AltairaLabs/PromptKit/runtime/pipeline/middleware"
```

## Index

- [func ContextBuilderMiddleware\(policy \*ContextBuilderPolicy\) pipeline.Middleware](<#ContextBuilderMiddleware>)
- [func ContextExtractionMiddleware\(\) pipeline.Middleware](<#ContextExtractionMiddleware>)
- [func DebugMiddleware\(stage string\) pipeline.Middleware](<#DebugMiddleware>)
- [func DynamicValidatorMiddleware\(registry \*validators.Registry\) pipeline.Middleware](<#DynamicValidatorMiddleware>)
- [func GetContextMetadata\(execCtx \*pipeline.ExecutionContext\) \(truncated bool, originalCount, truncatedCount int\)](<#GetContextMetadata>)
- [func PromptAssemblyMiddleware\(promptRegistry \*prompt.Registry, taskType string, baseVariables map\[string\]string\) pipeline.Middleware](<#PromptAssemblyMiddleware>)
- [func ProviderMiddleware\(provider providers.Provider, toolRegistry \*tools.Registry, toolPolicy \*pipeline.ToolPolicy, config \*ProviderMiddlewareConfig\) pipeline.Middleware](<#ProviderMiddleware>)
- [func StateStoreLoadMiddleware\(config \*pipeline.StateStoreConfig\) pipeline.Middleware](<#StateStoreLoadMiddleware>)
- [func StateStoreSaveMiddleware\(config \*pipeline.StateStoreConfig\) pipeline.Middleware](<#StateStoreSaveMiddleware>)
- [func TemplateMiddleware\(\) pipeline.Middleware](<#TemplateMiddleware>)
- [type ContextBuilderPolicy](<#ContextBuilderPolicy>)
- [type ProviderMiddlewareConfig](<#ProviderMiddlewareConfig>)
- [type TruncationStrategy](<#TruncationStrategy>)


<a name="ContextBuilderMiddleware"></a>
## func ContextBuilderMiddleware

```go
func ContextBuilderMiddleware(policy *ContextBuilderPolicy) pipeline.Middleware
```

ContextBuilderMiddleware manages conversation context with token budget enforcement This middleware should be placed BEFORE ProviderMiddleware in the pipeline

<a name="ContextExtractionMiddleware"></a>
## func ContextExtractionMiddleware

```go
func ContextExtractionMiddleware() pipeline.Middleware
```



<a name="DebugMiddleware"></a>
## func DebugMiddleware

```go
func DebugMiddleware(stage string) pipeline.Middleware
```

DebugMiddleware creates middleware that logs the full execution context as JSON. The stage parameter identifies where in the pipeline this middleware is placed. You can add this middleware multiple times at different stages to trace state changes.

Example:

```
middleware.DebugMiddleware("after-prompt-assembly"),
middleware.DebugMiddleware("after-provider"),
```

Note: This middleware serializes the entire context to JSON, which can be expensive. Only use in development/debugging scenarios.

<a name="DynamicValidatorMiddleware"></a>
## func DynamicValidatorMiddleware

```go
func DynamicValidatorMiddleware(registry *validators.Registry) pipeline.Middleware
```

DynamicValidatorMiddleware creates middleware that dynamically instantiates validators from configurations stored in ExecutionContext. It uses the validator registry to create validators on\-demand and passes their params from the config.

<a name="GetContextMetadata"></a>
## func GetContextMetadata

```go
func GetContextMetadata(execCtx *pipeline.ExecutionContext) (truncated bool, originalCount, truncatedCount int)
```

GetContextMetadata extracts context truncation metadata from ExecutionContext

<a name="PromptAssemblyMiddleware"></a>
## func PromptAssemblyMiddleware

```go
func PromptAssemblyMiddleware(promptRegistry *prompt.Registry, taskType string, baseVariables map[string]string) pipeline.Middleware
```

PromptAssemblyMiddleware loads and assembles prompts from the prompt registry. It populates execCtx.SystemPrompt, execCtx.AllowedTools, and base variables. This middleware should run BEFORE context extraction and template substitution.

<a name="ProviderMiddleware"></a>
## func ProviderMiddleware

```go
func ProviderMiddleware(provider providers.Provider, toolRegistry *tools.Registry, toolPolicy *pipeline.ToolPolicy, config *ProviderMiddlewareConfig) pipeline.Middleware
```

ProviderMiddleware executes LLM calls and handles tool execution via the ToolRegistry. It supports multi\-round execution when tools are involved. In streaming mode, it forwards chunks to execCtx.StreamOutput.

The provider, toolRegistry, toolPolicy, and configuration are provided at construction time, simplifying the ExecutionContext and avoiding the need to pass Config around.

<a name="StateStoreLoadMiddleware"></a>
## func StateStoreLoadMiddleware

```go
func StateStoreLoadMiddleware(config *pipeline.StateStoreConfig) pipeline.Middleware
```

StateStoreLoadMiddleware loads conversation history from StateStore. It should be placed FIRST in the pipeline, before any other middleware. If the conversation doesn't exist, it starts with an empty history.

<a name="StateStoreSaveMiddleware"></a>
## func StateStoreSaveMiddleware

```go
func StateStoreSaveMiddleware(config *pipeline.StateStoreConfig) pipeline.Middleware
```

StateStoreSaveMiddleware saves conversation state to StateStore. It should be placed LAST in the pipeline, after all other middleware. It saves even if the pipeline execution failed \(to preserve partial state\).

<a name="TemplateMiddleware"></a>
## func TemplateMiddleware

```go
func TemplateMiddleware() pipeline.Middleware
```

TemplateMiddleware substitutes variables in the system prompt. It replaces \{\{variable\}\} placeholders with values from ExecutionContext.Variables.

<a name="ContextBuilderPolicy"></a>
## type ContextBuilderPolicy

ContextBuilderPolicy defines token budget and truncation behavior

```go
type ContextBuilderPolicy struct {
    TokenBudget      int                // Max tokens for context (0 = unlimited)
    ReserveForOutput int                // Reserve tokens for response
    Strategy         TruncationStrategy // How to handle overflow
    CacheBreakpoints bool               // Insert cache markers (Anthropic)
}
```

<a name="ProviderMiddlewareConfig"></a>
## type ProviderMiddlewareConfig

ProviderMiddlewareConfig contains configuration for the provider middleware

```go
type ProviderMiddlewareConfig struct {
    MaxTokens    int
    Temperature  float32
    Seed         *int
    DisableTrace bool // Disable execution tracing (default: false = tracing enabled)
}
```

<a name="TruncationStrategy"></a>
## type TruncationStrategy

TruncationStrategy defines how to handle messages when over token budget

```go
type TruncationStrategy string
```

<a name="TruncateOldest"></a>

```go
const (
    // TruncateOldest drops oldest messages first (simple, preserves recent context)
    TruncateOldest TruncationStrategy = "oldest"

    // TruncateLeastRelevant drops least relevant messages (requires embeddings)
    TruncateLeastRelevant TruncationStrategy = "relevance"

    // TruncateSummarize compresses old messages into summaries
    TruncateSummarize TruncationStrategy = "summarize"

    // TruncateFail returns error if over budget (strict mode)
    TruncateFail TruncationStrategy = "fail"
)
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
