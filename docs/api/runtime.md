<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# logger

```go
import "github.com/AltairaLabs/PromptKit/runtime/logger"
```

Package logger provides structured logging with automatic PII redaction.

This package wraps Go's standard log/slog with convenience functions for:

- LLM API call logging \(requests, responses, errors\)
- Tool execution logging
- Automatic API key and sensitive data redaction
- Contextual logging with request tracing
- Level\-based verbosity control

All exported functions use the global DefaultLogger which can be configured for different output formats and log levels.

## Index

- [Variables](<#variables>)
- [func APIRequest\(provider, method, url string, headers map\[string\]string, body interface\{\}\)](<#APIRequest>)
- [func APIResponse\(provider string, statusCode int, body string, err error\)](<#APIResponse>)
- [func Debug\(msg string, args ...any\)](<#Debug>)
- [func DebugContext\(ctx context.Context, msg string, args ...any\)](<#DebugContext>)
- [func Error\(msg string, args ...any\)](<#Error>)
- [func ErrorContext\(ctx context.Context, msg string, args ...any\)](<#ErrorContext>)
- [func Info\(msg string, args ...any\)](<#Info>)
- [func InfoContext\(ctx context.Context, msg string, args ...any\)](<#InfoContext>)
- [func LLMCall\(provider, role string, messages int, temperature float64, attrs ...any\)](<#LLMCall>)
- [func LLMError\(provider, role string, err error, attrs ...any\)](<#LLMError>)
- [func LLMResponse\(provider, role string, tokensIn, tokensOut int, cost float64, attrs ...any\)](<#LLMResponse>)
- [func RedactSensitiveData\(input string\) string](<#RedactSensitiveData>)
- [func SetLevel\(level slog.Level\)](<#SetLevel>)
- [func SetVerbose\(verbose bool\)](<#SetVerbose>)
- [func ToolCall\(provider string, messages, tools int, choice string, attrs ...any\)](<#ToolCall>)
- [func ToolResponse\(provider string, tokensIn, tokensOut, toolCalls int, cost float64, attrs ...any\)](<#ToolResponse>)
- [func Warn\(msg string, args ...any\)](<#Warn>)
- [func WarnContext\(ctx context.Context, msg string, args ...any\)](<#WarnContext>)


## Variables

<a name="DefaultLogger"></a>

```go
var (
    // DefaultLogger is the global structured logger instance.
    // It is safe for concurrent use and initialized with slog.LevelInfo by default.
    DefaultLogger *slog.Logger
)
```

<a name="APIRequest"></a>
## func APIRequest

```go
func APIRequest(provider, method, url string, headers map[string]string, body interface{})
```

APIRequest logs HTTP API request details at debug level with automatic PII redaction. This function is a no\-op when debug logging is disabled for performance.

Parameters:

- provider: The API provider name \(e.g., "OpenAI", "Anthropic"\)
- method: HTTP method \(GET, POST, etc.\)
- url: Request URL \(will be redacted for sensitive data\)
- headers: HTTP headers map \(will be redacted\)
- body: Request body \(will be marshaled to JSON and redacted\)

Sensitive data in URL, headers, and body are automatically redacted.

<a name="APIResponse"></a>
## func APIResponse

```go
func APIResponse(provider string, statusCode int, body string, err error)
```

APIResponse logs HTTP API response details at debug level with automatic PII redaction. This function is a no\-op when debug logging is disabled for performance.

Parameters:

- provider: The API provider name
- statusCode: HTTP status code
- body: Response body as string \(will be redacted\)
- err: Error if the request failed \(takes precedence over body logging\)

Response bodies are attempted to be parsed as JSON for pretty formatting. Status codes are logged with emoji indicators: ðŸŸ¢ \(2xx\), ðŸŸ¡ \(3xx\), ðŸ”´ \(4xx/5xx\).

<a name="Debug"></a>
## func Debug

```go
func Debug(msg string, args ...any)
```

Debug logs a debug\-level message with structured attributes. Debug messages are only output when the log level is set to LevelDebug or lower.

<a name="DebugContext"></a>
## func DebugContext

```go
func DebugContext(ctx context.Context, msg string, args ...any)
```

DebugContext logs a debug message with context and structured attributes.

<a name="Error"></a>
## func Error

```go
func Error(msg string, args ...any)
```

Error logs an error message with structured attributes. Use for errors that affect operation but don't cause complete failure.

<a name="ErrorContext"></a>
## func ErrorContext

```go
func ErrorContext(ctx context.Context, msg string, args ...any)
```

ErrorContext logs an error message with context and structured attributes.

<a name="Info"></a>
## func Info

```go
func Info(msg string, args ...any)
```

Info logs an informational message with structured key\-value attributes. Args should be provided in key\-value pairs: key1, value1, key2, value2, ...

<a name="InfoContext"></a>
## func InfoContext

```go
func InfoContext(ctx context.Context, msg string, args ...any)
```

InfoContext logs an informational message with context and structured attributes. The context can be used for request tracing and cancellation.

<a name="LLMCall"></a>
## func LLMCall

```go
func LLMCall(provider, role string, messages int, temperature float64, attrs ...any)
```

LLMCall logs an LLM API call with structured fields for observability. Additional attributes can be passed as key\-value pairs after the required parameters.

<a name="LLMError"></a>
## func LLMError

```go
func LLMError(provider, role string, err error, attrs ...any)
```

LLMError logs an LLM API error for debugging and monitoring.

<a name="LLMResponse"></a>
## func LLMResponse

```go
func LLMResponse(provider, role string, tokensIn, tokensOut int, cost float64, attrs ...any)
```

LLMResponse logs an LLM API response with token usage and cost tracking. Cost should be provided in USD \(e.g., 0.0001 for $0.0001\).

<a name="RedactSensitiveData"></a>
## func RedactSensitiveData

```go
func RedactSensitiveData(input string) string
```

RedactSensitiveData removes API keys and other sensitive information from strings. It replaces matched patterns with a redacted form that preserves the first few characters for debugging while hiding the sensitive portion.

Supported patterns:

- OpenAI keys \(sk\-...\): Shows first 4 chars
- Google keys \(AIza...\): Shows first 4 chars
- Bearer tokens: Shows only "Bearer \[REDACTED\]"

This function is safe for concurrent use as it only reads from the compiled patterns.

<a name="SetLevel"></a>
## func SetLevel

```go
func SetLevel(level slog.Level)
```

SetLevel changes the logging level for all subsequent log operations. This is safe for concurrent use as it replaces the entire logger instance.

<a name="SetVerbose"></a>
## func SetVerbose

```go
func SetVerbose(verbose bool)
```

SetVerbose enables debug\-level logging when verbose is true, otherwise sets info\-level. This is a convenience wrapper around SetLevel for command\-line verbose flags.

<a name="ToolCall"></a>
## func ToolCall

```go
func ToolCall(provider string, messages, tools int, choice string, attrs ...any)
```

ToolCall logs a tool execution request with context about available tools. The choice parameter indicates the tool selection mode \(e.g., "auto", "required", "none"\).

<a name="ToolResponse"></a>
## func ToolResponse

```go
func ToolResponse(provider string, tokensIn, tokensOut, toolCalls int, cost float64, attrs ...any)
```

ToolResponse logs the result of tool executions with token usage and cost.

<a name="Warn"></a>
## func Warn

```go
func Warn(msg string, args ...any)
```

Warn logs a warning message with structured attributes. Use for recoverable errors or unexpected but non\-critical situations.

<a name="WarnContext"></a>
## func WarnContext

```go
func WarnContext(ctx context.Context, msg string, args ...any)
```

WarnContext logs a warning message with context and structured attributes.

# mcp

```go
import "github.com/AltairaLabs/PromptKit/runtime/mcp"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [type Client](<#Client>)
- [type ClientCapabilities](<#ClientCapabilities>)
- [type ClientOptions](<#ClientOptions>)
  - [func DefaultClientOptions\(\) ClientOptions](<#DefaultClientOptions>)
- [type Content](<#Content>)
- [type ElicitationCapability](<#ElicitationCapability>)
- [type Implementation](<#Implementation>)
- [type InitializeRequest](<#InitializeRequest>)
- [type InitializeResponse](<#InitializeResponse>)
- [type JSONRPCError](<#JSONRPCError>)
- [type JSONRPCMessage](<#JSONRPCMessage>)
- [type LoggingCapability](<#LoggingCapability>)
- [type PromptsCapability](<#PromptsCapability>)
- [type Registry](<#Registry>)
- [type RegistryImpl](<#RegistryImpl>)
  - [func NewRegistry\(\) \*RegistryImpl](<#NewRegistry>)
  - [func NewRegistryWithServers\(serverConfigs \[\]ServerConfigData\) \(\*RegistryImpl, error\)](<#NewRegistryWithServers>)
  - [func \(r \*RegistryImpl\) Close\(\) error](<#RegistryImpl.Close>)
  - [func \(r \*RegistryImpl\) GetClient\(ctx context.Context, serverName string\) \(Client, error\)](<#RegistryImpl.GetClient>)
  - [func \(r \*RegistryImpl\) GetClientForTool\(ctx context.Context, toolName string\) \(Client, error\)](<#RegistryImpl.GetClientForTool>)
  - [func \(r \*RegistryImpl\) GetToolSchema\(ctx context.Context, toolName string\) \(\*Tool, error\)](<#RegistryImpl.GetToolSchema>)
  - [func \(r \*RegistryImpl\) ListAllTools\(ctx context.Context\) \(map\[string\]\[\]Tool, error\)](<#RegistryImpl.ListAllTools>)
  - [func \(r \*RegistryImpl\) ListServers\(\) \[\]string](<#RegistryImpl.ListServers>)
  - [func \(r \*RegistryImpl\) RegisterServer\(config ServerConfig\) error](<#RegistryImpl.RegisterServer>)
- [type ResourcesCapability](<#ResourcesCapability>)
- [type SamplingCapability](<#SamplingCapability>)
- [type ServerCapabilities](<#ServerCapabilities>)
- [type ServerConfig](<#ServerConfig>)
- [type ServerConfigData](<#ServerConfigData>)
- [type StdioClient](<#StdioClient>)
  - [func NewStdioClient\(config ServerConfig\) \*StdioClient](<#NewStdioClient>)
  - [func NewStdioClientWithOptions\(config ServerConfig, options ClientOptions\) \*StdioClient](<#NewStdioClientWithOptions>)
  - [func \(c \*StdioClient\) CallTool\(ctx context.Context, name string, arguments json.RawMessage\) \(\*ToolCallResponse, error\)](<#StdioClient.CallTool>)
  - [func \(c \*StdioClient\) Close\(\) error](<#StdioClient.Close>)
  - [func \(c \*StdioClient\) Initialize\(ctx context.Context\) \(\*InitializeResponse, error\)](<#StdioClient.Initialize>)
  - [func \(c \*StdioClient\) IsAlive\(\) bool](<#StdioClient.IsAlive>)
  - [func \(c \*StdioClient\) ListTools\(ctx context.Context\) \(\[\]Tool, error\)](<#StdioClient.ListTools>)
- [type Tool](<#Tool>)
- [type ToolCallRequest](<#ToolCallRequest>)
- [type ToolCallResponse](<#ToolCallResponse>)
- [type ToolsCapability](<#ToolsCapability>)
- [type ToolsListRequest](<#ToolsListRequest>)
- [type ToolsListResponse](<#ToolsListResponse>)


## Constants

<a name="ProtocolVersion"></a>Protocol version \(as of 2025\-06\-18\)

```go
const ProtocolVersion = "2025-06-18"
```

## Variables

<a name="ErrClientNotInitialized"></a>

```go
var (
    // ErrClientNotInitialized is returned when attempting operations on uninitialized client
    ErrClientNotInitialized = errors.New("mcp: client not initialized")
    // ErrClientClosed is returned when attempting operations on closed client
    ErrClientClosed = errors.New("mcp: client closed")
    // ErrServerUnresponsive is returned when server doesn't respond
    ErrServerUnresponsive = errors.New("mcp: server unresponsive")
    // ErrProcessDied is returned when server process dies unexpectedly
    ErrProcessDied = errors.New("mcp: server process died")
)
```

<a name="Client"></a>
## type Client

Client interface defines the MCP client operations

```go
type Client interface {
    // Initialize establishes the MCP connection and negotiates capabilities
    Initialize(ctx context.Context) (*InitializeResponse, error)

    // ListTools retrieves all available tools from the server
    ListTools(ctx context.Context) ([]Tool, error)

    // CallTool executes a tool with the given arguments
    CallTool(ctx context.Context, name string, arguments json.RawMessage) (*ToolCallResponse, error)

    // Close terminates the connection to the MCP server
    Close() error

    // IsAlive checks if the connection is still active
    IsAlive() bool
}
```

<a name="ClientCapabilities"></a>
## type ClientCapabilities

ClientCapabilities describes what the client supports

```go
type ClientCapabilities struct {
    Elicitation *ElicitationCapability `json:"elicitation,omitempty"`
    Sampling    *SamplingCapability    `json:"sampling,omitempty"`
    Logging     *LoggingCapability     `json:"logging,omitempty"`
}
```

<a name="ClientOptions"></a>
## type ClientOptions

ClientOptions configures MCP client behavior

```go
type ClientOptions struct {
    // RequestTimeout is the default timeout for RPC requests
    RequestTimeout time.Duration
    // InitTimeout is the timeout for the initialization handshake
    InitTimeout time.Duration
    // MaxRetries is the number of times to retry failed requests
    MaxRetries int
    // RetryDelay is the initial delay between retries (exponential backoff)
    RetryDelay time.Duration
    // EnableGracefulDegradation allows operations to continue even if MCP is unavailable
    EnableGracefulDegradation bool
}
```

<a name="DefaultClientOptions"></a>
### func DefaultClientOptions

```go
func DefaultClientOptions() ClientOptions
```

DefaultClientOptions returns sensible defaults

<a name="Content"></a>
## type Content

Content represents a content item in MCP responses

```go
type Content struct {
    Type     string `json:"type"` // "text", "image", "resource", etc.
    Text     string `json:"text,omitempty"`
    Data     string `json:"data,omitempty"`     // Base64 encoded data
    MimeType string `json:"mimeType,omitempty"` // MIME type for data
    URI      string `json:"uri,omitempty"`      // URI for resources
}
```

<a name="ElicitationCapability"></a>
## type ElicitationCapability

ElicitationCapability indicates the client supports elicitation

```go
type ElicitationCapability struct{}
```

<a name="Implementation"></a>
## type Implementation

Implementation describes client or server implementation details

```go
type Implementation struct {
    Name    string `json:"name"`
    Version string `json:"version"`
}
```

<a name="InitializeRequest"></a>
## type InitializeRequest

InitializeRequest represents the initialization request params

```go
type InitializeRequest struct {
    ProtocolVersion string             `json:"protocolVersion"`
    Capabilities    ClientCapabilities `json:"capabilities"`
    ClientInfo      Implementation     `json:"clientInfo"`
}
```

<a name="InitializeResponse"></a>
## type InitializeResponse

InitializeResponse represents the initialization response

```go
type InitializeResponse struct {
    ProtocolVersion string             `json:"protocolVersion"`
    Capabilities    ServerCapabilities `json:"capabilities"`
    ServerInfo      Implementation     `json:"serverInfo"`
}
```

<a name="JSONRPCError"></a>
## type JSONRPCError

JSONRPCError represents a JSON\-RPC 2.0 error

```go
type JSONRPCError struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
}
```

<a name="JSONRPCMessage"></a>
## type JSONRPCMessage

JSONRPCMessage represents a JSON\-RPC 2.0 message

```go
type JSONRPCMessage struct {
    JSONRPC string          `json:"jsonrpc"`
    ID      interface{}     `json:"id,omitempty"`     // Request ID (number or string)
    Method  string          `json:"method,omitempty"` // Method name for requests/notifications
    Params  json.RawMessage `json:"params,omitempty"` // Parameters for method
    Result  json.RawMessage `json:"result,omitempty"` // Result for responses
    Error   *JSONRPCError   `json:"error,omitempty"`  // Error for error responses
}
```

<a name="LoggingCapability"></a>
## type LoggingCapability

LoggingCapability indicates the client supports logging

```go
type LoggingCapability struct{}
```

<a name="PromptsCapability"></a>
## type PromptsCapability

PromptsCapability indicates the server supports prompts

```go
type PromptsCapability struct {
    ListChanged bool `json:"listChanged,omitempty"`
}
```

<a name="Registry"></a>
## type Registry

Registry interface defines the MCP server registry operations

```go
type Registry interface {
    // RegisterServer adds a new MCP server configuration
    RegisterServer(config ServerConfig) error

    // GetClient returns an active client for the given server name
    GetClient(ctx context.Context, serverName string) (Client, error)

    // GetClientForTool returns the client that provides the specified tool
    GetClientForTool(ctx context.Context, toolName string) (Client, error)

    // ListServers returns all registered server names
    ListServers() []string

    // ListAllTools returns all tools from all connected servers
    ListAllTools(ctx context.Context) (map[string][]Tool, error)

    // Close shuts down all MCP servers and connections
    Close() error
}
```

<a name="RegistryImpl"></a>
## type RegistryImpl

RegistryImpl implements the Registry interface

```go
type RegistryImpl struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *RegistryImpl
```

NewRegistry creates a new MCP server registry

<a name="NewRegistryWithServers"></a>
### func NewRegistryWithServers

```go
func NewRegistryWithServers(serverConfigs []ServerConfigData) (*RegistryImpl, error)
```

NewRegistryWithServers creates a registry and registers multiple servers. Returns error if any server registration fails.

<a name="RegistryImpl.Close"></a>
### func \(\*RegistryImpl\) Close

```go
func (r *RegistryImpl) Close() error
```

Close shuts down all MCP servers and connections

<a name="RegistryImpl.GetClient"></a>
### func \(\*RegistryImpl\) GetClient

```go
func (r *RegistryImpl) GetClient(ctx context.Context, serverName string) (Client, error)
```

GetClient returns an active client for the given server name

<a name="RegistryImpl.GetClientForTool"></a>
### func \(\*RegistryImpl\) GetClientForTool

```go
func (r *RegistryImpl) GetClientForTool(ctx context.Context, toolName string) (Client, error)
```

GetClientForTool returns the client that provides the specified tool

<a name="RegistryImpl.GetToolSchema"></a>
### func \(\*RegistryImpl\) GetToolSchema

```go
func (r *RegistryImpl) GetToolSchema(ctx context.Context, toolName string) (*Tool, error)
```

GetToolSchema returns the schema for a specific tool

<a name="RegistryImpl.ListAllTools"></a>
### func \(\*RegistryImpl\) ListAllTools

```go
func (r *RegistryImpl) ListAllTools(ctx context.Context) (map[string][]Tool, error)
```

ListAllTools returns all tools from all connected servers

<a name="RegistryImpl.ListServers"></a>
### func \(\*RegistryImpl\) ListServers

```go
func (r *RegistryImpl) ListServers() []string
```

ListServers returns all registered server names

<a name="RegistryImpl.RegisterServer"></a>
### func \(\*RegistryImpl\) RegisterServer

```go
func (r *RegistryImpl) RegisterServer(config ServerConfig) error
```

RegisterServer adds a new MCP server configuration

<a name="ResourcesCapability"></a>
## type ResourcesCapability

ResourcesCapability indicates the server supports resources

```go
type ResourcesCapability struct {
    ListChanged bool `json:"listChanged,omitempty"`
}
```

<a name="SamplingCapability"></a>
## type SamplingCapability

SamplingCapability indicates the client supports sampling

```go
type SamplingCapability struct{}
```

<a name="ServerCapabilities"></a>
## type ServerCapabilities

ServerCapabilities describes what the server supports

```go
type ServerCapabilities struct {
    Tools     *ToolsCapability     `json:"tools,omitempty"`
    Resources *ResourcesCapability `json:"resources,omitempty"`
    Prompts   *PromptsCapability   `json:"prompts,omitempty"`
}
```

<a name="ServerConfig"></a>
## type ServerConfig

ServerConfig represents configuration for an MCP server

```go
type ServerConfig struct {
    Name    string            `json:"name" yaml:"name"`       // Unique identifier for this server
    Command string            `json:"command" yaml:"command"` // Command to execute
    Args    []string          `json:"args,omitempty" yaml:"args,omitempty"`
    Env     map[string]string `json:"env,omitempty" yaml:"env,omitempty"`
}
```

<a name="ServerConfigData"></a>
## type ServerConfigData

ServerConfigData holds MCP server configuration matching config.MCPServerConfig

```go
type ServerConfigData struct {
    Name    string
    Command string
    Args    []string
    Env     map[string]string
}
```

<a name="StdioClient"></a>
## type StdioClient

StdioClient implements the MCP Client interface using stdio transport

```go
type StdioClient struct {
    // contains filtered or unexported fields
}
```

<a name="NewStdioClient"></a>
### func NewStdioClient

```go
func NewStdioClient(config ServerConfig) *StdioClient
```

NewStdioClient creates a new MCP client using stdio transport

<a name="NewStdioClientWithOptions"></a>
### func NewStdioClientWithOptions

```go
func NewStdioClientWithOptions(config ServerConfig, options ClientOptions) *StdioClient
```

NewStdioClientWithOptions creates a client with custom options

<a name="StdioClient.CallTool"></a>
### func \(\*StdioClient\) CallTool

```go
func (c *StdioClient) CallTool(ctx context.Context, name string, arguments json.RawMessage) (*ToolCallResponse, error)
```

CallTool executes a tool with the given arguments

<a name="StdioClient.Close"></a>
### func \(\*StdioClient\) Close

```go
func (c *StdioClient) Close() error
```

Close terminates the connection to the MCP server

<a name="StdioClient.Initialize"></a>
### func \(\*StdioClient\) Initialize

```go
func (c *StdioClient) Initialize(ctx context.Context) (*InitializeResponse, error)
```

Initialize establishes the MCP connection and negotiates capabilities

<a name="StdioClient.IsAlive"></a>
### func \(\*StdioClient\) IsAlive

```go
func (c *StdioClient) IsAlive() bool
```

IsAlive checks if the connection is still active

<a name="StdioClient.ListTools"></a>
### func \(\*StdioClient\) ListTools

```go
func (c *StdioClient) ListTools(ctx context.Context) ([]Tool, error)
```

ListTools retrieves all available tools from the server

<a name="Tool"></a>
## type Tool

Tool represents an MCP tool definition

```go
type Tool struct {
    Name        string          `json:"name"`
    Description string          `json:"description,omitempty"`
    InputSchema json.RawMessage `json:"inputSchema"` // JSON Schema for tool input
}
```

<a name="ToolCallRequest"></a>
## type ToolCallRequest

ToolCallRequest represents a request to execute a tool

```go
type ToolCallRequest struct {
    Name      string          `json:"name"`
    Arguments json.RawMessage `json:"arguments,omitempty"`
}
```

<a name="ToolCallResponse"></a>
## type ToolCallResponse

ToolCallResponse represents the response from a tool execution

```go
type ToolCallResponse struct {
    Content []Content `json:"content"`
    IsError bool      `json:"isError,omitempty"`
}
```

<a name="ToolsCapability"></a>
## type ToolsCapability

ToolsCapability indicates the server supports tools

```go
type ToolsCapability struct {
    ListChanged bool `json:"listChanged,omitempty"` // Server can send notifications
}
```

<a name="ToolsListRequest"></a>
## type ToolsListRequest

ToolsListRequest represents a request to list available tools

```go
type ToolsListRequest struct {
}
```

<a name="ToolsListResponse"></a>
## type ToolsListResponse

ToolsListResponse represents the response to a tools/list request

```go
type ToolsListResponse struct {
    Tools []Tool `json:"tools"`
}
```

# persistence

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence"
```

Package persistence provides abstract persistence layer for Runtime components.

This package implements the Repository Pattern to decouple Runtime from storage implementations. It provides interfaces for loading prompts, tools, and fragments from various backends \(YAML files, JSON files, memory, packs, etc.\).

## Index

- [type PromptRepository](<#PromptRepository>)
- [type ToolRepository](<#ToolRepository>)


<a name="PromptRepository"></a>
## type PromptRepository

PromptRepository provides abstract access to prompt configurations

```go
type PromptRepository interface {
    // LoadPrompt loads a prompt configuration by task type
    LoadPrompt(taskType string) (*prompt.PromptConfig, error)

    // LoadFragment loads a fragment by name and optional path
    LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)

    // ListPrompts returns all available prompt task types
    ListPrompts() ([]string, error)

    // SavePrompt saves a prompt configuration (for future write support)
    SavePrompt(config *prompt.PromptConfig) error
}
```

<a name="ToolRepository"></a>
## type ToolRepository

ToolRepository provides abstract access to tool descriptors

```go
type ToolRepository interface {
    // LoadTool loads a tool descriptor by name
    LoadTool(name string) (*tools.ToolDescriptor, error)

    // ListTools returns all available tool names
    ListTools() ([]string, error)

    // SaveTool saves a tool descriptor (for future write support)
    SaveTool(descriptor *tools.ToolDescriptor) error
}
```

# pipeline

```go
import "github.com/AltairaLabs/PromptKit/runtime/pipeline"
```

## Index

- [Variables](<#variables>)
- [type ExecutionConfig](<#ExecutionConfig>)
- [type ExecutionContext](<#ExecutionContext>)
  - [func \(ctx \*ExecutionContext\) AddPendingToolCall\(toolCall types.MessageToolCall\)](<#ExecutionContext.AddPendingToolCall>)
  - [func \(ctx \*ExecutionContext\) ClearPendingToolCalls\(\)](<#ExecutionContext.ClearPendingToolCalls>)
  - [func \(ctx \*ExecutionContext\) EmitStreamChunk\(chunk providers.StreamChunk\) bool](<#ExecutionContext.EmitStreamChunk>)
  - [func \(ctx \*ExecutionContext\) GetPendingToolCall\(id string\) \*types.MessageToolCall](<#ExecutionContext.GetPendingToolCall>)
  - [func \(ctx \*ExecutionContext\) HasPendingToolCalls\(\) bool](<#ExecutionContext.HasPendingToolCalls>)
  - [func \(ctx \*ExecutionContext\) InterruptStream\(reason string\)](<#ExecutionContext.InterruptStream>)
  - [func \(ctx \*ExecutionContext\) IsStreaming\(\) bool](<#ExecutionContext.IsStreaming>)
  - [func \(ctx \*ExecutionContext\) RecordLLMCall\(disableTrace bool, response \*Response, startTime time.Time, duration time.Duration, costInfo \*types.CostInfo, toolCalls \[\]types.MessageToolCall\)](<#ExecutionContext.RecordLLMCall>)
  - [func \(ctx \*ExecutionContext\) RemovePendingToolCall\(id string\) bool](<#ExecutionContext.RemovePendingToolCall>)
- [type ExecutionResult](<#ExecutionResult>)
- [type ExecutionTrace](<#ExecutionTrace>)
- [type LLMCall](<#LLMCall>)
  - [func \(l \*LLMCall\) GetError\(\) error](<#LLMCall.GetError>)
  - [func \(l \*LLMCall\) SetError\(err error\)](<#LLMCall.SetError>)
- [type Middleware](<#Middleware>)
- [type MiddlewareConfig](<#MiddlewareConfig>)
- [type Pipeline](<#Pipeline>)
  - [func NewPipeline\(middleware ...Middleware\) \*Pipeline](<#NewPipeline>)
  - [func NewPipelineWithConfig\(config \*PipelineRuntimeConfig, middleware ...Middleware\) \*Pipeline](<#NewPipelineWithConfig>)
  - [func NewPipelineWithConfigValidated\(config \*PipelineRuntimeConfig, middleware ...Middleware\) \(\*Pipeline, error\)](<#NewPipelineWithConfigValidated>)
  - [func \(p \*Pipeline\) Execute\(ctx context.Context, role string, content string\) \(\*ExecutionResult, error\)](<#Pipeline.Execute>)
  - [func \(p \*Pipeline\) ExecuteStream\(ctx context.Context, role string, content string\) \(\<\-chan providers.StreamChunk, error\)](<#Pipeline.ExecuteStream>)
  - [func \(p \*Pipeline\) ExecuteStreamWithMessage\(ctx context.Context, message types.Message\) \(\<\-chan providers.StreamChunk, error\)](<#Pipeline.ExecuteStreamWithMessage>)
  - [func \(p \*Pipeline\) ExecuteWithMessage\(ctx context.Context, message types.Message\) \(\*ExecutionResult, error\)](<#Pipeline.ExecuteWithMessage>)
  - [func \(p \*Pipeline\) Shutdown\(ctx context.Context\) error](<#Pipeline.Shutdown>)
- [type PipelineConfig](<#PipelineConfig>)
- [type PipelineRuntimeConfig](<#PipelineRuntimeConfig>)
  - [func DefaultPipelineRuntimeConfig\(\) \*PipelineRuntimeConfig](<#DefaultPipelineRuntimeConfig>)
- [type ProviderMiddlewareConfig](<#ProviderMiddlewareConfig>)
- [type Response](<#Response>)
- [type ResponseMetadata](<#ResponseMetadata>)
- [type RetryPolicy](<#RetryPolicy>)
- [type StateStoreConfig](<#StateStoreConfig>)
- [type TemplateMiddlewareConfig](<#TemplateMiddlewareConfig>)
- [type ToolPolicy](<#ToolPolicy>)
- [type TraceEvent](<#TraceEvent>)
- [type ValidationError](<#ValidationError>)
  - [func \(e \*ValidationError\) Error\(\) string](<#ValidationError.Error>)
- [type ValidatorMiddlewareConfig](<#ValidatorMiddlewareConfig>)


## Variables

<a name="ErrPipelineShuttingDown"></a>Error constants

```go
var (
    ErrPipelineShuttingDown = errors.New("pipeline is shutting down")
)
```

<a name="ExecutionConfig"></a>
## type ExecutionConfig

ExecutionConfig contains configuration for pipeline execution.

```go
type ExecutionConfig struct {
    Provider     providers.Provider
    ToolRegistry *tools.Registry
    Temperature  float32
    MaxTokens    int
    Seed         *int
    ToolPolicy   *ToolPolicy
}
```

<a name="ExecutionContext"></a>
## type ExecutionContext

ExecutionContext is the execution state passed through the middleware chain. It contains all the data needed for pipeline execution and is modified by middleware.

```go
type ExecutionContext struct {
    // Context for cancellation, deadlines, and request-scoped values
    Context context.Context

    // State (mutable by middleware)
    SystemPrompt     string                    // Populated by PromptAssemblyMiddleware
    Variables        map[string]string         // Populated by PromptAssemblyMiddleware and ContextExtractionMiddleware
    AllowedTools     []string                  // Populated by PromptAssemblyMiddleware
    Messages         []types.Message           // Conversation history + current messages
    Tools            []types.ToolDef           // Available tool definitions
    ToolResults      []types.MessageToolResult // Executed tool results
    PendingToolCalls []types.MessageToolCall   // Tool calls awaiting external completion (human-in-the-loop)
    Prompt           string                    // Assembled prompt (after variable substitution by TemplateMiddleware)

    // Output (populated by middleware)
    Trace       ExecutionTrace // Complete trace of all LLM calls and events
    Response    *Response      // Convenience pointer to the most recent response (= Trace.LLMCalls[len-1].Response)
    RawResponse interface{}    // Convenience pointer to most recent raw response (= Trace.LLMCalls[len-1].RawResponse)

    // Error tracking (middleware can check this to see if an error occurred earlier in the chain)
    Error error // First error encountered during execution (subsequent middleware still run)

    // Metadata (for passing data between middleware)
    Metadata map[string]interface{}

    // Cost tracking (aggregate across all calls)
    CostInfo types.CostInfo

    // Streaming support
    StreamMode        bool                       // If true, use streaming execution
    StreamOutput      chan providers.StreamChunk // Output channel for streaming chunks
    StreamInterrupted bool                       // Set to true by middleware to stop streaming
    InterruptReason   string                     // Reason for interruption

    // Middleware control
    ShortCircuit bool // Set to true by middleware to intentionally skip remaining middleware
    // contains filtered or unexported fields
}
```

<a name="ExecutionContext.AddPendingToolCall"></a>
### func \(\*ExecutionContext\) AddPendingToolCall

```go
func (ctx *ExecutionContext) AddPendingToolCall(toolCall types.MessageToolCall)
```

AddPendingToolCall adds a tool call to the pending list. Used by middleware when a tool returns ToolStatusPending.

<a name="ExecutionContext.ClearPendingToolCalls"></a>
### func \(\*ExecutionContext\) ClearPendingToolCalls

```go
func (ctx *ExecutionContext) ClearPendingToolCalls()
```

ClearPendingToolCalls removes all pending tool calls.

<a name="ExecutionContext.EmitStreamChunk"></a>
### func \(\*ExecutionContext\) EmitStreamChunk

```go
func (ctx *ExecutionContext) EmitStreamChunk(chunk providers.StreamChunk) bool
```

EmitStreamChunk emits a stream chunk to the output channel. Returns false if the stream has been interrupted or the channel is closed. Middleware that produces chunks should check the return value to know when to stop.

<a name="ExecutionContext.GetPendingToolCall"></a>
### func \(\*ExecutionContext\) GetPendingToolCall

```go
func (ctx *ExecutionContext) GetPendingToolCall(id string) *types.MessageToolCall
```

GetPendingToolCall retrieves a pending tool call by ID. Returns nil if not found.

<a name="ExecutionContext.HasPendingToolCalls"></a>
### func \(\*ExecutionContext\) HasPendingToolCalls

```go
func (ctx *ExecutionContext) HasPendingToolCalls() bool
```

HasPendingToolCalls returns true if there are any pending tool calls.

<a name="ExecutionContext.InterruptStream"></a>
### func \(\*ExecutionContext\) InterruptStream

```go
func (ctx *ExecutionContext) InterruptStream(reason string)
```

InterruptStream interrupts the stream with the given reason. Middleware should call this to stop streaming when validation fails, rate limits are hit, etc.

<a name="ExecutionContext.IsStreaming"></a>
### func \(\*ExecutionContext\) IsStreaming

```go
func (ctx *ExecutionContext) IsStreaming() bool
```

IsStreaming returns true if the execution context is in streaming mode.

<a name="ExecutionContext.RecordLLMCall"></a>
### func \(\*ExecutionContext\) RecordLLMCall

```go
func (ctx *ExecutionContext) RecordLLMCall(disableTrace bool, response *Response, startTime time.Time, duration time.Duration, costInfo *types.CostInfo, toolCalls []types.MessageToolCall)
```

RecordLLMCall adds an LLM call to the execution trace if tracing is enabled. This method is called by provider middleware to track all LLM interactions.

<a name="ExecutionContext.RemovePendingToolCall"></a>
### func \(\*ExecutionContext\) RemovePendingToolCall

```go
func (ctx *ExecutionContext) RemovePendingToolCall(id string) bool
```

RemovePendingToolCall removes a tool call from the pending list by ID. Returns true if the tool call was found and removed.

<a name="ExecutionResult"></a>
## type ExecutionResult

ExecutionResult is the output of a pipeline execution. It contains the final state after all middleware has been executed.

```go
type ExecutionResult struct {
    Messages []types.Message        `json:"messages"`  // All messages including history and responses
    Response *Response              `json:"response"`  // The final response (convenience field)
    Trace    ExecutionTrace         `json:"trace"`     // Complete execution trace with all LLM calls
    CostInfo types.CostInfo         `json:"cost_info"` // Aggregate cost across all LLM calls
    Metadata map[string]interface{} `json:"metadata"`  // Metadata populated by middleware
}
```

<a name="ExecutionTrace"></a>
## type ExecutionTrace

ExecutionTrace captures the complete execution history of a pipeline run. This includes all LLM calls, tool executions, and other significant events.

```go
type ExecutionTrace struct {
    LLMCalls    []LLMCall    `json:"llm_calls"`              // All LLM API calls made during execution
    Events      []TraceEvent `json:"events,omitempty"`       // Other trace events (tool execution, context truncation, etc.)
    StartedAt   time.Time    `json:"started_at"`             // When pipeline execution started
    CompletedAt *time.Time   `json:"completed_at,omitempty"` // When pipeline execution completed (nil if still running)
}
```

<a name="LLMCall"></a>
## type LLMCall

LLMCall represents a single LLM API call within a pipeline execution. In tool\-enabled scenarios, multiple calls may occur in sequence.

```go
type LLMCall struct {
    Sequence     int                     `json:"sequence"`               // Call number in sequence (1, 2, 3...)
    MessageIndex int                     `json:"message_index"`          // Index into ExecutionResult.Messages where assistant response is stored
    Request      interface{}             `json:"request,omitempty"`      // Raw request (if debugging enabled)
    Response     *Response               `json:"response"`               // Parsed response
    RawResponse  interface{}             `json:"raw_response,omitempty"` // Raw provider response (if debugging enabled)
    StartedAt    time.Time               `json:"started_at"`             // When call started
    Duration     time.Duration           `json:"duration"`               // How long the call took
    Cost         types.CostInfo          `json:"cost"`                   // Cost information for this call
    ToolCalls    []types.MessageToolCall `json:"tool_calls,omitempty"`   // If this call triggered tool execution
    Error        *string                 `json:"error,omitempty"`        // Error message if the call failed (nil if successful)
}
```

<a name="LLMCall.GetError"></a>
### func \(\*LLMCall\) GetError

```go
func (l *LLMCall) GetError() error
```

GetError returns the error as an error type, or nil if no error occurred. This is a convenience method for accessing the Error field as an error type.

<a name="LLMCall.SetError"></a>
### func \(\*LLMCall\) SetError

```go
func (l *LLMCall) SetError(err error)
```

SetError sets the error for this LLM call from an error value. If err is nil, clears the error field.

<a name="Middleware"></a>
## type Middleware

Middleware defines the execution interface for pipeline steps.

Middleware executes in a nested chain where each middleware explicitly calls next\(\) to continue the pipeline. This makes the execution flow clear and explicit.

Given middleware chain: \[A, B, C\] Execution order is:

```
A.Process(ctx, func() {
  return B.Process(ctx, func() {
    return C.Process(ctx, func() {
      return nil // End of chain
    })
  })
})
```

Example implementation:

```
func (m *ProviderMiddleware) Process(ctx *ExecutionContext, next func() error) error {
  // Setup/processing logic
  response, err := m.provider.Generate(ctx)
  if err != nil {
    return err
  }
  ctx.Response = response

  // Continue to next middleware
  if err := next(); err != nil {
    return err
  }

  // Optional cleanup logic
  return nil
}
```

Error Handling:

- If Process\(\) returns an error, the error is captured in ExecutionContext.Error
- Errors stop the chain \- subsequent middleware do not execute
- Middleware can check ExecutionContext.Error to see if earlier steps failed

ExecutionContext is used internally by middleware but users should not create it directly.

```go
type Middleware interface {
    Process(ctx *ExecutionContext, next func() error) error
    // StreamChunk is called for each chunk during streaming execution (if StreamMode is true).
    // Middleware can inspect, validate, or modify chunks. Return an error or call ctx.InterruptStream()
    // to stop streaming. Most middleware should return nil (no-op).
    StreamChunk(ctx *ExecutionContext, chunk *providers.StreamChunk) error
}
```

<a name="MiddlewareConfig"></a>
## type MiddlewareConfig

MiddlewareConfig represents configuration for a specific middleware

```go
type MiddlewareConfig struct {
    Type   string                 `json:"type"`             // Middleware type (e.g., "template", "provider", "validator")
    Config map[string]interface{} `json:"config,omitempty"` // Type-specific configuration
}
```

<a name="Pipeline"></a>
## type Pipeline

Pipeline chains middleware together in sequence.

```go
type Pipeline struct {
    // contains filtered or unexported fields
}
```

<a name="NewPipeline"></a>
### func NewPipeline

```go
func NewPipeline(middleware ...Middleware) *Pipeline
```

NewPipeline creates a new pipeline with the given middleware. Uses default runtime configuration.

<a name="NewPipelineWithConfig"></a>
### func NewPipelineWithConfig

```go
func NewPipelineWithConfig(config *PipelineRuntimeConfig, middleware ...Middleware) *Pipeline
```

NewPipelineWithConfig creates a new pipeline with the given configuration and middleware. If config is nil, uses default configuration. Note: This function does not validate config values for backward compatibility. Use NewPipelineWithConfigValidated for validation.

<a name="NewPipelineWithConfigValidated"></a>
### func NewPipelineWithConfigValidated

```go
func NewPipelineWithConfigValidated(config *PipelineRuntimeConfig, middleware ...Middleware) (*Pipeline, error)
```

NewPipelineWithConfigValidated creates a new pipeline with validation. Returns an error if config contains invalid values \(negative numbers\). If config is nil, uses default configuration. If config has zero values for some fields, they are filled with defaults.

<a name="Pipeline.Execute"></a>
### func \(\*Pipeline\) Execute

```go
func (p *Pipeline) Execute(ctx context.Context, role string, content string) (*ExecutionResult, error)
```

Execute runs the pipeline with the given role and content, returning the execution result. It creates a fresh internal ExecutionContext for each call, preventing state contamination. The role and content parameters are used to create the initial user message. If role is empty, no message is appended \(useful for testing\). Returns the ExecutionResult containing messages, response, trace, and metadata.

<a name="Pipeline.ExecuteStream"></a>
### func \(\*Pipeline\) ExecuteStream

```go
func (p *Pipeline) ExecuteStream(ctx context.Context, role string, content string) (<-chan providers.StreamChunk, error)
```

ExecuteStream runs the pipeline in streaming mode, returning a channel of stream chunks. It creates a fresh internal ExecutionContext for each call, preventing state contamination. The role and content parameters are used to create the initial user message. If role is empty, no message is appended \(useful for testing\). The pipeline executes in the background and closes the channel when complete. The final chunk will contain the ExecutionResult in the FinalResult field.

<a name="Pipeline.ExecuteStreamWithMessage"></a>
### func \(\*Pipeline\) ExecuteStreamWithMessage

```go
func (p *Pipeline) ExecuteStreamWithMessage(ctx context.Context, message types.Message) (<-chan providers.StreamChunk, error)
```

ExecuteStreamWithMessage runs the pipeline in streaming mode with a complete Message object. This method allows callers to provide a fully\-populated message with all fields \(Meta, Timestamp, etc.\) rather than just role and content. The message is added to the execution context as\-is, preserving all fields including Meta, Timestamp, ToolCalls, CostInfo, and Validations.

The pipeline executes in the background and closes the channel when complete. The final chunk will contain the ExecutionResult in the FinalResult field. Returns a channel of StreamChunk objects that will be closed when execution completes.

<a name="Pipeline.ExecuteWithMessage"></a>
### func \(\*Pipeline\) ExecuteWithMessage

```go
func (p *Pipeline) ExecuteWithMessage(ctx context.Context, message types.Message) (*ExecutionResult, error)
```

ExecuteWithMessage runs the pipeline with a complete Message object, returning the execution result. This method allows callers to provide a fully\-populated message with all fields \(Meta, Timestamp, etc.\) rather than just role and content. This is useful when you need to preserve metadata or other message properties through the pipeline execution.

The message is added to the execution context as\-is, preserving all fields including: \- Meta \(metadata, raw responses, validation info\) \- Timestamp \- ToolCalls \- CostInfo \- Validations

Middleware can still modify the message during execution if needed. Returns the ExecutionResult containing messages, response, trace, and metadata.

<a name="Pipeline.Shutdown"></a>
### func \(\*Pipeline\) Shutdown

```go
func (p *Pipeline) Shutdown(ctx context.Context) error
```

Shutdown gracefully shuts down the pipeline, waiting for in\-flight executions to complete. Returns an error if shutdown times out according to GracefulShutdownTimeout.

<a name="PipelineConfig"></a>
## type PipelineConfig

PipelineConfig represents the complete pipeline configuration for pack format

```go
type PipelineConfig struct {
    Stages     []string           `json:"stages"`               // Pipeline stages in order (e.g., ["template", "provider", "validator"])
    Middleware []MiddlewareConfig `json:"middleware,omitempty"` // Middleware configurations
}
```

<a name="PipelineRuntimeConfig"></a>
## type PipelineRuntimeConfig

PipelineRuntimeConfig defines runtime configuration options for pipeline execution. All fields have sensible defaults and are optional.

```go
type PipelineRuntimeConfig struct {
    // MaxConcurrentExecutions limits the number of concurrent pipeline executions.
    // Default: 100
    MaxConcurrentExecutions int

    // StreamBufferSize sets the buffer size for streaming output channels.
    // Default: 100
    StreamBufferSize int

    // ExecutionTimeout sets the maximum duration for a single pipeline execution.
    // Set to 0 to disable timeout.
    // Default: 30 seconds
    ExecutionTimeout time.Duration

    // GracefulShutdownTimeout sets the maximum time to wait for in-flight executions during shutdown.
    // Default: 10 seconds
    GracefulShutdownTimeout time.Duration
}
```

<a name="DefaultPipelineRuntimeConfig"></a>
### func DefaultPipelineRuntimeConfig

```go
func DefaultPipelineRuntimeConfig() *PipelineRuntimeConfig
```

DefaultPipelineRuntimeConfig returns a PipelineRuntimeConfig with sensible default values.

<a name="ProviderMiddlewareConfig"></a>
## type ProviderMiddlewareConfig

ProviderMiddlewareConfig contains configuration for provider middleware

```go
type ProviderMiddlewareConfig struct {
    RetryPolicy  *RetryPolicy `json:"retry_policy,omitempty"`  // Retry policy
    TimeoutMs    int          `json:"timeout_ms,omitempty"`    // Request timeout in milliseconds
    DisableTrace bool         `json:"disable_trace,omitempty"` // Disable execution tracing (default: false = tracing enabled)
}
```

<a name="Response"></a>
## type Response

Response represents the final output from a pipeline execution.

```go
type Response struct {
    Role          string
    Content       string
    Parts         []types.ContentPart // Multimodal content parts (text, image, audio, video)
    ToolCalls     []types.MessageToolCall
    FinalResponse string // If tools were used, this is the final response after tools
    Metadata      ResponseMetadata
}
```

<a name="ResponseMetadata"></a>
## type ResponseMetadata

ResponseMetadata contains metadata about the response.

```go
type ResponseMetadata struct {
    Provider     string
    Model        string
    Latency      time.Duration
    TokensInput  int
    TokensOutput int
    Cost         float64
}
```

<a name="RetryPolicy"></a>
## type RetryPolicy

RetryPolicy defines retry behavior for provider middleware

```go
type RetryPolicy struct {
    MaxRetries     int    `json:"max_retries"`                // Maximum retry attempts
    Backoff        string `json:"backoff"`                    // Backoff strategy ("fixed", "exponential")
    InitialDelayMs int    `json:"initial_delay_ms,omitempty"` // Initial delay in milliseconds
}
```

<a name="StateStoreConfig"></a>
## type StateStoreConfig

StateStoreConfig contains configuration for state store middleware

```go
type StateStoreConfig struct {
    Store          interface{}            // State store implementation (statestore.Store)
    ConversationID string                 // Unique conversation identifier
    UserID         string                 // User identifier (optional)
    Metadata       map[string]interface{} // Additional metadata to store (optional)
}
```

<a name="TemplateMiddlewareConfig"></a>
## type TemplateMiddlewareConfig

TemplateMiddlewareConfig contains configuration for template middleware

```go
type TemplateMiddlewareConfig struct {
    StrictMode     bool `json:"strict_mode"`     // Fail on undefined variables
    AllowUndefined bool `json:"allow_undefined"` // Allow undefined variables (opposite of strict_mode)
}
```

<a name="ToolPolicy"></a>
## type ToolPolicy

ToolPolicy defines constraints on tool usage.

```go
type ToolPolicy struct {
    ToolChoice          string   `json:"tool_choice,omitempty"` // "auto", "required", "none", or specific tool name
    MaxRounds           int      `json:"max_rounds,omitempty"`
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="TraceEvent"></a>
## type TraceEvent

TraceEvent represents a significant event during pipeline execution.

```go
type TraceEvent struct {
    Type      string      `json:"type"`              // Event type (e.g., "tool_execution", "context_truncation", "validation_failed")
    Timestamp time.Time   `json:"timestamp"`         // When the event occurred
    Data      interface{} `json:"data"`              // Event-specific data
    Message   string      `json:"message,omitempty"` // Human-readable description
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a validation failure.

```go
type ValidationError struct {
    Type     string
    Details  string
    Failures []types.ValidationResult // All failed validations (for aggregation)
}
```

<a name="ValidationError.Error"></a>
### func \(\*ValidationError\) Error

```go
func (e *ValidationError) Error() string
```

Error returns the error message for this validation error.

<a name="ValidatorMiddlewareConfig"></a>
## type ValidatorMiddlewareConfig

ValidatorMiddlewareConfig contains configuration for validator middleware

```go
type ValidatorMiddlewareConfig struct {
    FailFast         bool `json:"fail_fast"`          // Stop on first validation error
    CollectAllErrors bool `json:"collect_all_errors"` // Collect all errors before failing
}
```

# prompt

```go
import "github.com/AltairaLabs/PromptKit/runtime/prompt"
```

Package prompt provides template\-based prompt management and assembly.

This package implements a registry system for loading, caching, and assembling prompt templates via repository interfaces:

- Fragment\-based prompt composition
- Variable substitution with required/optional vars
- Model\-specific overrides \(template modifications only\)
- Tool allowlist integration
- Version tracking and content hashing

The Registry uses the repository pattern to load prompt configs, avoiding direct file I/O. It resolves fragment references, performs template variable substitution, and generates AssembledPrompt objects ready for LLM execution.

### Architecture

For system architecture and design patterns, see:

- Architecture overview: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/architecture.md
- Prompt assembly pipeline: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/prompt-assembly.md
- Repository pattern: https://github.com/AltairaAI/promptkit-wip/blob/main/docs/persistence-layer-proposal.md

### Usage

Create a registry with a repository \(config\-first pattern\):

```
repo := memory.NewPromptRepository()
registry := prompt.NewRegistryWithRepository(repo)
assembled := registry.LoadWithVars("task_type", vars, "gpt-4")
```

See package github.com/AltairaLabs/PromptKit/sdk for higher\-level APIs.

## Index

- [func ExtractVariablesFromTemplate\(template string\) \[\]string](<#ExtractVariablesFromTemplate>)
- [func GetDefaultPipelineConfig\(\) map\[string\]interface\{\}](<#GetDefaultPipelineConfig>)
- [func GetUsedVars\(vars map\[string\]string\) \[\]string](<#GetUsedVars>)
- [func SupportsMediaType\(config \*MediaConfig, mediaType string\) bool](<#SupportsMediaType>)
- [func ValidateMediaConfig\(config \*MediaConfig\) error](<#ValidateMediaConfig>)
- [type AssembledPrompt](<#AssembledPrompt>)
  - [func \(ap \*AssembledPrompt\) UsesTools\(\) bool](<#AssembledPrompt.UsesTools>)
- [type AudioConfig](<#AudioConfig>)
  - [func GetAudioConfig\(config \*MediaConfig\) \*AudioConfig](<#GetAudioConfig>)
- [type ChangelogEntry](<#ChangelogEntry>)
- [type CompilationInfo](<#CompilationInfo>)
- [type CostEstimate](<#CostEstimate>)
- [type ExampleContentPart](<#ExampleContentPart>)
- [type ExampleMedia](<#ExampleMedia>)
- [type FileWriter](<#FileWriter>)
- [type Fragment](<#Fragment>)
- [type FragmentRef](<#FragmentRef>)
- [type FragmentRepository](<#FragmentRepository>)
- [type FragmentResolver](<#FragmentResolver>)
  - [func NewFragmentResolverWithRepository\(repository FragmentRepository\) \*FragmentResolver](<#NewFragmentResolverWithRepository>)
  - [func \(fr \*FragmentResolver\) AssembleFragments\(fragments \[\]FragmentRef, vars map\[string\]string, configFilePath string\) \(map\[string\]string, error\)](<#FragmentResolver.AssembleFragments>)
  - [func \(fr \*FragmentResolver\) LoadFragment\(name string, relativePath string, configFilePath string\) \(\*Fragment, error\)](<#FragmentResolver.LoadFragment>)
- [type ImageConfig](<#ImageConfig>)
  - [func GetImageConfig\(config \*MediaConfig\) \*ImageConfig](<#GetImageConfig>)
- [type MediaConfig](<#MediaConfig>)
- [type MetadataBuilder](<#MetadataBuilder>)
  - [func NewMetadataBuilder\(spec \*PromptSpec\) \*MetadataBuilder](<#NewMetadataBuilder>)
  - [func \(mb \*MetadataBuilder\) AddChangelogEntry\(version string, author string, description string\)](<#MetadataBuilder.AddChangelogEntry>)
  - [func \(mb \*MetadataBuilder\) BuildCompilationInfo\(compilerVersion string\) \*CompilationInfo](<#MetadataBuilder.BuildCompilationInfo>)
  - [func \(mb \*MetadataBuilder\) BuildPromptMetadata\(domain string, language string, tags \[\]string, testResults \[\]TestResultSummary\) \*PromptMetadata](<#MetadataBuilder.BuildPromptMetadata>)
  - [func \(mb \*MetadataBuilder\) SetDomain\(domain string\)](<#MetadataBuilder.SetDomain>)
  - [func \(mb \*MetadataBuilder\) SetLanguage\(language string\)](<#MetadataBuilder.SetLanguage>)
  - [func \(mb \*MetadataBuilder\) SetTags\(tags \[\]string\)](<#MetadataBuilder.SetTags>)
  - [func \(mb \*MetadataBuilder\) UpdateFromCostInfo\(costs \[\]types.CostInfo\)](<#MetadataBuilder.UpdateFromCostInfo>)
  - [func \(mb \*MetadataBuilder\) ValidateMetadata\(\) \[\]string](<#MetadataBuilder.ValidateMetadata>)
- [type ModelOverride](<#ModelOverride>)
- [type ModelTestResultRef](<#ModelTestResultRef>)
  - [func AggregateTestResults\(results \[\]TestResultSummary, provider string, model string\) \*ModelTestResultRef](<#AggregateTestResults>)
- [type MultimodalExample](<#MultimodalExample>)
- [type Pack](<#Pack>)
  - [func LoadPack\(filePath string\) \(\*Pack, error\)](<#LoadPack>)
  - [func \(p \*Pack\) GetOptionalVariables\(taskType string\) map\[string\]string](<#Pack.GetOptionalVariables>)
  - [func \(p \*Pack\) GetPrompt\(taskType string\) \*PackPrompt](<#Pack.GetPrompt>)
  - [func \(p \*Pack\) GetRequiredVariables\(taskType string\) \[\]string](<#Pack.GetRequiredVariables>)
  - [func \(p \*Pack\) GetToolNames\(taskType string\) \[\]string](<#Pack.GetToolNames>)
  - [func \(p \*Pack\) ListPrompts\(\) \[\]string](<#Pack.ListPrompts>)
  - [func \(p \*Pack\) Summary\(\) string](<#Pack.Summary>)
  - [func \(p \*Pack\) Validate\(\) \[\]string](<#Pack.Validate>)
- [type PackCompiler](<#PackCompiler>)
  - [func NewPackCompiler\(registry \*Registry\) \*PackCompiler](<#NewPackCompiler>)
  - [func NewPackCompilerWithDeps\(loader PromptLoader, timeProvider TimeProvider, fileWriter FileWriter\) \*PackCompiler](<#NewPackCompilerWithDeps>)
  - [func \(pc \*PackCompiler\) Compile\(taskType, compilerVersion string\) \(\*Pack, error\)](<#PackCompiler.Compile>)
  - [func \(pc \*PackCompiler\) CompileFromRegistry\(packID, compilerVersion string\) \(\*Pack, error\)](<#PackCompiler.CompileFromRegistry>)
  - [func \(pc \*PackCompiler\) CompileToFile\(taskType, outputPath, compilerVersion string\) error](<#PackCompiler.CompileToFile>)
  - [func \(pc \*PackCompiler\) MarshalPack\(pack \*Pack\) \(\[\]byte, error\)](<#PackCompiler.MarshalPack>)
  - [func \(pc \*PackCompiler\) WritePack\(pack \*Pack, outputPath string\) error](<#PackCompiler.WritePack>)
- [type PackPrompt](<#PackPrompt>)
- [type ParametersPack](<#ParametersPack>)
- [type PerformanceMetrics](<#PerformanceMetrics>)
- [type PromptConfig](<#PromptConfig>)
  - [func ParsePromptConfig\(data \[\]byte\) \(\*PromptConfig, error\)](<#ParsePromptConfig>)
- [type PromptInfo](<#PromptInfo>)
- [type PromptLoader](<#PromptLoader>)
- [type PromptMetadata](<#PromptMetadata>)
- [type PromptRepository](<#PromptRepository>)
- [type PromptSpec](<#PromptSpec>)
- [type Registry](<#Registry>)
  - [func NewRegistryWithRepository\(repository PromptRepository\) \*Registry](<#NewRegistryWithRepository>)
  - [func \(r \*Registry\) ClearCache\(\)](<#Registry.ClearCache>)
  - [func \(r \*Registry\) GetAvailableRegions\(\) \[\]string](<#Registry.GetAvailableRegions>)
  - [func \(r \*Registry\) GetAvailableTaskTypes\(\) \[\]string](<#Registry.GetAvailableTaskTypes>)
  - [func \(r \*Registry\) GetCachedFragments\(\) \[\]string](<#Registry.GetCachedFragments>)
  - [func \(r \*Registry\) GetCachedPrompts\(\) \[\]string](<#Registry.GetCachedPrompts>)
  - [func \(r \*Registry\) GetLoadedFragments\(\) \[\]string](<#Registry.GetLoadedFragments>)
  - [func \(r \*Registry\) GetLoadedPrompts\(\) \[\]string](<#Registry.GetLoadedPrompts>)
  - [func \(r \*Registry\) GetPromptInfo\(taskType string\) \(\*PromptInfo, error\)](<#Registry.GetPromptInfo>)
  - [func \(r \*Registry\) ListTaskTypes\(\) \[\]string](<#Registry.ListTaskTypes>)
  - [func \(r \*Registry\) Load\(activity string\) \*AssembledPrompt](<#Registry.Load>)
  - [func \(r \*Registry\) LoadConfig\(activity string\) \(\*PromptConfig, error\)](<#Registry.LoadConfig>)
  - [func \(r \*Registry\) LoadWithVars\(activity string, vars map\[string\]string, model string\) \*AssembledPrompt](<#Registry.LoadWithVars>)
  - [func \(r \*Registry\) RegisterConfig\(taskType string, config \*PromptConfig\) error](<#Registry.RegisterConfig>)
- [type TemplateEngineInfo](<#TemplateEngineInfo>)
- [type TestResultSummary](<#TestResultSummary>)
  - [func ConvertFromEngineResults\(engineResults \[\]interface\{\}\) \[\]TestResultSummary](<#ConvertFromEngineResults>)
- [type TimeProvider](<#TimeProvider>)
- [type ToolPolicyPack](<#ToolPolicyPack>)
- [type ValidatorConfig](<#ValidatorConfig>)
- [type VariableMetadata](<#VariableMetadata>)
- [type VariableValidation](<#VariableValidation>)
- [type VideoConfig](<#VideoConfig>)
  - [func GetVideoConfig\(config \*MediaConfig\) \*VideoConfig](<#GetVideoConfig>)


<a name="ExtractVariablesFromTemplate"></a>
## func ExtractVariablesFromTemplate

```go
func ExtractVariablesFromTemplate(template string) []string
```

ExtractVariablesFromTemplate analyzes a template string and extracts variable names This helps auto\-generate variable metadata when not explicitly specified

<a name="GetDefaultPipelineConfig"></a>
## func GetDefaultPipelineConfig

```go
func GetDefaultPipelineConfig() map[string]interface{}
```

GetDefaultPipelineConfig returns the default Arena pipeline configuration Returns as map to avoid import cycle with pipeline package

<a name="GetUsedVars"></a>
## func GetUsedVars

```go
func GetUsedVars(vars map[string]string) []string
```

GetUsedVars returns a list of variable names that had non\-empty values Deprecated: Use template.GetUsedVars instead

<a name="SupportsMediaType"></a>
## func SupportsMediaType

```go
func SupportsMediaType(config *MediaConfig, mediaType string) bool
```

SupportsMediaType checks if a MediaConfig supports a specific media type

<a name="ValidateMediaConfig"></a>
## func ValidateMediaConfig

```go
func ValidateMediaConfig(config *MediaConfig) error
```

ValidateMediaConfig validates a MediaConfig for correctness and completeness

<a name="AssembledPrompt"></a>
## type AssembledPrompt

AssembledPrompt represents a complete prompt ready for LLM execution.

```go
type AssembledPrompt struct {
    TaskType     string            `json:"task_type"`
    SystemPrompt string            `json:"system_prompt"`
    AllowedTools []string          `json:"allowed_tools,omitempty"` // Tools this prompt can use
    Validators   []ValidatorConfig `json:"validators,omitempty"`    // Validators to apply at runtime
}
```

<a name="AssembledPrompt.UsesTools"></a>
### func \(\*AssembledPrompt\) UsesTools

```go
func (ap *AssembledPrompt) UsesTools() bool
```

UsesTools returns true if this prompt has tools configured

<a name="AudioConfig"></a>
## type AudioConfig

AudioConfig contains audio\-specific configuration

```go
type AudioConfig struct {
    // Maximum audio size in MB (0 = unlimited)
    MaxSizeMB int `yaml:"max_size_mb,omitempty" json:"max_size_mb,omitempty"`
    // Allowed formats: ["mp3", "wav", "ogg", "webm"]
    AllowedFormats []string `yaml:"allowed_formats,omitempty" json:"allowed_formats,omitempty"`
    // Max duration in seconds (0 = unlimited)
    MaxDurationSec int `yaml:"max_duration_sec,omitempty" json:"max_duration_sec,omitempty"`
    // Whether metadata (duration, bitrate) is required
    RequireMetadata bool `yaml:"require_metadata,omitempty" json:"require_metadata,omitempty"`
}
```

<a name="GetAudioConfig"></a>
### func GetAudioConfig

```go
func GetAudioConfig(config *MediaConfig) *AudioConfig
```

GetAudioConfig returns the audio configuration if audio is supported

<a name="ChangelogEntry"></a>
## type ChangelogEntry

ChangelogEntry records a change in the prompt configuration

```go
type ChangelogEntry struct {
    Version     string `yaml:"version"`          // Version number
    Date        string `yaml:"date"`             // Date of change (YYYY-MM-DD)
    Author      string `yaml:"author,omitempty"` // Author of change
    Description string `yaml:"description"`      // Description of change
}
```

<a name="CompilationInfo"></a>
## type CompilationInfo

CompilationInfo contains information about prompt compilation

```go
type CompilationInfo struct {
    CompiledWith string `yaml:"compiled_with"`    // Compiler version
    CreatedAt    string `yaml:"created_at"`       // Timestamp (RFC3339)
    Schema       string `yaml:"schema,omitempty"` // Pack schema version (e.g., "v1")
}
```

<a name="CostEstimate"></a>
## type CostEstimate

CostEstimate provides estimated costs for prompt execution

```go
type CostEstimate struct {
    MinCostUSD float64 `yaml:"min_cost_usd"` // Minimum cost per execution
    MaxCostUSD float64 `yaml:"max_cost_usd"` // Maximum cost per execution
    AvgCostUSD float64 `yaml:"avg_cost_usd"` // Average cost per execution
}
```

<a name="ExampleContentPart"></a>
## type ExampleContentPart

ExampleContentPart represents a content part in an example \(simplified for YAML\)

```go
type ExampleContentPart struct {
    // Content type: "text", "image", "audio", "video"
    Type string `yaml:"type" json:"type"`
    // Text content (for type=text)
    Text string `yaml:"text,omitempty" json:"text,omitempty"`
    // For media content
    Media *ExampleMedia `yaml:"media,omitempty" json:"media,omitempty"`
}
```

<a name="ExampleMedia"></a>
## type ExampleMedia

ExampleMedia represents media references in examples

```go
type ExampleMedia struct {
    // Relative path to media file
    FilePath string `yaml:"file_path,omitempty" json:"file_path,omitempty"`
    // External URL
    URL string `yaml:"url,omitempty" json:"url,omitempty"`
    // MIME type
    MIMEType string `yaml:"mime_type" json:"mime_type"`
    // Detail level for images
    Detail string `yaml:"detail,omitempty" json:"detail,omitempty"`
    // Optional caption
    Caption string `yaml:"caption,omitempty" json:"caption,omitempty"`
}
```

<a name="FileWriter"></a>
## type FileWriter

FileWriter abstracts file writing for testing

```go
type FileWriter interface {
    WriteFile(path string, data []byte, perm os.FileMode) error
}
```

<a name="Fragment"></a>
## type Fragment

Fragment represents a reusable prompt fragment

```go
type Fragment struct {
    Type              string `yaml:"fragment_type"`
    Version           string `yaml:"version"`
    Description       string `yaml:"description"`
    Content           string `yaml:"content"`
    SourceFile        string `yaml:"source_file,omitempty"`         // Source file path (for pack compilation)
    ResolvedAtCompile bool   `yaml:"resolved_at_compile,omitempty"` // Whether resolved at compile time
}
```

<a name="FragmentRef"></a>
## type FragmentRef

FragmentRef references a prompt fragment for assembly

```go
type FragmentRef struct {
    Name     string `yaml:"name"`
    Path     string `yaml:"path,omitempty"` // Optional: relative path to fragment file
    Required bool   `yaml:"required"`
}
```

<a name="FragmentRepository"></a>
## type FragmentRepository

FragmentRepository interface for loading fragments \(to avoid import cycles\)

```go
type FragmentRepository interface {
    LoadFragment(name string, relativePath string, baseDir string) (*Fragment, error)
}
```

<a name="FragmentResolver"></a>
## type FragmentResolver

FragmentResolver handles fragment loading, resolution, and variable substitution using the repository pattern

```go
type FragmentResolver struct {
    // contains filtered or unexported fields
}
```

<a name="NewFragmentResolverWithRepository"></a>
### func NewFragmentResolverWithRepository

```go
func NewFragmentResolverWithRepository(repository FragmentRepository) *FragmentResolver
```

NewFragmentResolverWithRepository creates a new fragment resolver with a repository

<a name="FragmentResolver.AssembleFragments"></a>
### func \(\*FragmentResolver\) AssembleFragments

```go
func (fr *FragmentResolver) AssembleFragments(fragments []FragmentRef, vars map[string]string, configFilePath string) (map[string]string, error)
```

AssembleFragments loads and assembles prompt fragments into variables. Resolves dynamic names and paths using the provided variable map.

<a name="FragmentResolver.LoadFragment"></a>
### func \(\*FragmentResolver\) LoadFragment

```go
func (fr *FragmentResolver) LoadFragment(name string, relativePath string, configFilePath string) (*Fragment, error)
```

LoadFragment loads a fragment from the repository with caching. Uses name as cache key, or path if provided.

<a name="ImageConfig"></a>
## type ImageConfig

ImageConfig contains image\-specific configuration

```go
type ImageConfig struct {
    // Maximum image size in MB (0 = unlimited)
    MaxSizeMB int `yaml:"max_size_mb,omitempty" json:"max_size_mb,omitempty"`
    // Allowed formats: ["jpeg", "png", "webp", "gif"]
    AllowedFormats []string `yaml:"allowed_formats,omitempty" json:"allowed_formats,omitempty"`
    // Default detail level: "low", "high", "auto"
    DefaultDetail string `yaml:"default_detail,omitempty" json:"default_detail,omitempty"`
    // Whether captions are required
    RequireCaption bool `yaml:"require_caption,omitempty" json:"require_caption,omitempty"`
    // Max images per message (0 = unlimited)
    MaxImagesPerMsg int `yaml:"max_images_per_msg,omitempty" json:"max_images_per_msg,omitempty"`
}
```

<a name="GetImageConfig"></a>
### func GetImageConfig

```go
func GetImageConfig(config *MediaConfig) *ImageConfig
```

GetImageConfig returns the image configuration if images are supported

<a name="MediaConfig"></a>
## type MediaConfig

MediaConfig defines multimodal media support configuration for a prompt

```go
type MediaConfig struct {
    // Enable multimodal support for this prompt
    Enabled bool `yaml:"enabled" json:"enabled"`
    // Supported content types: "image", "audio", "video"
    SupportedTypes []string `yaml:"supported_types,omitempty" json:"supported_types,omitempty"`
    // Image-specific configuration
    Image *ImageConfig `yaml:"image,omitempty" json:"image,omitempty"`
    // Audio-specific configuration
    Audio *AudioConfig `yaml:"audio,omitempty" json:"audio,omitempty"`
    // Video-specific configuration
    Video *VideoConfig `yaml:"video,omitempty" json:"video,omitempty"`
    // Example multimodal messages
    Examples []MultimodalExample `yaml:"examples,omitempty" json:"examples,omitempty"`
}
```

<a name="MetadataBuilder"></a>
## type MetadataBuilder

MetadataBuilder helps construct pack format metadata from prompt configs and test results

```go
type MetadataBuilder struct {
    // contains filtered or unexported fields
}
```

<a name="NewMetadataBuilder"></a>
### func NewMetadataBuilder

```go
func NewMetadataBuilder(spec *PromptSpec) *MetadataBuilder
```

NewMetadataBuilder creates a new metadata builder for a prompt spec

<a name="MetadataBuilder.AddChangelogEntry"></a>
### func \(\*MetadataBuilder\) AddChangelogEntry

```go
func (mb *MetadataBuilder) AddChangelogEntry(version string, author string, description string)
```

AddChangelogEntry adds a new entry to the prompt's changelog

<a name="MetadataBuilder.BuildCompilationInfo"></a>
### func \(\*MetadataBuilder\) BuildCompilationInfo

```go
func (mb *MetadataBuilder) BuildCompilationInfo(compilerVersion string) *CompilationInfo
```

BuildCompilationInfo generates compilation metadata

<a name="MetadataBuilder.BuildPromptMetadata"></a>
### func \(\*MetadataBuilder\) BuildPromptMetadata

```go
func (mb *MetadataBuilder) BuildPromptMetadata(domain string, language string, tags []string, testResults []TestResultSummary) *PromptMetadata
```

BuildPromptMetadata generates PromptMetadata from test execution results

<a name="MetadataBuilder.SetDomain"></a>
### func \(\*MetadataBuilder\) SetDomain

```go
func (mb *MetadataBuilder) SetDomain(domain string)
```

SetDomain sets the domain for the prompt metadata

<a name="MetadataBuilder.SetLanguage"></a>
### func \(\*MetadataBuilder\) SetLanguage

```go
func (mb *MetadataBuilder) SetLanguage(language string)
```

SetLanguage sets the language for the prompt metadata

<a name="MetadataBuilder.SetTags"></a>
### func \(\*MetadataBuilder\) SetTags

```go
func (mb *MetadataBuilder) SetTags(tags []string)
```

SetTags sets the tags for the prompt metadata

<a name="MetadataBuilder.UpdateFromCostInfo"></a>
### func \(\*MetadataBuilder\) UpdateFromCostInfo

```go
func (mb *MetadataBuilder) UpdateFromCostInfo(costs []types.CostInfo)
```

UpdateFromCostInfo updates cost estimate from types.CostInfo

<a name="MetadataBuilder.ValidateMetadata"></a>
### func \(\*MetadataBuilder\) ValidateMetadata

```go
func (mb *MetadataBuilder) ValidateMetadata() []string
```

ValidateMetadata checks that metadata fields are properly populated

<a name="ModelOverride"></a>
## type ModelOverride

ModelOverride contains model\-specific template modifications. Note: Temperature and MaxTokens should be configured at the scenario or provider level, not in the prompt configuration.

```go
type ModelOverride struct {
    SystemTemplate       string `yaml:"system_template,omitempty"`
    SystemTemplateSuffix string `yaml:"system_template_suffix,omitempty"`
}
```

<a name="ModelTestResultRef"></a>
## type ModelTestResultRef

ModelTestResultRef is a simplified reference to model test results The full ModelTestResult type is in pkg/engine for tracking test execution

```go
type ModelTestResultRef struct {
    Provider     string  `yaml:"provider"`
    Model        string  `yaml:"model"`
    Date         string  `yaml:"date"`
    SuccessRate  float64 `yaml:"success_rate"`
    AvgTokens    int     `yaml:"avg_tokens,omitempty"`
    AvgCost      float64 `yaml:"avg_cost,omitempty"`
    AvgLatencyMs int     `yaml:"avg_latency_ms,omitempty"`
}
```

<a name="AggregateTestResults"></a>
### func AggregateTestResults

```go
func AggregateTestResults(results []TestResultSummary, provider string, model string) *ModelTestResultRef
```

AggregateTestResults computes ModelTestResultRef from test execution summaries

<a name="MultimodalExample"></a>
## type MultimodalExample

MultimodalExample represents an example multimodal message for testing/documentation

```go
type MultimodalExample struct {
    // Example name/identifier
    Name string `yaml:"name" json:"name"`
    // Human-readable description
    Description string `yaml:"description,omitempty" json:"description,omitempty"`
    // Message role: "user", "assistant"
    Role string `yaml:"role" json:"role"`
    // Content parts for this example
    Parts []ExampleContentPart `yaml:"parts" json:"parts"`
}
```

<a name="Pack"></a>
## type Pack

Pack represents the complete JSON pack format containing MULTIPLE prompts for different task types.

DESIGN DECISION: Why separate Pack types in runtime vs sdk?

This runtime Pack is optimized for COMPILATION:

- Created by PackCompiler from prompt registry
- Includes Compilation and Metadata for tracking provenance
- Returns validation warnings \(\[\]string\) for compiler feedback
- No thread\-safety needed \(single\-threaded compilation\)
- Simple types \(VariableMetadata, ValidatorConfig\) for JSON serialization

The sdk.Pack is optimized for LOADING & EXECUTION:

- Loaded from .pack.json files for application use
- Includes Tools map and filePath for execution context
- Thread\-safe with sync.RWMutex for concurrent access
- Returns validation errors for application error handling
- Rich types \(\*Variable, \*Validator\) with additional methods
- Has CreateRegistry\(\) to convert back to runtime.Registry for pipeline

Both serialize to/from the SAME JSON format \(.pack.json files\), ensuring full interoperability. The type duplication is intentional and prevents circular dependencies while allowing each module to evolve independently.

See sdk/pack.go for the corresponding SDK\-side documentation.

```go
type Pack struct {
    // Identity
    ID          string `json:"id"`          // Pack ID (e.g., "customer-support")
    Name        string `json:"name"`        // Human-readable name
    Version     string `json:"version"`     // Pack version
    Description string `json:"description"` // Pack description

    // Template Engine (shared across all prompts in pack)
    TemplateEngine *TemplateEngineInfo `json:"template_engine"`

    // Prompts - Map of task_type -> PackPrompt
    Prompts map[string]*PackPrompt `json:"prompts"`

    // Shared fragments (can be referenced by any prompt)
    Fragments map[string]string `json:"fragments,omitempty"` // Resolved fragments: name -> content

    // Metadata
    Metadata    *PromptMetadata  `json:"metadata,omitempty"`
    Compilation *CompilationInfo `json:"compilation,omitempty"`
}
```

<a name="LoadPack"></a>
### func LoadPack

```go
func LoadPack(filePath string) (*Pack, error)
```

LoadPack loads a pack from a JSON file

<a name="Pack.GetOptionalVariables"></a>
### func \(\*Pack\) GetOptionalVariables

```go
func (p *Pack) GetOptionalVariables(taskType string) map[string]string
```

GetOptionalVariables returns all optional variable names with defaults for a specific prompt

<a name="Pack.GetPrompt"></a>
### func \(\*Pack\) GetPrompt

```go
func (p *Pack) GetPrompt(taskType string) *PackPrompt
```

GetPrompt returns a specific prompt by task type

<a name="Pack.GetRequiredVariables"></a>
### func \(\*Pack\) GetRequiredVariables

```go
func (p *Pack) GetRequiredVariables(taskType string) []string
```

GetRequiredVariables returns all required variable names for a specific prompt

<a name="Pack.GetToolNames"></a>
### func \(\*Pack\) GetToolNames

```go
func (p *Pack) GetToolNames(taskType string) []string
```

GetToolNames returns the list of allowed tool names for a specific prompt

<a name="Pack.ListPrompts"></a>
### func \(\*Pack\) ListPrompts

```go
func (p *Pack) ListPrompts() []string
```

ListPrompts returns all prompt task types in the pack

<a name="Pack.Summary"></a>
### func \(\*Pack\) Summary

```go
func (p *Pack) Summary() string
```

Summary returns a brief summary of the pack

<a name="Pack.Validate"></a>
### func \(\*Pack\) Validate

```go
func (p *Pack) Validate() []string
```

Validate validates a pack format

<a name="PackCompiler"></a>
## type PackCompiler

PackCompiler compiles PromptConfig to Pack format

```go
type PackCompiler struct {
    // contains filtered or unexported fields
}
```

<a name="NewPackCompiler"></a>
### func NewPackCompiler

```go
func NewPackCompiler(registry *Registry) *PackCompiler
```

NewPackCompiler creates a new pack compiler with default dependencies

<a name="NewPackCompilerWithDeps"></a>
### func NewPackCompilerWithDeps

```go
func NewPackCompilerWithDeps(loader PromptLoader, timeProvider TimeProvider, fileWriter FileWriter) *PackCompiler
```

NewPackCompilerWithDeps creates a pack compiler with injected dependencies \(for testing\)

<a name="PackCompiler.Compile"></a>
### func \(\*PackCompiler\) Compile

```go
func (pc *PackCompiler) Compile(taskType, compilerVersion string) (*Pack, error)
```

Compile compiles a single prompt config to Pack format \(for backward compatibility\)

<a name="PackCompiler.CompileFromRegistry"></a>
### func \(\*PackCompiler\) CompileFromRegistry

```go
func (pc *PackCompiler) CompileFromRegistry(packID, compilerVersion string) (*Pack, error)
```

CompileFromRegistry compiles ALL prompts from the registry into a single Pack

<a name="PackCompiler.CompileToFile"></a>
### func \(\*PackCompiler\) CompileToFile

```go
func (pc *PackCompiler) CompileToFile(taskType, outputPath, compilerVersion string) error
```

CompileToFile compiles a prompt config to a JSON pack file

<a name="PackCompiler.MarshalPack"></a>
### func \(\*PackCompiler\) MarshalPack

```go
func (pc *PackCompiler) MarshalPack(pack *Pack) ([]byte, error)
```

MarshalPack marshals pack to JSON \(testable without I/O\)

<a name="PackCompiler.WritePack"></a>
### func \(\*PackCompiler\) WritePack

```go
func (pc *PackCompiler) WritePack(pack *Pack, outputPath string) error
```

WritePack writes a pack to a file

<a name="PackPrompt"></a>
## type PackPrompt

PackPrompt represents a single prompt configuration within a pack

```go
type PackPrompt struct {
    // Identity
    ID          string `json:"id"`          // Prompt ID (task_type)
    Name        string `json:"name"`        // Human-readable name
    Description string `json:"description"` // Prompt description
    Version     string `json:"version"`     // Prompt version

    // Prompt
    SystemTemplate string `json:"system_template"`

    // Variables
    Variables []VariableMetadata `json:"variables,omitempty"`

    // Tools
    Tools      []string        `json:"tools,omitempty"`       // Allowed tool names
    ToolPolicy *ToolPolicyPack `json:"tool_policy,omitempty"` // Tool usage policy

    // Multimodal media configuration
    MediaConfig *MediaConfig `json:"media,omitempty"`

    // Pipeline
    Pipeline map[string]interface{} `json:"pipeline,omitempty"` // Pipeline configuration

    // Parameters
    Parameters *ParametersPack `json:"parameters,omitempty"` // Model-specific parameters

    // Validators
    Validators []ValidatorConfig `json:"validators,omitempty"`

    // Model Testing
    TestedModels []ModelTestResultRef `json:"tested_models,omitempty"`

    // Model Overrides
    ModelOverrides map[string]ModelOverride `json:"model_overrides,omitempty"`
}
```

<a name="ParametersPack"></a>
## type ParametersPack

ParametersPack represents model parameters in pack format

```go
type ParametersPack struct {
    Temperature *float64 `json:"temperature,omitempty"`
    MaxTokens   *int     `json:"max_tokens,omitempty"`
    TopP        *float64 `json:"top_p,omitempty"`
    TopK        *int     `json:"top_k,omitempty"`
}
```

<a name="PerformanceMetrics"></a>
## type PerformanceMetrics

PerformanceMetrics provides performance benchmarks

```go
type PerformanceMetrics struct {
    AvgLatencyMs int     `yaml:"avg_latency_ms"` // Average latency in milliseconds
    P95LatencyMs int     `yaml:"p95_latency_ms"` // 95th percentile latency
    AvgTokens    int     `yaml:"avg_tokens"`     // Average tokens used
    SuccessRate  float64 `yaml:"success_rate"`   // Success rate (0.0-1.0)
}
```

<a name="PromptConfig"></a>
## type PromptConfig

PromptConfig represents a YAML prompt configuration file in K8s\-style manifest format

```go
type PromptConfig struct {
    APIVersion string            `yaml:"apiVersion"`
    Kind       string            `yaml:"kind"`
    Metadata   metav1.ObjectMeta `yaml:"metadata,omitempty"`
    Spec       PromptSpec        `yaml:"spec"`
}
```

<a name="ParsePromptConfig"></a>
### func ParsePromptConfig

```go
func ParsePromptConfig(data []byte) (*PromptConfig, error)
```

ParsePromptConfig parses a prompt config from YAML data. This is a package\-level utility function for parsing prompt configs in the config layer. The config layer should read files using os.ReadFile and pass the data to this function. Returns the parsed PromptConfig or an error if parsing/validation fails.

<a name="PromptInfo"></a>
## type PromptInfo

PromptInfo provides summary information about a prompt configuration

```go
type PromptInfo struct {
    TaskType       string
    Version        string
    Description    string
    FragmentCount  int
    RequiredVars   []string
    OptionalVars   []string
    ToolAllowlist  []string
    ModelOverrides []string
}
```

<a name="PromptLoader"></a>
## type PromptLoader

PromptLoader interface abstracts the registry for testing

```go
type PromptLoader interface {
    LoadConfig(taskType string) (*PromptConfig, error)
    ListTaskTypes() []string
}
```

<a name="PromptMetadata"></a>
## type PromptMetadata

PromptMetadata contains additional metadata for the pack format

```go
type PromptMetadata struct {
    Domain       string              `yaml:"domain,omitempty"`        // Domain/category (e.g., "customer-support")
    Language     string              `yaml:"language,omitempty"`      // Primary language (e.g., "en")
    Tags         []string            `yaml:"tags,omitempty"`          // Tags for categorization
    CostEstimate *CostEstimate       `yaml:"cost_estimate,omitempty"` // Estimated cost per execution
    Performance  *PerformanceMetrics `yaml:"performance,omitempty"`   // Performance benchmarks
    Changelog    []ChangelogEntry    `yaml:"changelog,omitempty"`     // Version history
}
```

<a name="PromptRepository"></a>
## type PromptRepository

PromptRepository interface defines methods for loading prompts \(to avoid import cycles\) This should match persistence.PromptRepository interface

```go
type PromptRepository interface {
    LoadPrompt(taskType string) (*PromptConfig, error)
    LoadFragment(name string, relativePath string, baseDir string) (*Fragment, error)
    ListPrompts() ([]string, error)
    SavePrompt(config *PromptConfig) error
}
```

<a name="PromptSpec"></a>
## type PromptSpec

PromptSpec contains the actual prompt configuration

```go
type PromptSpec struct {
    TaskType       string                   `yaml:"task_type"`
    Version        string                   `yaml:"version"`
    Description    string                   `yaml:"description"`
    TemplateEngine *TemplateEngineInfo      `yaml:"template_engine,omitempty"` // Template engine configuration
    Fragments      []FragmentRef            `yaml:"fragments,omitempty"`       // New: fragment assembly
    SystemTemplate string                   `yaml:"system_template"`
    RequiredVars   []string                 `yaml:"required_vars"`
    OptionalVars   map[string]string        `yaml:"optional_vars"`
    Variables      []VariableMetadata       `yaml:"variables,omitempty"` // Enhanced variable metadata
    ModelOverrides map[string]ModelOverride `yaml:"model_overrides"`
    AllowedTools   []string                 `yaml:"allowed_tools,omitempty"` // Tools this prompt can use
    MediaConfig    *MediaConfig             `yaml:"media,omitempty"`         // Multimodal media configuration
    Validators     []ValidatorConfig        `yaml:"validators,omitempty"`    // Validators/Guardrails for production runtime
    TestedModels   []ModelTestResultRef     `yaml:"tested_models,omitempty"` // Model testing metadata
    Metadata       *PromptMetadata          `yaml:"metadata,omitempty"`      // Additional metadata for pack format
    Compilation    *CompilationInfo         `yaml:"compilation,omitempty"`   // Compilation information
}
```

<a name="Registry"></a>
## type Registry

Registry manages prompt templates, versions, and variable substitution.

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistryWithRepository"></a>
### func NewRegistryWithRepository

```go
func NewRegistryWithRepository(repository PromptRepository) *Registry
```

NewRegistryWithRepository creates a registry with a repository \(new preferred method\). This constructor uses the repository pattern for loading prompts, avoiding direct file I/O.

<a name="Registry.ClearCache"></a>
### func \(\*Registry\) ClearCache

```go
func (r *Registry) ClearCache()
```

ClearCache clears all cached prompts and fragments

<a name="Registry.GetAvailableRegions"></a>
### func \(\*Registry\) GetAvailableRegions

```go
func (r *Registry) GetAvailableRegions() []string
```

GetAvailableRegions returns a list of all available regions from prompt fragments

<a name="Registry.GetAvailableTaskTypes"></a>
### func \(\*Registry\) GetAvailableTaskTypes

```go
func (r *Registry) GetAvailableTaskTypes() []string
```

GetAvailableTaskTypes is deprecated: use ListTaskTypes instead

<a name="Registry.GetCachedFragments"></a>
### func \(\*Registry\) GetCachedFragments

```go
func (r *Registry) GetCachedFragments() []string
```

GetCachedFragments returns a list of currently cached fragment keys.

<a name="Registry.GetCachedPrompts"></a>
### func \(\*Registry\) GetCachedPrompts

```go
func (r *Registry) GetCachedPrompts() []string
```

GetCachedPrompts returns a list of currently cached prompt task types. For a complete list including uncached prompts, use ListTaskTypes instead.

<a name="Registry.GetLoadedFragments"></a>
### func \(\*Registry\) GetLoadedFragments

```go
func (r *Registry) GetLoadedFragments() []string
```

GetLoadedFragments is deprecated: use GetCachedFragments instead

<a name="Registry.GetLoadedPrompts"></a>
### func \(\*Registry\) GetLoadedPrompts

```go
func (r *Registry) GetLoadedPrompts() []string
```

GetLoadedPrompts is deprecated: use GetCachedPrompts instead

<a name="Registry.GetPromptInfo"></a>
### func \(\*Registry\) GetPromptInfo

```go
func (r *Registry) GetPromptInfo(taskType string) (*PromptInfo, error)
```

GetPromptInfo returns detailed information about a prompt configuration

<a name="Registry.ListTaskTypes"></a>
### func \(\*Registry\) ListTaskTypes

```go
func (r *Registry) ListTaskTypes() []string
```

ListTaskTypes returns all available task types from the repository. Falls back to cached task types if repository is unavailable or returns empty.

<a name="Registry.Load"></a>
### func \(\*Registry\) Load

```go
func (r *Registry) Load(activity string) *AssembledPrompt
```

Load returns an assembled prompt for the specified activity with variable substitution.

<a name="Registry.LoadConfig"></a>
### func \(\*Registry\) LoadConfig

```go
func (r *Registry) LoadConfig(activity string) (*PromptConfig, error)
```

LoadConfig is deprecated: use loadConfig directly \(internal use\) or use Load/LoadWithVars

<a name="Registry.LoadWithVars"></a>
### func \(\*Registry\) LoadWithVars

```go
func (r *Registry) LoadWithVars(activity string, vars map[string]string, model string) *AssembledPrompt
```

LoadWithVars loads a prompt with variable substitution and optional model override.

<a name="Registry.RegisterConfig"></a>
### func \(\*Registry\) RegisterConfig

```go
func (r *Registry) RegisterConfig(taskType string, config *PromptConfig) error
```

RegisterConfig registers a PromptConfig directly into the registry. This allows programmatic registration of prompts without requiring disk files. Useful for loading prompts from compiled packs or other in\-memory sources. If a repository is configured, the config is persisted there as well.

<a name="TemplateEngineInfo"></a>
## type TemplateEngineInfo

TemplateEngineInfo describes the template engine used for variable substitution

```go
type TemplateEngineInfo struct {
    Version  string   `yaml:"version"`            // Template engine version (e.g., "v1")
    Syntax   string   `yaml:"syntax"`             // Template syntax (e.g., "{{variable}}")
    Features []string `yaml:"features,omitempty"` // Supported features (e.g., "conditionals", "loops")
}
```

<a name="TestResultSummary"></a>
## type TestResultSummary

TestResultSummary contains summarized test execution data

```go
type TestResultSummary struct {
    Success   bool
    Cost      float64
    LatencyMs int
    Tokens    int
}
```

<a name="ConvertFromEngineResults"></a>
### func ConvertFromEngineResults

```go
func ConvertFromEngineResults(engineResults []interface{}) []TestResultSummary
```

ConvertFromEngineResults converts engine RunResults to TestResultSummary This is a helper to bridge between engine execution and metadata generation

<a name="TimeProvider"></a>
## type TimeProvider

TimeProvider allows injecting time for deterministic tests

```go
type TimeProvider interface {
    Now() time.Time
}
```

<a name="ToolPolicyPack"></a>
## type ToolPolicyPack

ToolPolicyPack represents tool policy in pack format

```go
type ToolPolicyPack struct {
    ToolChoice          string   `json:"tool_choice,omitempty"`
    MaxRounds           int      `json:"max_rounds,omitempty"`
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="ValidatorConfig"></a>
## type ValidatorConfig

ValidatorConfig extends validators.ValidatorConfig with prompt\-pack specific fields

```go
type ValidatorConfig struct {
    // Embed base config (Type, Params)
    validators.ValidatorConfig `yaml:",inline"`
    // Enable/disable validator (default: true)
    Enabled *bool `yaml:"enabled,omitempty"`
    // Fail execution on violation (default: true)
    FailOnViolation *bool `yaml:"fail_on_violation,omitempty"`
}
```

<a name="VariableMetadata"></a>
## type VariableMetadata

VariableMetadata contains enhanced metadata for a variable

```go
type VariableMetadata struct {
    Name        string              `yaml:"name"`                  // Variable name
    Type        string              `yaml:"type,omitempty"`        // Variable type (string, int, etc.)
    Required    bool                `yaml:"required"`              // Whether variable is required
    Default     string              `yaml:"default,omitempty"`     // Default value if optional
    Description string              `yaml:"description,omitempty"` // Human-readable description
    Example     string              `yaml:"example,omitempty"`     // Example value
    Enum        []string            `yaml:"enum,omitempty"`        // Allowed values
    Validation  *VariableValidation `yaml:"validation,omitempty"`  // Validation rules
}
```

<a name="VariableValidation"></a>
## type VariableValidation

VariableValidation contains validation rules for a variable

```go
type VariableValidation struct {
    Pattern   string `yaml:"pattern,omitempty"`    // Regex pattern
    MinLength int    `yaml:"min_length,omitempty"` // Minimum length
    MaxLength int    `yaml:"max_length,omitempty"` // Maximum length
}
```

<a name="VideoConfig"></a>
## type VideoConfig

VideoConfig contains video\-specific configuration

```go
type VideoConfig struct {
    // Maximum video size in MB (0 = unlimited)
    MaxSizeMB int `yaml:"max_size_mb,omitempty" json:"max_size_mb,omitempty"`
    // Allowed formats: ["mp4", "webm", "ogg"]
    AllowedFormats []string `yaml:"allowed_formats,omitempty" json:"allowed_formats,omitempty"`
    // Max duration in seconds (0 = unlimited)
    MaxDurationSec int `yaml:"max_duration_sec,omitempty" json:"max_duration_sec,omitempty"`
    // Whether metadata (resolution, fps) is required
    RequireMetadata bool `yaml:"require_metadata,omitempty" json:"require_metadata,omitempty"`
}
```

<a name="GetVideoConfig"></a>
### func GetVideoConfig

```go
func GetVideoConfig(config *MediaConfig) *VideoConfig
```

GetVideoConfig returns the video configuration if video is supported

# providers

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers"
```

Package providers implements multi\-LLM provider support with unified interfaces.

This package provides a common abstraction for predict\-based LLM providers including OpenAI, Anthropic Claude, and Google Gemini. It handles:

- Predict completion requests with streaming support
- Tool/function calling with provider\-specific formats
- Cost tracking and token usage calculation
- Rate limiting and error handling

All providers implement the Provider interface for basic predict, and ToolSupport interface for function calling capabilities.

## Index

- [func CheckHTTPError\(resp \*http.Response\) error](<#CheckHTTPError>)
- [func HasAudioSupport\(p Provider\) bool](<#HasAudioSupport>)
- [func HasImageSupport\(p Provider\) bool](<#HasImageSupport>)
- [func HasVideoSupport\(p Provider\) bool](<#HasVideoSupport>)
- [func IsFormatSupported\(p Provider, contentType string, mimeType string\) bool](<#IsFormatSupported>)
- [func IsValidationAbort\(err error\) bool](<#IsValidationAbort>)
- [func LoadFileAsBase64\(filePath string\) \(string, error\)](<#LoadFileAsBase64>)
- [func RegisterProviderFactory\(providerType string, factory ProviderFactory\)](<#RegisterProviderFactory>)
- [func SetErrorResponse\(predictResp \*PredictionResponse, respBody \[\]byte, start time.Time\)](<#SetErrorResponse>)
- [func StringPtr\(s string\) \*string](<#StringPtr>)
- [func SupportsMultimodal\(p Provider\) bool](<#SupportsMultimodal>)
- [func UnmarshalJSON\(respBody \[\]byte, v interface\{\}, predictResp \*PredictionResponse, start time.Time\) error](<#UnmarshalJSON>)
- [func ValidateMultimodalMessage\(p Provider, msg types.Message\) error](<#ValidateMultimodalMessage>)
- [func ValidateMultimodalRequest\(p MultimodalSupport, req PredictionRequest\) error](<#ValidateMultimodalRequest>)
- [type AudioStreamingCapabilities](<#AudioStreamingCapabilities>)
- [type BaseProvider](<#BaseProvider>)
  - [func NewBaseProvider\(id string, includeRawOutput bool, client \*http.Client\) BaseProvider](<#NewBaseProvider>)
  - [func NewBaseProviderWithAPIKey\(id string, includeRawOutput bool, primaryKey, fallbackKey string\) \(BaseProvider, string\)](<#NewBaseProviderWithAPIKey>)
  - [func \(b \*BaseProvider\) Close\(\) error](<#BaseProvider.Close>)
  - [func \(b \*BaseProvider\) GetHTTPClient\(\) \*http.Client](<#BaseProvider.GetHTTPClient>)
  - [func \(b \*BaseProvider\) ID\(\) string](<#BaseProvider.ID>)
  - [func \(b \*BaseProvider\) ShouldIncludeRawOutput\(\) bool](<#BaseProvider.ShouldIncludeRawOutput>)
  - [func \(b \*BaseProvider\) SupportsStreaming\(\) bool](<#BaseProvider.SupportsStreaming>)
- [type ExecutionResult](<#ExecutionResult>)
- [type ImageDetail](<#ImageDetail>)
- [type MultimodalCapabilities](<#MultimodalCapabilities>)
- [type MultimodalSupport](<#MultimodalSupport>)
  - [func GetMultimodalProvider\(p Provider\) MultimodalSupport](<#GetMultimodalProvider>)
- [type MultimodalToolSupport](<#MultimodalToolSupport>)
- [type PredictionRequest](<#PredictionRequest>)
- [type PredictionResponse](<#PredictionResponse>)
- [type Pricing](<#Pricing>)
- [type Provider](<#Provider>)
  - [func CreateProviderFromSpec\(spec ProviderSpec\) \(Provider, error\)](<#CreateProviderFromSpec>)
- [type ProviderDefaults](<#ProviderDefaults>)
- [type ProviderFactory](<#ProviderFactory>)
- [type ProviderSpec](<#ProviderSpec>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func \(r \*Registry\) Close\(\) error](<#Registry.Close>)
  - [func \(r \*Registry\) Get\(id string\) \(Provider, bool\)](<#Registry.Get>)
  - [func \(r \*Registry\) List\(\) \[\]string](<#Registry.List>)
  - [func \(r \*Registry\) Register\(provider Provider\)](<#Registry.Register>)
- [type SSEScanner](<#SSEScanner>)
  - [func NewSSEScanner\(r io.Reader\) \*SSEScanner](<#NewSSEScanner>)
  - [func \(s \*SSEScanner\) Data\(\) string](<#SSEScanner.Data>)
  - [func \(s \*SSEScanner\) Err\(\) error](<#SSEScanner.Err>)
  - [func \(s \*SSEScanner\) Scan\(\) bool](<#SSEScanner.Scan>)
- [type StreamChunk](<#StreamChunk>)
- [type StreamEvent](<#StreamEvent>)
- [type StreamInputRequest](<#StreamInputRequest>)
  - [func \(r \*StreamInputRequest\) Validate\(\) error](<#StreamInputRequest.Validate>)
- [type StreamInputSession](<#StreamInputSession>)
- [type StreamInputSupport](<#StreamInputSupport>)
- [type StreamObserver](<#StreamObserver>)
- [type StreamingCapabilities](<#StreamingCapabilities>)
- [type ToolDescriptor](<#ToolDescriptor>)
- [type ToolResult](<#ToolResult>)
- [type ToolSupport](<#ToolSupport>)
- [type UnsupportedContentError](<#UnsupportedContentError>)
  - [func \(e \*UnsupportedContentError\) Error\(\) string](<#UnsupportedContentError.Error>)
- [type UnsupportedProviderError](<#UnsupportedProviderError>)
  - [func \(e \*UnsupportedProviderError\) Error\(\) string](<#UnsupportedProviderError.Error>)
- [type ValidationAbortError](<#ValidationAbortError>)
  - [func \(e \*ValidationAbortError\) Error\(\) string](<#ValidationAbortError.Error>)
- [type VideoResolution](<#VideoResolution>)
  - [func \(r VideoResolution\) String\(\) string](<#VideoResolution.String>)
- [type VideoStreamingCapabilities](<#VideoStreamingCapabilities>)


<a name="CheckHTTPError"></a>
## func CheckHTTPError

```go
func CheckHTTPError(resp *http.Response) error
```

CheckHTTPError checks if HTTP response is an error and returns formatted error with body

<a name="HasAudioSupport"></a>
## func HasAudioSupport

```go
func HasAudioSupport(p Provider) bool
```

HasAudioSupport checks if a provider supports audio inputs

<a name="HasImageSupport"></a>
## func HasImageSupport

```go
func HasImageSupport(p Provider) bool
```

HasImageSupport checks if a provider supports image inputs

<a name="HasVideoSupport"></a>
## func HasVideoSupport

```go
func HasVideoSupport(p Provider) bool
```

HasVideoSupport checks if a provider supports video inputs

<a name="IsFormatSupported"></a>
## func IsFormatSupported

```go
func IsFormatSupported(p Provider, contentType string, mimeType string) bool
```

IsFormatSupported checks if a provider supports a specific media format \(MIME type\)

<a name="IsValidationAbort"></a>
## func IsValidationAbort

```go
func IsValidationAbort(err error) bool
```

IsValidationAbort checks if an error is a validation abort

<a name="LoadFileAsBase64"></a>
## func LoadFileAsBase64

```go
func LoadFileAsBase64(filePath string) (string, error)
```

LoadFileAsBase64 reads a file and returns its content as a base64\-encoded string. It supports home directory expansion \(\~/path\) and is used by multimodal providers to load image files.

<a name="RegisterProviderFactory"></a>
## func RegisterProviderFactory

```go
func RegisterProviderFactory(providerType string, factory ProviderFactory)
```

RegisterProviderFactory registers a factory function for a provider type

<a name="SetErrorResponse"></a>
## func SetErrorResponse

```go
func SetErrorResponse(predictResp *PredictionResponse, respBody []byte, start time.Time)
```

SetErrorResponse sets latency and raw body on error responses

<a name="StringPtr"></a>
## func StringPtr

```go
func StringPtr(s string) *string
```

StringPtr is a helper function that returns a pointer to a string. This is commonly used across provider implementations for optional fields.

<a name="SupportsMultimodal"></a>
## func SupportsMultimodal

```go
func SupportsMultimodal(p Provider) bool
```

SupportsMultimodal checks if a provider implements multimodal support

<a name="UnmarshalJSON"></a>
## func UnmarshalJSON

```go
func UnmarshalJSON(respBody []byte, v interface{}, predictResp *PredictionResponse, start time.Time) error
```

UnmarshalJSON unmarshals JSON with error recovery that sets latency and raw response

<a name="ValidateMultimodalMessage"></a>
## func ValidateMultimodalMessage

```go
func ValidateMultimodalMessage(p Provider, msg types.Message) error
```

ValidateMultimodalMessage checks if a message's multimodal content is supported by the provider

<a name="ValidateMultimodalRequest"></a>
## func ValidateMultimodalRequest

```go
func ValidateMultimodalRequest(p MultimodalSupport, req PredictionRequest) error
```

ValidateMultimodalRequest validates all messages in a predict request for multimodal compatibility This is a helper function to reduce duplication across provider implementations

<a name="AudioStreamingCapabilities"></a>
## type AudioStreamingCapabilities

AudioStreamingCapabilities describes audio streaming support.

```go
type AudioStreamingCapabilities struct {
    // SupportedEncodings lists supported audio encodings
    // Common values: "pcm", "opus", "mp3", "aac"
    SupportedEncodings []string `json:"supported_encodings"`

    // SupportedSampleRates lists supported sample rates in Hz
    // Common values: 8000, 16000, 24000, 44100, 48000
    SupportedSampleRates []int `json:"supported_sample_rates"`

    // SupportedChannels lists supported channel counts
    // Common values: 1 (mono), 2 (stereo)
    SupportedChannels []int `json:"supported_channels"`

    // SupportedBitDepths lists supported bit depths
    // Common values: 16, 24, 32
    SupportedBitDepths []int `json:"supported_bit_depths,omitempty"`

    // PreferredEncoding is the recommended encoding for best quality/latency
    PreferredEncoding string `json:"preferred_encoding"`

    // PreferredSampleRate is the recommended sample rate
    PreferredSampleRate int `json:"preferred_sample_rate"`
}
```

<a name="BaseProvider"></a>
## type BaseProvider

BaseProvider provides common functionality shared across all provider implementations. It should be embedded in concrete provider structs to avoid code duplication.

```go
type BaseProvider struct {
    // contains filtered or unexported fields
}
```

<a name="NewBaseProvider"></a>
### func NewBaseProvider

```go
func NewBaseProvider(id string, includeRawOutput bool, client *http.Client) BaseProvider
```

NewBaseProvider creates a new BaseProvider with common fields

<a name="NewBaseProviderWithAPIKey"></a>
### func NewBaseProviderWithAPIKey

```go
func NewBaseProviderWithAPIKey(id string, includeRawOutput bool, primaryKey, fallbackKey string) (BaseProvider, string)
```

NewBaseProviderWithAPIKey creates a BaseProvider and retrieves API key from environment It tries the primary key first, then falls back to the secondary key if primary is empty.

<a name="BaseProvider.Close"></a>
### func \(\*BaseProvider\) Close

```go
func (b *BaseProvider) Close() error
```

Close closes the HTTP client's idle connections

<a name="BaseProvider.GetHTTPClient"></a>
### func \(\*BaseProvider\) GetHTTPClient

```go
func (b *BaseProvider) GetHTTPClient() *http.Client
```

GetHTTPClient returns the underlying HTTP client for provider\-specific use

<a name="BaseProvider.ID"></a>
### func \(\*BaseProvider\) ID

```go
func (b *BaseProvider) ID() string
```

ID returns the provider ID

<a name="BaseProvider.ShouldIncludeRawOutput"></a>
### func \(\*BaseProvider\) ShouldIncludeRawOutput

```go
func (b *BaseProvider) ShouldIncludeRawOutput() bool
```

ShouldIncludeRawOutput returns whether to include raw API responses in output

<a name="BaseProvider.SupportsStreaming"></a>
### func \(\*BaseProvider\) SupportsStreaming

```go
func (b *BaseProvider) SupportsStreaming() bool
```

SupportsStreaming returns true by default \(can be overridden by providers that don't support streaming\)

<a name="ExecutionResult"></a>
## type ExecutionResult

Forward declare ExecutionResult to avoid circular import

```go
type ExecutionResult interface{}
```

<a name="ImageDetail"></a>
## type ImageDetail

ImageDetail specifies the level of detail for image processing

```go
type ImageDetail string
```

<a name="ImageDetailLow"></a>

```go
const (
    ImageDetailLow  ImageDetail = "low"  // Faster, less detailed analysis
    ImageDetailHigh ImageDetail = "high" // Slower, more detailed analysis
    ImageDetailAuto ImageDetail = "auto" // Provider chooses automatically
)
```

<a name="MultimodalCapabilities"></a>
## type MultimodalCapabilities

MultimodalCapabilities describes what types of multimodal content a provider supports

```go
type MultimodalCapabilities struct {
    SupportsImages bool     // Provider can process image inputs
    SupportsAudio  bool     // Provider can process audio inputs
    SupportsVideo  bool     // Provider can process video inputs
    ImageFormats   []string // Supported image MIME types (e.g., "image/jpeg", "image/png")
    AudioFormats   []string // Supported audio MIME types (e.g., "audio/mpeg", "audio/wav")
    VideoFormats   []string // Supported video MIME types (e.g., "video/mp4")
    MaxImageSizeMB int      // Maximum image size in megabytes (0 = unlimited/unknown)
    MaxAudioSizeMB int      // Maximum audio size in megabytes (0 = unlimited/unknown)
    MaxVideoSizeMB int      // Maximum video size in megabytes (0 = unlimited/unknown)
}
```

<a name="MultimodalSupport"></a>
## type MultimodalSupport

MultimodalSupport interface for providers that support multimodal inputs

```go
type MultimodalSupport interface {
    Provider // Extends the base Provider interface

    // GetMultimodalCapabilities returns what types of multimodal content this provider supports
    GetMultimodalCapabilities() MultimodalCapabilities

    // PredictMultimodal performs a predict request with multimodal message content
    // Messages in the request can contain Parts with images, audio, or video
    PredictMultimodal(ctx context.Context, req PredictionRequest) (PredictionResponse, error)

    // PredictMultimodalStream performs a streaming predict request with multimodal content
    PredictMultimodalStream(ctx context.Context, req PredictionRequest) (<-chan StreamChunk, error)
}
```

<a name="GetMultimodalProvider"></a>
### func GetMultimodalProvider

```go
func GetMultimodalProvider(p Provider) MultimodalSupport
```

GetMultimodalProvider safely casts a provider to MultimodalSupport Returns nil if the provider doesn't support multimodal

<a name="MultimodalToolSupport"></a>
## type MultimodalToolSupport

MultimodalToolSupport interface for providers that support both multimodal and tools

```go
type MultimodalToolSupport interface {
    MultimodalSupport // Extends multimodal support
    ToolSupport       // Extends tool support

    // PredictMultimodalWithTools performs a predict request with both multimodal content and tools
    PredictMultimodalWithTools(ctx context.Context, req PredictionRequest, tools interface{}, toolChoice string) (PredictionResponse, []types.MessageToolCall, error)
}
```

<a name="PredictionRequest"></a>
## type PredictionRequest

PredictionRequest represents a request to a predict provider

```go
type PredictionRequest struct {
    System      string                 `json:"system"`
    Messages    []types.Message        `json:"messages"`
    Temperature float32                `json:"temperature"`
    TopP        float32                `json:"top_p"`
    MaxTokens   int                    `json:"max_tokens"`
    Seed        *int                   `json:"seed,omitempty"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"` // Optional metadata for provider-specific context
}
```

<a name="PredictionResponse"></a>
## type PredictionResponse

PredictionResponse represents a response from a predict provider

```go
type PredictionResponse struct {
    Content    string                  `json:"content"`
    Parts      []types.ContentPart     `json:"parts,omitempty"`     // Multimodal content parts (text, image, audio, video)
    CostInfo   *types.CostInfo         `json:"cost_info,omitempty"` // Cost breakdown for this response (includes token counts)
    Latency    time.Duration           `json:"latency"`
    Raw        []byte                  `json:"raw,omitempty"`
    RawRequest interface{}             `json:"raw_request,omitempty"` // Raw API request (for debugging)
    ToolCalls  []types.MessageToolCall `json:"tool_calls,omitempty"`  // Tools called in this response
}
```

<a name="Pricing"></a>
## type Pricing

Pricing defines cost per 1K tokens for input and output

```go
type Pricing struct {
    InputCostPer1K  float64
    OutputCostPer1K float64
}
```

<a name="Provider"></a>
## type Provider

Provider interface defines the contract for predict providers

```go
type Provider interface {
    ID() string
    Predict(ctx context.Context, req PredictionRequest) (PredictionResponse, error)

    // Streaming support
    PredictStream(ctx context.Context, req PredictionRequest) (<-chan StreamChunk, error)
    SupportsStreaming() bool

    ShouldIncludeRawOutput() bool
    Close() error // Close cleans up provider resources (e.g., HTTP connections)

    // CalculateCost calculates cost breakdown for given token counts
    CalculateCost(inputTokens, outputTokens, cachedTokens int) types.CostInfo
}
```

<a name="CreateProviderFromSpec"></a>
### func CreateProviderFromSpec

```go
func CreateProviderFromSpec(spec ProviderSpec) (Provider, error)
```

CreateProviderFromSpec creates a provider implementation from a spec. Returns an error if the provider type is unsupported.

<a name="ProviderDefaults"></a>
## type ProviderDefaults

ProviderDefaults holds default parameters for providers

```go
type ProviderDefaults struct {
    Temperature float32
    TopP        float32
    MaxTokens   int
    Pricing     Pricing
}
```

<a name="ProviderFactory"></a>
## type ProviderFactory

ProviderFactory is a function that creates a provider from a spec

```go
type ProviderFactory func(spec ProviderSpec) (Provider, error)
```

<a name="ProviderSpec"></a>
## type ProviderSpec

ProviderSpec holds the configuration needed to create a provider instance

```go
type ProviderSpec struct {
    ID               string
    Type             string
    Model            string
    BaseURL          string
    Defaults         ProviderDefaults
    IncludeRawOutput bool
    AdditionalConfig map[string]interface{} // Flexible key-value pairs for provider-specific configuration
}
```

<a name="Registry"></a>
## type Registry

Registry manages available providers

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new provider registry

<a name="Registry.Close"></a>
### func \(\*Registry\) Close

```go
func (r *Registry) Close() error
```

Close closes all registered providers and cleans up their resources. Returns the first error encountered, if any.

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(id string) (Provider, bool)
```

Get retrieves a provider by ID, returning the provider and a boolean indicating if it was found.

<a name="Registry.List"></a>
### func \(\*Registry\) List

```go
func (r *Registry) List() []string
```

List returns all registered provider IDs

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(provider Provider)
```

Register adds a provider to the registry using its ID as the key.

<a name="SSEScanner"></a>
## type SSEScanner

SSEScanner scans Server\-Sent Events \(SSE\) streams

```go
type SSEScanner struct {
    // contains filtered or unexported fields
}
```

<a name="NewSSEScanner"></a>
### func NewSSEScanner

```go
func NewSSEScanner(r io.Reader) *SSEScanner
```

NewSSEScanner creates a new SSE scanner

<a name="SSEScanner.Data"></a>
### func \(\*SSEScanner\) Data

```go
func (s *SSEScanner) Data() string
```

Data returns the current event data

<a name="SSEScanner.Err"></a>
### func \(\*SSEScanner\) Err

```go
func (s *SSEScanner) Err() error
```

Err returns any scanning error

<a name="SSEScanner.Scan"></a>
### func \(\*SSEScanner\) Scan

```go
func (s *SSEScanner) Scan() bool
```

Scan advances to the next SSE event

<a name="StreamChunk"></a>
## type StreamChunk

StreamChunk represents a batch of tokens with metadata

```go
type StreamChunk struct {
    // Content is the accumulated content so far
    Content string `json:"content"`

    // Delta is the new content in this chunk
    Delta string `json:"delta"`

    // MediaDelta contains new media content in this chunk (audio, video, images)
    // Uses the same MediaContent type as non-streaming messages for API consistency.
    MediaDelta *types.MediaContent `json:"media_delta,omitempty"`

    // TokenCount is the total number of tokens so far
    TokenCount int `json:"token_count"`

    // DeltaTokens is the number of tokens in this delta
    DeltaTokens int `json:"delta_tokens"`

    // ToolCalls contains accumulated tool calls (for assistant messages that invoke tools)
    ToolCalls []types.MessageToolCall `json:"tool_calls,omitempty"`

    // FinishReason is nil until stream is complete
    // Values: "stop", "length", "content_filter", "tool_calls", "error", "validation_failed", "cancelled"
    FinishReason *string `json:"finish_reason,omitempty"`

    // Error is set if an error occurred during streaming
    Error error `json:"error,omitempty"`

    // Metadata contains provider-specific metadata
    Metadata map[string]interface{} `json:"metadata,omitempty"`

    // FinalResult contains the complete execution result (only set in the final chunk)
    FinalResult ExecutionResult `json:"final_result,omitempty"`

    // CostInfo contains cost breakdown (only present in final chunk when FinishReason != nil)
    CostInfo *types.CostInfo `json:"cost_info,omitempty"`
}
```

<a name="StreamEvent"></a>
## type StreamEvent

StreamEvent is sent to observers for monitoring

```go
type StreamEvent struct {
    // Type is the event type: "chunk", "complete", "error"
    Type string `json:"type"`

    // Chunk contains the stream chunk data
    Chunk *StreamChunk `json:"chunk,omitempty"`

    // Error is set for error events
    Error error `json:"error,omitempty"`

    // Timestamp is when the event occurred
    Timestamp time.Time `json:"timestamp"`
}
```

<a name="StreamInputRequest"></a>
## type StreamInputRequest

StreamInputRequest configures a new streaming input session.

```go
type StreamInputRequest struct {
    // Config specifies the media streaming configuration
    Config types.StreamingMediaConfig `json:"config"`

    // SystemMsg is the system message for the conversation
    SystemMsg string `json:"system_msg,omitempty"`

    // InitialText is optional text to send before streaming starts
    // This can be used to provide initial context or instructions
    InitialText string `json:"initial_text,omitempty"`

    // Temperature controls randomness in responses (0.0 to 2.0)
    Temperature float32 `json:"temperature,omitempty"`

    // MaxTokens limits the response length
    MaxTokens int `json:"max_tokens,omitempty"`

    // Metadata contains provider-specific configuration
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

<a name="StreamInputRequest.Validate"></a>
### func \(\*StreamInputRequest\) Validate

```go
func (r *StreamInputRequest) Validate() error
```

Validate checks if the StreamInputRequest is valid

<a name="StreamInputSession"></a>
## type StreamInputSession

StreamInputSession manages a bidirectional streaming session with a provider. The session allows sending media chunks \(e.g., audio from a microphone\) and receiving streaming responses from the LLM.

Example usage:

```
session, err := provider.CreateStreamSession(ctx, StreamInputRequest{
    Config: types.StreamingMediaConfig{
        Type:       types.ContentTypeAudio,
        ChunkSize:  8192,
        SampleRate: 16000,
        Encoding:   "pcm",
        Channels:   1,
    },
    SystemMsg: "You are a helpful voice assistant",
})
if err != nil {
    return err
}
defer session.Close()

// Send audio chunks in a goroutine
go func() {
    for chunk := range micInput {
        if err := session.SendChunk(ctx, chunk); err != nil {
            log.Printf("send error: %v", err)
            break
        }
    }
}()

// Receive responses
for chunk := range session.Response() {
    if chunk.Error != nil {
        log.Printf("response error: %v", chunk.Error)
        break
    }
    fmt.Print(chunk.Delta)
}
```

```go
type StreamInputSession interface {
    // SendChunk sends a media chunk to the provider.
    // Returns an error if the chunk cannot be sent or the session is closed.
    // This method is safe to call from multiple goroutines.
    SendChunk(ctx context.Context, chunk *types.MediaChunk) error

    // SendText sends a text message to the provider during the streaming session.
    // This is useful for sending text prompts or instructions during audio streaming.
    SendText(ctx context.Context, text string) error

    // Response returns a receive-only channel for streaming responses.
    // The channel is closed when the session ends or encounters an error.
    // Consumers should read from this channel in a separate goroutine.
    Response() <-chan StreamChunk

    // Close ends the streaming session and releases resources.
    // After calling Close, SendChunk and SendText will return errors.
    // The Response channel will be closed.
    // Close is safe to call multiple times.
    Close() error

    // Error returns any error that occurred during the session.
    // Returns nil if no error has occurred.
    Error() error

    // Done returns a channel that's closed when the session ends.
    // This is useful for select statements to detect session completion.
    Done() <-chan struct{}
}
```

<a name="StreamInputSupport"></a>
## type StreamInputSupport

StreamInputSupport extends the Provider interface for bidirectional streaming. Providers that implement this interface can handle streaming media input \(e.g., real\-time audio\) and provide streaming responses.

```go
type StreamInputSupport interface {
    Provider // Extends the base Provider interface

    // CreateStreamSession creates a new bidirectional streaming session.
    // The session remains active until Close() is called or an error occurs.
    // Returns an error if the provider doesn't support the requested media type.
    CreateStreamSession(ctx context.Context, req *StreamInputRequest) (StreamInputSession, error)

    // SupportsStreamInput returns the media types supported for streaming input.
    // Common values: types.ContentTypeAudio, types.ContentTypeVideo
    SupportsStreamInput() []string

    // GetStreamingCapabilities returns detailed information about streaming support.
    // This includes supported codecs, sample rates, and other constraints.
    GetStreamingCapabilities() StreamingCapabilities
}
```

<a name="StreamObserver"></a>
## type StreamObserver

StreamObserver receives stream events for monitoring

```go
type StreamObserver interface {
    OnChunk(chunk StreamChunk)
    OnComplete(totalTokens int, duration time.Duration)
    OnError(err error)
}
```

<a name="StreamingCapabilities"></a>
## type StreamingCapabilities

StreamingCapabilities describes what streaming features a provider supports.

```go
type StreamingCapabilities struct {
    // SupportedMediaTypes lists the media types that can be streamed
    // Values: types.ContentTypeAudio, types.ContentTypeVideo
    SupportedMediaTypes []string `json:"supported_media_types"`

    // Audio capabilities
    Audio *AudioStreamingCapabilities `json:"audio,omitempty"`

    // Video capabilities
    Video *VideoStreamingCapabilities `json:"video,omitempty"`

    // BidirectionalSupport indicates if the provider supports full bidirectional streaming
    BidirectionalSupport bool `json:"bidirectional_support"`

    // MaxSessionDuration is the maximum duration for a streaming session (in seconds)
    // Zero means no limit
    MaxSessionDuration int `json:"max_session_duration,omitempty"`

    // MinChunkSize is the minimum chunk size in bytes
    MinChunkSize int `json:"min_chunk_size,omitempty"`

    // MaxChunkSize is the maximum chunk size in bytes
    MaxChunkSize int `json:"max_chunk_size,omitempty"`
}
```

<a name="ToolDescriptor"></a>
## type ToolDescriptor

ToolDescriptor represents a tool that can be used by providers

```go
type ToolDescriptor struct {
    Name         string          `json:"name"`
    Description  string          `json:"description"`
    InputSchema  json.RawMessage `json:"input_schema"`
    OutputSchema json.RawMessage `json:"output_schema"`
}
```

<a name="ToolResult"></a>
## type ToolResult

ToolResult represents the result of a tool execution This is an alias to types.MessageToolResult for provider\-specific context

```go
type ToolResult = types.MessageToolResult
```

<a name="ToolSupport"></a>
## type ToolSupport

ToolSupport interface for providers that support tool/function calling

```go
type ToolSupport interface {
    Provider // Extends the base Provider interface

    // BuildTooling converts tool descriptors to provider-native format
    BuildTooling(descriptors []*ToolDescriptor) (interface{}, error)

    // PredictWithTools performs a predict request with tool support
    PredictWithTools(ctx context.Context, req PredictionRequest, tools interface{}, toolChoice string) (PredictionResponse, []types.MessageToolCall, error)
}
```

<a name="UnsupportedContentError"></a>
## type UnsupportedContentError

UnsupportedContentError is returned when a provider doesn't support certain content types

```go
type UnsupportedContentError struct {
    Provider    string // Provider ID
    ContentType string // "image", "audio", "video", or "multimodal"
    Message     string // Human-readable error message
    PartIndex   int    // Index of the unsupported content part (if applicable)
    MIMEType    string // Specific MIME type that's unsupported (if applicable)
}
```

<a name="UnsupportedContentError.Error"></a>
### func \(\*UnsupportedContentError\) Error

```go
func (e *UnsupportedContentError) Error() string
```



<a name="UnsupportedProviderError"></a>
## type UnsupportedProviderError

UnsupportedProviderError is returned when a provider type is not recognized

```go
type UnsupportedProviderError struct {
    ProviderType string
}
```

<a name="UnsupportedProviderError.Error"></a>
### func \(\*UnsupportedProviderError\) Error

```go
func (e *UnsupportedProviderError) Error() string
```

Error returns the error message for this unsupported provider error.

<a name="ValidationAbortError"></a>
## type ValidationAbortError

ValidationAbortError is returned when a streaming validator aborts a stream

```go
type ValidationAbortError struct {
    Reason string
    Chunk  StreamChunk
}
```

<a name="ValidationAbortError.Error"></a>
### func \(\*ValidationAbortError\) Error

```go
func (e *ValidationAbortError) Error() string
```

Error returns the error message for this validation abort error.

<a name="VideoResolution"></a>
## type VideoResolution

VideoResolution represents a video resolution.

```go
type VideoResolution struct {
    Width  int `json:"width"`
    Height int `json:"height"`
}
```

<a name="VideoResolution.String"></a>
### func \(VideoResolution\) String

```go
func (r VideoResolution) String() string
```

String returns a string representation of the resolution \(e.g., "1920x1080"\)

<a name="VideoStreamingCapabilities"></a>
## type VideoStreamingCapabilities

VideoStreamingCapabilities describes video streaming support.

```go
type VideoStreamingCapabilities struct {
    // SupportedEncodings lists supported video encodings
    // Common values: "h264", "vp8", "vp9", "av1"
    SupportedEncodings []string `json:"supported_encodings"`

    // SupportedResolutions lists supported resolutions (width x height)
    SupportedResolutions []VideoResolution `json:"supported_resolutions"`

    // SupportedFrameRates lists supported frame rates
    // Common values: 15, 24, 30, 60
    SupportedFrameRates []int `json:"supported_frame_rates"`

    // PreferredEncoding is the recommended encoding
    PreferredEncoding string `json:"preferred_encoding"`

    // PreferredResolution is the recommended resolution
    PreferredResolution VideoResolution `json:"preferred_resolution"`

    // PreferredFrameRate is the recommended frame rate
    PreferredFrameRate int `json:"preferred_frame_rate"`
}
```

# statestore

```go
import "github.com/AltairaLabs/PromptKit/runtime/statestore"
```

## Index

- [Variables](<#variables>)
- [type ConversationState](<#ConversationState>)
- [type ListOptions](<#ListOptions>)
- [type MemoryStore](<#MemoryStore>)
  - [func NewMemoryStore\(\) \*MemoryStore](<#NewMemoryStore>)
  - [func \(s \*MemoryStore\) Delete\(ctx context.Context, id string\) error](<#MemoryStore.Delete>)
  - [func \(s \*MemoryStore\) List\(ctx context.Context, opts ListOptions\) \(\[\]string, error\)](<#MemoryStore.List>)
  - [func \(s \*MemoryStore\) Load\(ctx context.Context, id string\) \(\*ConversationState, error\)](<#MemoryStore.Load>)
  - [func \(s \*MemoryStore\) Save\(ctx context.Context, state \*ConversationState\) error](<#MemoryStore.Save>)
- [type RedisOption](<#RedisOption>)
  - [func WithPrefix\(prefix string\) RedisOption](<#WithPrefix>)
  - [func WithTTL\(ttl time.Duration\) RedisOption](<#WithTTL>)
- [type RedisStore](<#RedisStore>)
  - [func NewRedisStore\(client \*redis.Client, opts ...RedisOption\) \*RedisStore](<#NewRedisStore>)
  - [func \(s \*RedisStore\) Delete\(ctx context.Context, id string\) error](<#RedisStore.Delete>)
  - [func \(s \*RedisStore\) List\(ctx context.Context, opts ListOptions\) \(\[\]string, error\)](<#RedisStore.List>)
  - [func \(s \*RedisStore\) Load\(ctx context.Context, id string\) \(\*ConversationState, error\)](<#RedisStore.Load>)
  - [func \(s \*RedisStore\) Save\(ctx context.Context, state \*ConversationState\) error](<#RedisStore.Save>)
- [type Store](<#Store>)
- [type Summary](<#Summary>)


## Variables

<a name="ErrInvalidID"></a>ErrInvalidID is returned when an invalid conversation ID is provided.

```go
var ErrInvalidID = errors.New("invalid conversation ID")
```

<a name="ErrInvalidState"></a>ErrInvalidState is returned when a conversation state is invalid.

```go
var ErrInvalidState = errors.New("invalid conversation state")
```

<a name="ErrNotFound"></a>ErrNotFound is returned when a conversation doesn't exist in the store.

```go
var ErrNotFound = errors.New("conversation not found")
```

<a name="ConversationState"></a>
## type ConversationState

ConversationState represents stored conversation state in the state store. This is the primary data structure for persisting and loading conversation history.

```go
type ConversationState struct {
    ID             string                 // Unique conversation identifier
    UserID         string                 // User who owns this conversation
    Messages       []types.Message        // Message history (using unified types.Message)
    SystemPrompt   string                 // System prompt for this conversation
    Summaries      []Summary              // Compressed summaries of old turns
    TokenCount     int                    // Total tokens in messages
    LastAccessedAt time.Time              // Last time conversation was accessed
    Metadata       map[string]interface{} // Arbitrary metadata (e.g., extracted context)
}
```

<a name="ListOptions"></a>
## type ListOptions

ListOptions provides filtering and pagination options for listing conversations.

```go
type ListOptions struct {
    // UserID filters conversations by the user who owns them.
    // If empty, all conversations are returned (subject to pagination).
    UserID string

    // Limit is the maximum number of conversation IDs to return.
    // If 0, a default limit (e.g., 100) should be applied.
    Limit int

    // Offset is the number of conversations to skip (for pagination).
    Offset int

    // SortBy specifies the field to sort by (e.g., "created_at", "updated_at").
    // If empty, implementation-specific default sorting is used.
    SortBy string

    // SortOrder specifies sort direction: "asc" or "desc".
    // If empty, defaults to "desc" (newest first).
    SortOrder string
}
```

<a name="MemoryStore"></a>
## type MemoryStore

MemoryStore provides an in\-memory implementation of the Store interface. It is thread\-safe and suitable for development, testing, and single\-instance deployments. For distributed systems, use RedisStore or a database\-backed implementation.

```go
type MemoryStore struct {
    // contains filtered or unexported fields
}
```

<a name="NewMemoryStore"></a>
### func NewMemoryStore

```go
func NewMemoryStore() *MemoryStore
```

NewMemoryStore creates a new in\-memory state store.

<a name="MemoryStore.Delete"></a>
### func \(\*MemoryStore\) Delete

```go
func (s *MemoryStore) Delete(ctx context.Context, id string) error
```

Delete removes a conversation state by ID.

<a name="MemoryStore.List"></a>
### func \(\*MemoryStore\) List

```go
func (s *MemoryStore) List(ctx context.Context, opts ListOptions) ([]string, error)
```

List returns conversation IDs matching the given criteria.

<a name="MemoryStore.Load"></a>
### func \(\*MemoryStore\) Load

```go
func (s *MemoryStore) Load(ctx context.Context, id string) (*ConversationState, error)
```

Load retrieves a conversation state by ID. Returns a deep copy to prevent external mutations.

<a name="MemoryStore.Save"></a>
### func \(\*MemoryStore\) Save

```go
func (s *MemoryStore) Save(ctx context.Context, state *ConversationState) error
```

Save persists a conversation state. If it already exists, it will be updated.

<a name="RedisOption"></a>
## type RedisOption

RedisOption configures a RedisStore.

```go
type RedisOption func(*RedisStore)
```

<a name="WithPrefix"></a>
### func WithPrefix

```go
func WithPrefix(prefix string) RedisOption
```

WithPrefix sets the key prefix for Redis keys. Default is "promptkit".

<a name="WithTTL"></a>
### func WithTTL

```go
func WithTTL(ttl time.Duration) RedisOption
```

WithTTL sets the time\-to\-live for conversation states. After this duration, conversations will be automatically deleted. Default is 24 hours. Set to 0 for no expiration.

<a name="RedisStore"></a>
## type RedisStore

RedisStore provides a Redis\-backed implementation of the Store interface. It uses JSON serialization for state storage and supports automatic TTL\-based cleanup. This implementation is suitable for distributed systems and production deployments.

```go
type RedisStore struct {
    // contains filtered or unexported fields
}
```

<a name="NewRedisStore"></a>
### func NewRedisStore

```go
func NewRedisStore(client *redis.Client, opts ...RedisOption) *RedisStore
```

NewRedisStore creates a new Redis\-backed state store.

Example:

```
store := NewRedisStore(
    redis.NewClient(&redis.Options{Addr: "localhost:6379"}),
    WithTTL(24 * time.Hour),
    WithPrefix("myapp"),
)
```

<a name="RedisStore.Delete"></a>
### func \(\*RedisStore\) Delete

```go
func (s *RedisStore) Delete(ctx context.Context, id string) error
```

Delete removes a conversation state from Redis.

<a name="RedisStore.List"></a>
### func \(\*RedisStore\) List

```go
func (s *RedisStore) List(ctx context.Context, opts ListOptions) ([]string, error)
```

List returns conversation IDs matching the given criteria.

<a name="RedisStore.Load"></a>
### func \(\*RedisStore\) Load

```go
func (s *RedisStore) Load(ctx context.Context, id string) (*ConversationState, error)
```

Load retrieves a conversation state by ID from Redis.

<a name="RedisStore.Save"></a>
### func \(\*RedisStore\) Save

```go
func (s *RedisStore) Save(ctx context.Context, state *ConversationState) error
```

Save persists a conversation state to Redis with TTL.

<a name="Store"></a>
## type Store

Store defines the interface for persistent conversation state storage.

```go
type Store interface {
    // Load retrieves conversation state by ID
    Load(ctx context.Context, id string) (*ConversationState, error)

    // Save persists conversation state
    Save(ctx context.Context, state *ConversationState) error
}
```

<a name="Summary"></a>
## type Summary

Summary represents a compressed version of conversation turns. Used to maintain context while reducing token count for older conversations.

```go
type Summary struct {
    StartTurn  int       // First turn included in this summary
    EndTurn    int       // Last turn included in this summary
    Content    string    // Summarized content
    TokenCount int       // Token count of the summary
    CreatedAt  time.Time // When this summary was created
}
```

# template

```go
import "github.com/AltairaLabs/PromptKit/runtime/template"
```

Package template provides template rendering and variable substitution.

This package implements a flexible template system that can be used by both prompts and personas. It supports:

- Variable substitution with \{\{variable\}\} syntax
- Recursive template resolution \(variables can contain other variables\)
- Validation of required variables
- Detection of unresolved placeholders

Future versions may support more advanced templating engines like Go templates \(similar to Helm charts\) for conditional logic, loops, and functions.

## Index

- [func GetUsedVars\(vars map\[string\]string\) \[\]string](<#GetUsedVars>)
- [type Renderer](<#Renderer>)
  - [func NewRenderer\(\) \*Renderer](<#NewRenderer>)
  - [func \(r \*Renderer\) MergeVars\(varMaps ...map\[string\]string\) map\[string\]string](<#Renderer.MergeVars>)
  - [func \(r \*Renderer\) Render\(templateText string, vars map\[string\]string\) \(string, error\)](<#Renderer.Render>)
  - [func \(r \*Renderer\) ValidateRequiredVars\(requiredVars \[\]string, vars map\[string\]string\) error](<#Renderer.ValidateRequiredVars>)


<a name="GetUsedVars"></a>
## func GetUsedVars

```go
func GetUsedVars(vars map[string]string) []string
```

GetUsedVars returns a list of variable names that had non\-empty values. This is useful for debugging and logging which variables were actually used.

<a name="Renderer"></a>
## type Renderer

Renderer handles variable substitution in templates

```go
type Renderer struct {
}
```

<a name="NewRenderer"></a>
### func NewRenderer

```go
func NewRenderer() *Renderer
```

NewRenderer creates a new template renderer

<a name="Renderer.MergeVars"></a>
### func \(\*Renderer\) MergeVars

```go
func (r *Renderer) MergeVars(varMaps ...map[string]string) map[string]string
```

MergeVars merges multiple variable maps with later maps taking precedence. This is useful for combining default values, context variables, and overrides.

Example:

```
defaults := map[string]string{"color": "blue", "size": "medium"}
overrides := map[string]string{"color": "red"}
result := MergeVars(defaults, overrides)
// result = {"color": "red", "size": "medium"}
```

<a name="Renderer.Render"></a>
### func \(\*Renderer\) Render

```go
func (r *Renderer) Render(templateText string, vars map[string]string) (string, error)
```

Render applies variable substitution to the template with recursive resolution.

The renderer performs multiple passes \(up to maxPasses\) to handle nested variable substitution. For example, if var1="\{\{var2\}\}" and var2="value", the final result will correctly resolve to "value".

Returns an error if any placeholders remain unresolved after all passes.

<a name="Renderer.ValidateRequiredVars"></a>
### func \(\*Renderer\) ValidateRequiredVars

```go
func (r *Renderer) ValidateRequiredVars(requiredVars []string, vars map[string]string) error
```

ValidateRequiredVars checks that all required variables are provided and non\-empty. Returns an error listing any missing variables.

# tools

```go
import "github.com/AltairaLabs/PromptKit/runtime/tools"
```

Package tools provides tool/function calling infrastructure for LLM testing.

This package implements a flexible tool execution system with:

- Tool descriptor registry with JSON Schema validation
- Mock executors for testing \(static and template\-based\)
- HTTP executor for live API calls
- Type coercion and result validation
- Adapter for prompt registry integration

Tools can be loaded from YAML/JSON files and executed with argument validation, result schema checking, and automatic type coercion for common mismatches.

## Index

- [type AsyncToolExecutor](<#AsyncToolExecutor>)
- [type Coercion](<#Coercion>)
- [type Executor](<#Executor>)
- [type FileToolResponseRepository](<#FileToolResponseRepository>)
  - [func NewFileToolResponseRepository\(scenarioID string, toolResponses map\[string\]\[\]MockToolResponseConfig\) \*FileToolResponseRepository](<#NewFileToolResponseRepository>)
  - [func \(r \*FileToolResponseRepository\) GetToolResponse\(toolName string, args map\[string\]interface\{\}, contextKey string\) \(\*ToolResponseData, error\)](<#FileToolResponseRepository.GetToolResponse>)
- [type HTTPConfig](<#HTTPConfig>)
- [type InMemoryToolResponseRepository](<#InMemoryToolResponseRepository>)
  - [func NewInMemoryToolResponseRepository\(\) \*InMemoryToolResponseRepository](<#NewInMemoryToolResponseRepository>)
  - [func \(r \*InMemoryToolResponseRepository\) AddResponse\(contextKey, toolName string, response \*ToolResponseData\)](<#InMemoryToolResponseRepository.AddResponse>)
  - [func \(r \*InMemoryToolResponseRepository\) GetToolResponse\(toolName string, args map\[string\]interface\{\}, contextKey string\) \(\*ToolResponseData, error\)](<#InMemoryToolResponseRepository.GetToolResponse>)
- [type MCPExecutor](<#MCPExecutor>)
  - [func NewMCPExecutor\(registry mcp.Registry\) \*MCPExecutor](<#NewMCPExecutor>)
  - [func \(e \*MCPExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MCPExecutor.Execute>)
  - [func \(e \*MCPExecutor\) Name\(\) string](<#MCPExecutor.Name>)
- [type MockScriptedExecutor](<#MockScriptedExecutor>)
  - [func NewMockScriptedExecutor\(\) \*MockScriptedExecutor](<#NewMockScriptedExecutor>)
  - [func \(e \*MockScriptedExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MockScriptedExecutor.Execute>)
  - [func \(e \*MockScriptedExecutor\) Name\(\) string](<#MockScriptedExecutor.Name>)
- [type MockStaticExecutor](<#MockStaticExecutor>)
  - [func NewMockStaticExecutor\(\) \*MockStaticExecutor](<#NewMockStaticExecutor>)
  - [func \(e \*MockStaticExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#MockStaticExecutor.Execute>)
  - [func \(e \*MockStaticExecutor\) Name\(\) string](<#MockStaticExecutor.Name>)
- [type MockToolErrorConfig](<#MockToolErrorConfig>)
- [type MockToolResponseConfig](<#MockToolResponseConfig>)
- [type PendingToolInfo](<#PendingToolInfo>)
- [type PredictMessage](<#PredictMessage>)
- [type PredictionRequest](<#PredictionRequest>)
- [type PredictionResponse](<#PredictionResponse>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func NewRegistryWithRepository\(repository ToolRepository\) \*Registry](<#NewRegistryWithRepository>)
  - [func \(r \*Registry\) Execute\(toolName string, args json.RawMessage\) \(\*ToolResult, error\)](<#Registry.Execute>)
  - [func \(r \*Registry\) ExecuteAsync\(toolName string, args json.RawMessage\) \(\*ToolExecutionResult, error\)](<#Registry.ExecuteAsync>)
  - [func \(r \*Registry\) Get\(name string\) \*ToolDescriptor](<#Registry.Get>)
  - [func \(r \*Registry\) GetTool\(name string\) \(\*ToolDescriptor, error\)](<#Registry.GetTool>)
  - [func \(r \*Registry\) GetTools\(\) map\[string\]\*ToolDescriptor](<#Registry.GetTools>)
  - [func \(r \*Registry\) GetToolsByNames\(names \[\]string\) \(\[\]\*ToolDescriptor, error\)](<#Registry.GetToolsByNames>)
  - [func \(r \*Registry\) List\(\) \[\]string](<#Registry.List>)
  - [func \(r \*Registry\) LoadToolFromBytes\(filename string, data \[\]byte\) error](<#Registry.LoadToolFromBytes>)
  - [func \(r \*Registry\) LoadToolsFromData\(tools \[\]ToolData\) error](<#Registry.LoadToolsFromData>)
  - [func \(r \*Registry\) Register\(descriptor \*ToolDescriptor\) error](<#Registry.Register>)
  - [func \(r \*Registry\) RegisterExecutor\(executor Executor\)](<#Registry.RegisterExecutor>)
- [type RepositoryToolExecutor](<#RepositoryToolExecutor>)
  - [func NewRepositoryToolExecutor\(baseExecutor Executor, repo ToolResponseRepository, contextKey string\) \*RepositoryToolExecutor](<#NewRepositoryToolExecutor>)
  - [func \(e \*RepositoryToolExecutor\) Execute\(descriptor \*ToolDescriptor, args json.RawMessage\) \(json.RawMessage, error\)](<#RepositoryToolExecutor.Execute>)
  - [func \(e \*RepositoryToolExecutor\) Name\(\) string](<#RepositoryToolExecutor.Name>)
- [type SchemaValidator](<#SchemaValidator>)
  - [func NewSchemaValidator\(\) \*SchemaValidator](<#NewSchemaValidator>)
  - [func \(sv \*SchemaValidator\) CoerceResult\(descriptor \*ToolDescriptor, result json.RawMessage\) \(json.RawMessage, \[\]Coercion, error\)](<#SchemaValidator.CoerceResult>)
  - [func \(sv \*SchemaValidator\) ValidateArgs\(descriptor \*ToolDescriptor, args json.RawMessage\) error](<#SchemaValidator.ValidateArgs>)
  - [func \(sv \*SchemaValidator\) ValidateResult\(descriptor \*ToolDescriptor, result json.RawMessage\) error](<#SchemaValidator.ValidateResult>)
- [type ToolCall](<#ToolCall>)
- [type ToolConfig](<#ToolConfig>)
- [type ToolData](<#ToolData>)
- [type ToolDescriptor](<#ToolDescriptor>)
- [type ToolErrorData](<#ToolErrorData>)
- [type ToolExecutionResult](<#ToolExecutionResult>)
- [type ToolExecutionStatus](<#ToolExecutionStatus>)
- [type ToolGuidance](<#ToolGuidance>)
- [type ToolPolicy](<#ToolPolicy>)
- [type ToolRepository](<#ToolRepository>)
- [type ToolResponseData](<#ToolResponseData>)
- [type ToolResponseRepository](<#ToolResponseRepository>)
- [type ToolResult](<#ToolResult>)
- [type ToolStats](<#ToolStats>)
- [type ValidationError](<#ValidationError>)
  - [func \(e \*ValidationError\) Error\(\) string](<#ValidationError.Error>)


<a name="AsyncToolExecutor"></a>
## type AsyncToolExecutor

AsyncToolExecutor is a tool that can return pending status instead of blocking. Tools that require human approval or external async operations should implement this.

```go
type AsyncToolExecutor interface {
    Executor // Still implements the basic Executor interface

    // ExecuteAsync may return immediately with a pending status
    ExecuteAsync(descriptor *ToolDescriptor, args json.RawMessage) (*ToolExecutionResult, error)
}
```

<a name="Coercion"></a>
## type Coercion

Coercion represents a type coercion that was performed

```go
type Coercion struct {
    Path string      `json:"path"`
    From interface{} `json:"from"`
    To   interface{} `json:"to"`
}
```

<a name="Executor"></a>
## type Executor

Executor interface defines how tools are executed

```go
type Executor interface {
    Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
    Name() string
}
```

<a name="FileToolResponseRepository"></a>
## type FileToolResponseRepository

FileToolResponseRepository implements ToolResponseRepository using the provider's MockConfig YAML structure. This allows Arena scenarios to define tool responses alongside LLM responses.

```go
type FileToolResponseRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewFileToolResponseRepository"></a>
### func NewFileToolResponseRepository

```go
func NewFileToolResponseRepository(scenarioID string, toolResponses map[string][]MockToolResponseConfig) *FileToolResponseRepository
```

NewFileToolResponseRepository creates a repository from scenario tool responses. This is typically used by Arena to provide tool mocking from YAML scenarios.

<a name="FileToolResponseRepository.GetToolResponse"></a>
### func \(\*FileToolResponseRepository\) GetToolResponse

```go
func (r *FileToolResponseRepository) GetToolResponse(toolName string, args map[string]interface{}, contextKey string) (*ToolResponseData, error)
```

GetToolResponse implements ToolResponseRepository. It finds the first matching response based on argument comparison.

<a name="HTTPConfig"></a>
## type HTTPConfig

HTTPConfig defines configuration for live HTTP tool execution

```go
type HTTPConfig struct {
    URL            string            `json:"url" yaml:"url"`
    Method         string            `json:"method" yaml:"method"`
    HeadersFromEnv []string          `json:"headers_from_env,omitempty" yaml:"headers_from_env,omitempty"`
    TimeoutMs      int               `json:"timeout_ms" yaml:"timeout_ms"`
    Redact         []string          `json:"redact,omitempty" yaml:"redact,omitempty"`
    Headers        map[string]string `json:"headers,omitempty" yaml:"headers,omitempty"`
}
```

<a name="InMemoryToolResponseRepository"></a>
## type InMemoryToolResponseRepository

InMemoryToolResponseRepository implements ToolResponseRepository using in\-memory storage. This is useful for SDK unit tests and programmatic configuration of tool responses.

```go
type InMemoryToolResponseRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewInMemoryToolResponseRepository"></a>
### func NewInMemoryToolResponseRepository

```go
func NewInMemoryToolResponseRepository() *InMemoryToolResponseRepository
```

NewInMemoryToolResponseRepository creates a new in\-memory tool response repository.

<a name="InMemoryToolResponseRepository.AddResponse"></a>
### func \(\*InMemoryToolResponseRepository\) AddResponse

```go
func (r *InMemoryToolResponseRepository) AddResponse(contextKey, toolName string, response *ToolResponseData)
```

AddResponse adds a tool response for a specific context and tool name. This method supports simple responses where argument matching is not needed.

<a name="InMemoryToolResponseRepository.GetToolResponse"></a>
### func \(\*InMemoryToolResponseRepository\) GetToolResponse

```go
func (r *InMemoryToolResponseRepository) GetToolResponse(toolName string, args map[string]interface{}, contextKey string) (*ToolResponseData, error)
```

GetToolResponse implements ToolResponseRepository. For simplicity, this implementation only matches by tool name and context, not by arguments. For argument\-based matching, use FileToolResponseRepository or implement a custom repository.

<a name="MCPExecutor"></a>
## type MCPExecutor

MCPExecutor executes tools using MCP \(Model Context Protocol\) servers

```go
type MCPExecutor struct {
    // contains filtered or unexported fields
}
```

<a name="NewMCPExecutor"></a>
### func NewMCPExecutor

```go
func NewMCPExecutor(registry mcp.Registry) *MCPExecutor
```

NewMCPExecutor creates a new MCP executor

<a name="MCPExecutor.Execute"></a>
### func \(\*MCPExecutor\) Execute

```go
func (e *MCPExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using an MCP server

<a name="MCPExecutor.Name"></a>
### func \(\*MCPExecutor\) Name

```go
func (e *MCPExecutor) Name() string
```

Name returns the executor name

<a name="MockScriptedExecutor"></a>
## type MockScriptedExecutor

MockScriptedExecutor executes tools using templated mock data

```go
type MockScriptedExecutor struct{}
```

<a name="NewMockScriptedExecutor"></a>
### func NewMockScriptedExecutor

```go
func NewMockScriptedExecutor() *MockScriptedExecutor
```

NewMockScriptedExecutor creates a new scripted mock executor

<a name="MockScriptedExecutor.Execute"></a>
### func \(\*MockScriptedExecutor\) Execute

```go
func (e *MockScriptedExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using templated mock data

<a name="MockScriptedExecutor.Name"></a>
### func \(\*MockScriptedExecutor\) Name

```go
func (e *MockScriptedExecutor) Name() string
```

Name returns the executor name

<a name="MockStaticExecutor"></a>
## type MockStaticExecutor

MockStaticExecutor executes tools using static mock data

```go
type MockStaticExecutor struct{}
```

<a name="NewMockStaticExecutor"></a>
### func NewMockStaticExecutor

```go
func NewMockStaticExecutor() *MockStaticExecutor
```

NewMockStaticExecutor creates a new static mock executor

<a name="MockStaticExecutor.Execute"></a>
### func \(\*MockStaticExecutor\) Execute

```go
func (e *MockStaticExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool using static mock data

<a name="MockStaticExecutor.Name"></a>
### func \(\*MockStaticExecutor\) Name

```go
func (e *MockStaticExecutor) Name() string
```

Name returns the executor name

<a name="MockToolErrorConfig"></a>
## type MockToolErrorConfig

MockToolErrorConfig represents an error configuration.

```go
type MockToolErrorConfig struct {
    Type    string `yaml:"type"`
    Message string `yaml:"message"`
}
```

<a name="MockToolResponseConfig"></a>
## type MockToolResponseConfig

MockToolResponseConfig represents a single tool response configuration.

```go
type MockToolResponseConfig struct {
    CallArgs map[string]interface{} `yaml:"call_args"`
    Result   interface{}            `yaml:"result,omitempty"`
    Error    *MockToolErrorConfig   `yaml:"error,omitempty"`
}
```

<a name="PendingToolInfo"></a>
## type PendingToolInfo

PendingToolInfo provides context for middleware \(email templates, notifications\)

```go
type PendingToolInfo struct {
    // Reason for pending (e.g., "requires_approval", "waiting_external_api")
    Reason string `json:"reason"`

    // Human-readable description
    Message string `json:"message"`

    // Tool details (for middleware to use in notifications)
    ToolName string          `json:"tool_name"`
    Args     json.RawMessage `json:"args"`

    // Optional: expiration, callback URL, etc.
    ExpiresAt   *time.Time `json:"expires_at,omitempty"`
    CallbackURL string     `json:"callback_url,omitempty"`

    // Arbitrary metadata for custom middleware
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

<a name="PredictMessage"></a>
## type PredictMessage

PredictMessage represents a predict message \(simplified version for tool context\)

```go
type PredictMessage struct {
    Role               string     `json:"role"`
    Content            string     `json:"content"`
    ToolCalls          []ToolCall `json:"tool_calls,omitempty"`
    ToolCallResponseID string     `json:"tool_call_id,omitempty"` // For tool result messages
}
```

<a name="PredictionRequest"></a>
## type PredictionRequest

PredictionRequest represents a predict request \(extending existing type\)

```go
type PredictionRequest struct {
    System      string           `json:"system"`
    Messages    []PredictMessage `json:"messages"`
    Temperature float32          `json:"temperature"`
    TopP        float32          `json:"top_p"`
    MaxTokens   int              `json:"max_tokens"`
    Seed        *int             `json:"seed,omitempty"`
}
```

<a name="PredictionResponse"></a>
## type PredictionResponse

PredictionResponse represents a predict response \(extending existing type\)

```go
type PredictionResponse struct {
    Content   string        `json:"content"`
    TokensIn  int           `json:"tokens_in"`
    TokensOut int           `json:"tokens_out"`
    Latency   time.Duration `json:"latency"`
    Raw       []byte        `json:"raw,omitempty"`
    ToolCalls []ToolCall    `json:"tool_calls,omitempty"` // Tools called in this response
}
```

<a name="Registry"></a>
## type Registry

Registry manages tool descriptors and provides access to executors

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new tool registry without a repository backend \(legacy mode\)

<a name="NewRegistryWithRepository"></a>
### func NewRegistryWithRepository

```go
func NewRegistryWithRepository(repository ToolRepository) *Registry
```

NewRegistryWithRepository creates a new tool registry with a repository backend

<a name="Registry.Execute"></a>
### func \(\*Registry\) Execute

```go
func (r *Registry) Execute(toolName string, args json.RawMessage) (*ToolResult, error)
```

Execute executes a tool with the given arguments

<a name="Registry.ExecuteAsync"></a>
### func \(\*Registry\) ExecuteAsync

```go
func (r *Registry) ExecuteAsync(toolName string, args json.RawMessage) (*ToolExecutionResult, error)
```

ExecuteAsync executes a tool with async support, checking if it implements AsyncToolExecutor. Returns ToolExecutionResult with status \(complete/pending/failed\).

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(name string) *ToolDescriptor
```

Get retrieves a tool descriptor by name with repository fallback

<a name="Registry.GetTool"></a>
### func \(\*Registry\) GetTool

```go
func (r *Registry) GetTool(name string) (*ToolDescriptor, error)
```

GetTool retrieves a tool descriptor by name

<a name="Registry.GetTools"></a>
### func \(\*Registry\) GetTools

```go
func (r *Registry) GetTools() map[string]*ToolDescriptor
```

GetTools returns all loaded tool descriptors

<a name="Registry.GetToolsByNames"></a>
### func \(\*Registry\) GetToolsByNames

```go
func (r *Registry) GetToolsByNames(names []string) ([]*ToolDescriptor, error)
```

GetToolsByNames returns tool descriptors for the specified names

<a name="Registry.List"></a>
### func \(\*Registry\) List

```go
func (r *Registry) List() []string
```

List returns all tool names from repository or cache

<a name="Registry.LoadToolFromBytes"></a>
### func \(\*Registry\) LoadToolFromBytes

```go
func (r *Registry) LoadToolFromBytes(filename string, data []byte) error
```

LoadToolFromBytes loads a tool descriptor from raw bytes data. This is useful when tool data has already been read from a file or received from another source, avoiding redundant file I/O. The filename parameter is used only for error reporting.

<a name="Registry.LoadToolsFromData"></a>
### func \(\*Registry\) LoadToolsFromData

```go
func (r *Registry) LoadToolsFromData(tools []ToolData) error
```

LoadToolsFromData loads tool descriptors from a slice of ToolData. Returns error if any tool fails to load.

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(descriptor *ToolDescriptor) error
```

Register adds a tool descriptor to the registry with validation

<a name="Registry.RegisterExecutor"></a>
### func \(\*Registry\) RegisterExecutor

```go
func (r *Registry) RegisterExecutor(executor Executor)
```

RegisterExecutor registers a tool executor

<a name="RepositoryToolExecutor"></a>
## type RepositoryToolExecutor

RepositoryToolExecutor wraps existing tool executors to provide repository\-backed mock responses with fallback to real execution. This enables deterministic tool testing while maintaining the ability to fall back to real tool execution when needed.

```go
type RepositoryToolExecutor struct {
    // contains filtered or unexported fields
}
```

<a name="NewRepositoryToolExecutor"></a>
### func NewRepositoryToolExecutor

```go
func NewRepositoryToolExecutor(baseExecutor Executor, repo ToolResponseRepository, contextKey string) *RepositoryToolExecutor
```

NewRepositoryToolExecutor creates a new repository\-backed tool executor. The executor will first check the repository for configured responses, and fall back to the base executor if no match is found.

<a name="RepositoryToolExecutor.Execute"></a>
### func \(\*RepositoryToolExecutor\) Execute

```go
func (e *RepositoryToolExecutor) Execute(descriptor *ToolDescriptor, args json.RawMessage) (json.RawMessage, error)
```

Execute executes a tool, first checking the repository for mock responses. If a matching response is found in the repository, it returns that response. Otherwise, it falls back to the base executor for real execution.

<a name="RepositoryToolExecutor.Name"></a>
### func \(\*RepositoryToolExecutor\) Name

```go
func (e *RepositoryToolExecutor) Name() string
```

Name returns the executor name with repository suffix.

<a name="SchemaValidator"></a>
## type SchemaValidator

SchemaValidator handles JSON schema validation for tool inputs and outputs

```go
type SchemaValidator struct {
    // contains filtered or unexported fields
}
```

<a name="NewSchemaValidator"></a>
### func NewSchemaValidator

```go
func NewSchemaValidator() *SchemaValidator
```

NewSchemaValidator creates a new schema validator

<a name="SchemaValidator.CoerceResult"></a>
### func \(\*SchemaValidator\) CoerceResult

```go
func (sv *SchemaValidator) CoerceResult(descriptor *ToolDescriptor, result json.RawMessage) (json.RawMessage, []Coercion, error)
```

CoerceResult attempts to coerce simple type mismatches in tool results

<a name="SchemaValidator.ValidateArgs"></a>
### func \(\*SchemaValidator\) ValidateArgs

```go
func (sv *SchemaValidator) ValidateArgs(descriptor *ToolDescriptor, args json.RawMessage) error
```

ValidateArgs validates tool arguments against the input schema

<a name="SchemaValidator.ValidateResult"></a>
### func \(\*SchemaValidator\) ValidateResult

```go
func (sv *SchemaValidator) ValidateResult(descriptor *ToolDescriptor, result json.RawMessage) error
```

ValidateResult validates tool result against the output schema

<a name="ToolCall"></a>
## type ToolCall

ToolCall represents a tool invocation request

```go
type ToolCall struct {
    Name string          `json:"name"`
    Args json.RawMessage `json:"args"`
    ID   string          `json:"id"` // Provider-specific call ID
}
```

<a name="ToolConfig"></a>
## type ToolConfig

ToolConfig represents a K8s\-style tool configuration manifest

```go
type ToolConfig struct {
    APIVersion string            `yaml:"apiVersion"`
    Kind       string            `yaml:"kind"`
    Metadata   metav1.ObjectMeta `yaml:"metadata,omitempty"`
    Spec       ToolDescriptor    `yaml:"spec"`
}
```

<a name="ToolData"></a>
## type ToolData

ToolData holds raw tool configuration data with file path

```go
type ToolData struct {
    FilePath string
    Data     []byte
}
```

<a name="ToolDescriptor"></a>
## type ToolDescriptor

ToolDescriptor represents a normalized tool definition

```go
type ToolDescriptor struct {
    Name         string          `json:"name" yaml:"name"`
    Description  string          `json:"description" yaml:"description"`
    InputSchema  json.RawMessage `json:"input_schema" yaml:"input_schema"`   // JSON Schema Draft-07
    OutputSchema json.RawMessage `json:"output_schema" yaml:"output_schema"` // JSON Schema Draft-07
    Mode         string          `json:"mode" yaml:"mode"`                   // "mock" | "live"
    TimeoutMs    int             `json:"timeout_ms" yaml:"timeout_ms"`
    MockResult   json.RawMessage `json:"mock_result,omitempty" yaml:"mock_result,omitempty"`     // Static mock data
    MockTemplate string          `json:"mock_template,omitempty" yaml:"mock_template,omitempty"` // Template for dynamic mocks
    HTTPConfig   *HTTPConfig     `json:"http,omitempty" yaml:"http,omitempty"`                   // Live HTTP configuration
}
```

<a name="ToolErrorData"></a>
## type ToolErrorData

ToolErrorData represents an error response for tool execution.

```go
type ToolErrorData struct {
    Type    string `json:"type"`    // Error type/category
    Message string `json:"message"` // Error message
}
```

<a name="ToolExecutionResult"></a>
## type ToolExecutionResult

ToolExecutionResult includes status and optional pending information

```go
type ToolExecutionResult struct {
    Status  ToolExecutionStatus `json:"status"`
    Content json.RawMessage     `json:"content,omitempty"`
    Error   string              `json:"error,omitempty"`

    // Present when Status == ToolStatusPending
    PendingInfo *PendingToolInfo `json:"pending_info,omitempty"`
}
```

<a name="ToolExecutionStatus"></a>
## type ToolExecutionStatus

ToolExecutionStatus represents whether a tool completed or needs external input

```go
type ToolExecutionStatus string
```

<a name="ToolStatusComplete"></a>

```go
const (
    // ToolStatusComplete indicates the tool finished executing
    ToolStatusComplete ToolExecutionStatus = "complete"
    // ToolStatusPending indicates the tool is waiting for external input (e.g., human approval)
    ToolStatusPending ToolExecutionStatus = "pending"
    // ToolStatusFailed indicates the tool execution failed
    ToolStatusFailed ToolExecutionStatus = "failed"
)
```

<a name="ToolGuidance"></a>
## type ToolGuidance

ToolGuidance provides hints for different interaction modes This is a flexible structure that can be extended with task\-specific guidance

```go
type ToolGuidance struct {
    Support   string `json:"support,omitempty"`
    Assistant string `json:"assistant,omitempty"`
    Generic   string `json:"generic,omitempty"`
}
```

<a name="ToolPolicy"></a>
## type ToolPolicy

ToolPolicy defines constraints for tool usage in scenarios

```go
type ToolPolicy struct {
    ToolChoice          string   `json:"tool_choice"` // "auto" | "required" | "none"
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn"`
    MaxTotalToolCalls   int      `json:"max_total_tool_calls"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="ToolRepository"></a>
## type ToolRepository

ToolRepository provides abstract access to tool descriptors \(local interface to avoid import cycles\)

```go
type ToolRepository interface {
    LoadTool(name string) (*ToolDescriptor, error)
    ListTools() ([]string, error)
    SaveTool(descriptor *ToolDescriptor) error
}
```

<a name="ToolResponseData"></a>
## type ToolResponseData

ToolResponseData represents a configured tool response with optional error.

```go
type ToolResponseData struct {
    Result interface{}    `json:"result,omitempty"` // Successful response data
    Error  *ToolErrorData `json:"error,omitempty"`  // Error response
}
```

<a name="ToolResponseRepository"></a>
## type ToolResponseRepository

ToolResponseRepository defines the interface for repositories that can provide mock tool responses based on tool name, arguments, and context.

```go
type ToolResponseRepository interface {
    // GetToolResponse retrieves a mock response for a tool execution.
    // Returns nil if no matching response is configured (not an error).
    GetToolResponse(toolName string, args map[string]interface{}, contextKey string) (*ToolResponseData, error)
}
```

<a name="ToolResult"></a>
## type ToolResult

ToolResult represents the result of a tool execution

```go
type ToolResult struct {
    Name      string          `json:"name"`
    ID        string          `json:"id"` // Matches ToolCall.ID
    Result    json.RawMessage `json:"result"`
    LatencyMs int64           `json:"latency_ms"`
    Error     string          `json:"error,omitempty"`
}
```

<a name="ToolStats"></a>
## type ToolStats

ToolStats tracks tool usage statistics

```go
type ToolStats struct {
    TotalCalls int            `json:"total_calls"`
    ByTool     map[string]int `json:"by_tool"`
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a tool validation failure

```go
type ValidationError struct {
    Type   string `json:"type"` // "args_invalid" | "result_invalid" | "policy_violation"
    Tool   string `json:"tool"`
    Detail string `json:"detail"`
    Path   string `json:"path,omitempty"`
}
```

<a name="ValidationError.Error"></a>
### func \(\*ValidationError\) Error

```go
func (e *ValidationError) Error() string
```

Error implements the error interface

# types

```go
import "github.com/AltairaLabs/PromptKit/runtime/types"
```

## Index

- [Constants](<#constants>)
- [func CountMediaParts\(msg Message\) int](<#CountMediaParts>)
- [func CountPartsByType\(msg Message, contentType string\) int](<#CountPartsByType>)
- [func ExtractTextContent\(msg Message\) string](<#ExtractTextContent>)
- [func HasOnlyTextContent\(msg Message\) bool](<#HasOnlyTextContent>)
- [func MigrateMessagesToLegacy\(messages \[\]Message\) error](<#MigrateMessagesToLegacy>)
- [func MigrateMessagesToMultimodal\(messages \[\]Message\)](<#MigrateMessagesToMultimodal>)
- [func MigrateToLegacy\(msg \*Message\) error](<#MigrateToLegacy>)
- [func MigrateToMultimodal\(msg \*Message\)](<#MigrateToMultimodal>)
- [type ChunkReader](<#ChunkReader>)
  - [func NewChunkReader\(r io.Reader, config StreamingMediaConfig\) \*ChunkReader](<#NewChunkReader>)
  - [func \(cr \*ChunkReader\) NextChunk\(ctx context.Context\) \(\*MediaChunk, error\)](<#ChunkReader.NextChunk>)
- [type ChunkWriter](<#ChunkWriter>)
  - [func NewChunkWriter\(w io.Writer\) \*ChunkWriter](<#NewChunkWriter>)
  - [func \(cw \*ChunkWriter\) Flush\(\) error](<#ChunkWriter.Flush>)
  - [func \(cw \*ChunkWriter\) WriteChunk\(chunk \*MediaChunk\) \(int, error\)](<#ChunkWriter.WriteChunk>)
- [type ContentPart](<#ContentPart>)
  - [func NewAudioPart\(filePath string\) \(ContentPart, error\)](<#NewAudioPart>)
  - [func NewAudioPartFromData\(base64Data string, mimeType string\) ContentPart](<#NewAudioPartFromData>)
  - [func NewImagePart\(filePath string, detail \*string\) \(ContentPart, error\)](<#NewImagePart>)
  - [func NewImagePartFromData\(base64Data string, mimeType string, detail \*string\) ContentPart](<#NewImagePartFromData>)
  - [func NewImagePartFromURL\(url string, detail \*string\) ContentPart](<#NewImagePartFromURL>)
  - [func NewTextPart\(text string\) ContentPart](<#NewTextPart>)
  - [func NewVideoPart\(filePath string\) \(ContentPart, error\)](<#NewVideoPart>)
  - [func NewVideoPartFromData\(base64Data string, mimeType string\) ContentPart](<#NewVideoPartFromData>)
  - [func SplitMultimodalMessage\(msg Message\) \(text string, mediaParts \[\]ContentPart\)](<#SplitMultimodalMessage>)
  - [func \(cp \*ContentPart\) Validate\(\) error](<#ContentPart.Validate>)
- [type CostInfo](<#CostInfo>)
- [type MediaChunk](<#MediaChunk>)
- [type MediaContent](<#MediaContent>)
  - [func \(mc \*MediaContent\) GetBase64Data\(\) \(string, error\)](<#MediaContent.GetBase64Data>)
  - [func \(mc \*MediaContent\) ReadData\(\) \(io.ReadCloser, error\)](<#MediaContent.ReadData>)
  - [func \(mc \*MediaContent\) Validate\(\) error](<#MediaContent.Validate>)
- [type MediaItemSummary](<#MediaItemSummary>)
- [type MediaSummary](<#MediaSummary>)
- [type Message](<#Message>)
  - [func CloneMessage\(msg Message\) Message](<#CloneMessage>)
  - [func CombineTextAndMedia\(role, text string, mediaParts \[\]ContentPart\) Message](<#CombineTextAndMedia>)
  - [func ConvertTextToMultimodal\(role, content string\) Message](<#ConvertTextToMultimodal>)
  - [func \(m \*Message\) AddAudioPart\(filePath string\) error](<#Message.AddAudioPart>)
  - [func \(m \*Message\) AddImagePart\(filePath string, detail \*string\) error](<#Message.AddImagePart>)
  - [func \(m \*Message\) AddImagePartFromURL\(url string, detail \*string\)](<#Message.AddImagePartFromURL>)
  - [func \(m \*Message\) AddPart\(part ContentPart\)](<#Message.AddPart>)
  - [func \(m \*Message\) AddTextPart\(text string\)](<#Message.AddTextPart>)
  - [func \(m \*Message\) AddVideoPart\(filePath string\) error](<#Message.AddVideoPart>)
  - [func \(m \*Message\) GetContent\(\) string](<#Message.GetContent>)
  - [func \(m \*Message\) HasMediaContent\(\) bool](<#Message.HasMediaContent>)
  - [func \(m \*Message\) IsMultimodal\(\) bool](<#Message.IsMultimodal>)
  - [func \(m Message\) MarshalJSON\(\) \(\[\]byte, error\)](<#Message.MarshalJSON>)
  - [func \(m \*Message\) SetMultimodalContent\(parts \[\]ContentPart\)](<#Message.SetMultimodalContent>)
  - [func \(m \*Message\) SetTextContent\(text string\)](<#Message.SetTextContent>)
- [type MessageToolCall](<#MessageToolCall>)
- [type MessageToolResult](<#MessageToolResult>)
- [type StreamingMediaConfig](<#StreamingMediaConfig>)
  - [func \(c \*StreamingMediaConfig\) Validate\(\) error](<#StreamingMediaConfig.Validate>)
- [type ToolDef](<#ToolDef>)
- [type ToolStats](<#ToolStats>)
- [type ValidationError](<#ValidationError>)
- [type ValidationResult](<#ValidationResult>)


## Constants

<a name="ContentTypeText"></a>ContentType constants for different content part types

```go
const (
    ContentTypeText  = "text"
    ContentTypeImage = "image"
    ContentTypeAudio = "audio"
    ContentTypeVideo = "video"
)
```

<a name="MIMETypeImageJPEG"></a>Common MIME types

```go
const (
    MIMETypeImageJPEG = "image/jpeg"
    MIMETypeImagePNG  = "image/png"
    MIMETypeImageGIF  = "image/gif"
    MIMETypeImageWebP = "image/webp"

    MIMETypeAudioMP3  = "audio/mpeg"
    MIMETypeAudioWAV  = "audio/wav"
    MIMETypeAudioOgg  = "audio/ogg"
    MIMETypeAudioWebM = "audio/webm"

    MIMETypeVideoMP4  = "video/mp4"
    MIMETypeVideoWebM = "video/webm"
    MIMETypeVideoOgg  = "video/ogg"
)
```

<a name="CountMediaParts"></a>
## func CountMediaParts

```go
func CountMediaParts(msg Message) int
```

CountMediaParts returns the number of media parts \(image, audio, video\) in a message

<a name="CountPartsByType"></a>
## func CountPartsByType

```go
func CountPartsByType(msg Message, contentType string) int
```

CountPartsByType returns the number of parts of a specific type in a message

<a name="ExtractTextContent"></a>
## func ExtractTextContent

```go
func ExtractTextContent(msg Message) string
```

ExtractTextContent extracts all text content from a message, regardless of format. This is useful for backward compatibility when you need just the text.

<a name="HasOnlyTextContent"></a>
## func HasOnlyTextContent

```go
func HasOnlyTextContent(msg Message) bool
```

HasOnlyTextContent returns true if the message contains only text \(no media\)

<a name="MigrateMessagesToLegacy"></a>
## func MigrateMessagesToLegacy

```go
func MigrateMessagesToLegacy(messages []Message) error
```

MigrateMessagesToLegacy converts a slice of multimodal messages to legacy format in\-place. Returns an error if any message contains media content.

<a name="MigrateMessagesToMultimodal"></a>
## func MigrateMessagesToMultimodal

```go
func MigrateMessagesToMultimodal(messages []Message)
```

MigrateMessagesToMultimodal converts a slice of legacy messages to multimodal format in\-place

<a name="MigrateToLegacy"></a>
## func MigrateToLegacy

```go
func MigrateToLegacy(msg *Message) error
```

MigrateToLegacy converts a multimodal message back to legacy text\-only format. This is useful for backward compatibility with systems that don't support multimodal. Returns an error if the message contains non\-text content.

<a name="MigrateToMultimodal"></a>
## func MigrateToMultimodal

```go
func MigrateToMultimodal(msg *Message)
```

MigrateToMultimodal converts a legacy text\-only message to use the Parts structure. This is useful when transitioning existing code to the new multimodal API.

<a name="ChunkReader"></a>
## type ChunkReader

ChunkReader reads from an io.Reader and produces MediaChunks. Useful for converting continuous streams \(e.g., microphone input\) into chunks.

Example usage:

```
reader := NewChunkReader(micInput, config)
for {
    chunk, err := reader.NextChunk(ctx)
    if err == io.EOF {
        break
    }
    if err != nil {
        return err
    }
    session.SendChunk(ctx, chunk)
}
```

```go
type ChunkReader struct {
    // contains filtered or unexported fields
}
```

<a name="NewChunkReader"></a>
### func NewChunkReader

```go
func NewChunkReader(r io.Reader, config StreamingMediaConfig) *ChunkReader
```

NewChunkReader creates a new ChunkReader that reads from the given reader and produces MediaChunks according to the config.

<a name="ChunkReader.NextChunk"></a>
### func \(\*ChunkReader\) NextChunk

```go
func (cr *ChunkReader) NextChunk(ctx context.Context) (*MediaChunk, error)
```

NextChunk reads the next chunk from the reader. Returns io.EOF when the stream is complete. The returned chunk's IsLast field will be true on the final chunk.

<a name="ChunkWriter"></a>
## type ChunkWriter

ChunkWriter writes MediaChunks to an io.Writer. Useful for converting chunks back into continuous streams \(e.g., speaker output\).

Example usage:

```
writer := NewChunkWriter(speakerOutput)
for chunk := range session.Response() {
    if chunk.MediaDelta != nil {
        err := writer.WriteChunk(chunk.MediaDelta)
        if err != nil {
            return err
        }
    }
}
```

```go
type ChunkWriter struct {
    // contains filtered or unexported fields
}
```

<a name="NewChunkWriter"></a>
### func NewChunkWriter

```go
func NewChunkWriter(w io.Writer) *ChunkWriter
```

NewChunkWriter creates a new ChunkWriter that writes to the given writer.

<a name="ChunkWriter.Flush"></a>
### func \(\*ChunkWriter\) Flush

```go
func (cw *ChunkWriter) Flush() error
```

Flush flushes any buffered data to the underlying writer \(if it supports flushing\).

<a name="ChunkWriter.WriteChunk"></a>
### func \(\*ChunkWriter\) WriteChunk

```go
func (cw *ChunkWriter) WriteChunk(chunk *MediaChunk) (int, error)
```

WriteChunk writes a MediaChunk to the underlying writer. Returns the number of bytes written and any error encountered.

<a name="ContentPart"></a>
## type ContentPart

ContentPart represents a single piece of content in a multimodal message. A message can contain multiple parts: text, images, audio, video, etc.

```go
type ContentPart struct {
    Type string `json:"type"` // "text", "image", "audio", "video"

    // For text content
    Text *string `json:"text,omitempty"`

    // For media content (image, audio, video)
    Media *MediaContent `json:"media,omitempty"`
}
```

<a name="NewAudioPart"></a>
### func NewAudioPart

```go
func NewAudioPart(filePath string) (ContentPart, error)
```

NewAudioPart creates a ContentPart with audio content from a file path

<a name="NewAudioPartFromData"></a>
### func NewAudioPartFromData

```go
func NewAudioPartFromData(base64Data string, mimeType string) ContentPart
```

NewAudioPartFromData creates a ContentPart with base64\-encoded audio data

<a name="NewImagePart"></a>
### func NewImagePart

```go
func NewImagePart(filePath string, detail *string) (ContentPart, error)
```

NewImagePart creates a ContentPart with image content from a file path

<a name="NewImagePartFromData"></a>
### func NewImagePartFromData

```go
func NewImagePartFromData(base64Data string, mimeType string, detail *string) ContentPart
```

NewImagePartFromData creates a ContentPart with base64\-encoded image data

<a name="NewImagePartFromURL"></a>
### func NewImagePartFromURL

```go
func NewImagePartFromURL(url string, detail *string) ContentPart
```

NewImagePartFromURL creates a ContentPart with image content from a URL

<a name="NewTextPart"></a>
### func NewTextPart

```go
func NewTextPart(text string) ContentPart
```

NewTextPart creates a ContentPart with text content

<a name="NewVideoPart"></a>
### func NewVideoPart

```go
func NewVideoPart(filePath string) (ContentPart, error)
```

NewVideoPart creates a ContentPart with video content from a file path

<a name="NewVideoPartFromData"></a>
### func NewVideoPartFromData

```go
func NewVideoPartFromData(base64Data string, mimeType string) ContentPart
```

NewVideoPartFromData creates a ContentPart with base64\-encoded video data

<a name="SplitMultimodalMessage"></a>
### func SplitMultimodalMessage

```go
func SplitMultimodalMessage(msg Message) (text string, mediaParts []ContentPart)
```

SplitMultimodalMessage splits a multimodal message into separate text and media parts. Returns the text content and a slice of media content parts.

<a name="ContentPart.Validate"></a>
### func \(\*ContentPart\) Validate

```go
func (cp *ContentPart) Validate() error
```

Validate checks if the ContentPart is valid

<a name="CostInfo"></a>
## type CostInfo

CostInfo tracks token usage and associated costs for LLM operations. All cost values are in USD. Used for both individual messages and aggregated tracking.

```go
type CostInfo struct {
    InputTokens   int     `json:"input_tokens"`              // Number of input tokens consumed
    OutputTokens  int     `json:"output_tokens"`             // Number of output tokens generated
    CachedTokens  int     `json:"cached_tokens,omitempty"`   // Number of cached tokens used (reduces cost)
    InputCostUSD  float64 `json:"input_cost_usd"`            // Cost of input tokens in USD
    OutputCostUSD float64 `json:"output_cost_usd"`           // Cost of output tokens in USD
    CachedCostUSD float64 `json:"cached_cost_usd,omitempty"` // Cost savings from cached tokens
    TotalCost     float64 `json:"total_cost_usd"`            // Total cost in USD
}
```

<a name="MediaChunk"></a>
## type MediaChunk

MediaChunk represents a chunk of streaming media data. Used for bidirectional streaming where media is sent or received in chunks.

Example usage:

```
chunk := &MediaChunk{
    Data:        audioData,
    SequenceNum: 1,
    Timestamp:   time.Now(),
    IsLast:      false,
    Metadata:    map[string]string{"mime_type": "audio/pcm"},
}
```

```go
type MediaChunk struct {
    // Data contains the raw media bytes for this chunk
    Data []byte `json:"data"`

    // SequenceNum is the sequence number for ordering chunks (starts at 0)
    SequenceNum int64 `json:"sequence_num"`

    // Timestamp indicates when this chunk was created
    Timestamp time.Time `json:"timestamp"`

    // IsLast indicates if this is the final chunk in the stream
    IsLast bool `json:"is_last"`

    // Metadata contains chunk-specific metadata (MIME type, encoding, etc.)
    Metadata map[string]string `json:"metadata,omitempty"`
}
```

<a name="MediaContent"></a>
## type MediaContent

MediaContent represents media data \(image, audio, video\) in a message. Supports both inline base64 data and external file/URL references.

```go
type MediaContent struct {
    // Data source - exactly one should be set
    Data     *string `json:"data,omitempty"`      // Base64-encoded media data
    FilePath *string `json:"file_path,omitempty"` // Local file path
    URL      *string `json:"url,omitempty"`       // External URL (http/https)

    // Media metadata
    MIMEType string  `json:"mime_type"`          // e.g., "image/jpeg", "audio/mp3", "video/mp4"
    Format   *string `json:"format,omitempty"`   // Optional format hint (e.g., "png", "mp3", "mp4")
    SizeKB   *int64  `json:"size_kb,omitempty"`  // Optional size in kilobytes
    Detail   *string `json:"detail,omitempty"`   // Optional detail level for images: "low", "high", "auto"
    Caption  *string `json:"caption,omitempty"`  // Optional caption/description
    Duration *int    `json:"duration,omitempty"` // Optional duration in seconds (for audio/video)
    BitRate  *int    `json:"bit_rate,omitempty"` // Optional bit rate in kbps (for audio/video)
    Channels *int    `json:"channels,omitempty"` // Optional number of channels (for audio)
    Width    *int    `json:"width,omitempty"`    // Optional width in pixels (for image/video)
    Height   *int    `json:"height,omitempty"`   // Optional height in pixels (for image/video)
    FPS      *int    `json:"fps,omitempty"`      // Optional frames per second (for video)
}
```

<a name="MediaContent.GetBase64Data"></a>
### func \(\*MediaContent\) GetBase64Data

```go
func (mc *MediaContent) GetBase64Data() (string, error)
```

GetBase64Data returns the base64\-encoded data for this media content. If the data is already base64\-encoded, it returns it directly. If the data is from a file, it reads and encodes the file. If the data is from a URL, it returns an error \(caller should fetch separately\).

<a name="MediaContent.ReadData"></a>
### func \(\*MediaContent\) ReadData

```go
func (mc *MediaContent) ReadData() (io.ReadCloser, error)
```

ReadData returns an io.Reader for the media content. For base64 data, it decodes and returns a reader. For file paths, it opens and returns the file. For URLs, it returns an error \(caller should fetch separately\).

<a name="MediaContent.Validate"></a>
### func \(\*MediaContent\) Validate

```go
func (mc *MediaContent) Validate() error
```

Validate checks if the MediaContent is valid

<a name="MediaItemSummary"></a>
## type MediaItemSummary

MediaItemSummary provides details about a single media item in a message.

```go
type MediaItemSummary struct {
    Type      string `json:"type"`             // Content type: "image", "audio", "video"
    Source    string `json:"source"`           // Source description (file path, URL, or "inline data")
    MIMEType  string `json:"mime_type"`        // MIME type
    SizeBytes int    `json:"size_bytes"`       // Size in bytes (0 if unknown)
    Detail    string `json:"detail,omitempty"` // Detail level for images
    Loaded    bool   `json:"loaded"`           // Whether media was successfully loaded
    Error     string `json:"error,omitempty"`  // Error message if loading failed
}
```

<a name="MediaSummary"></a>
## type MediaSummary

MediaSummary provides a high\-level overview of media content in a message. This is included in JSON output to make multimodal messages more observable.

```go
type MediaSummary struct {
    TotalParts int                `json:"total_parts"`           // Total number of content parts
    TextParts  int                `json:"text_parts"`            // Number of text parts
    ImageParts int                `json:"image_parts"`           // Number of image parts
    AudioParts int                `json:"audio_parts"`           // Number of audio parts
    VideoParts int                `json:"video_parts"`           // Number of video parts
    MediaItems []MediaItemSummary `json:"media_items,omitempty"` // Details of each media item
}
```

<a name="Message"></a>
## type Message

Message represents a single message in a conversation. This is the canonical message type used throughout the system.

```go
type Message struct {
    Role    string `json:"role"`    // "system", "user", "assistant", "tool"
    Content string `json:"content"` // Message content (legacy text-only, maintained for backward compatibility)

    // Multimodal content parts (text, images, audio, video)
    // If Parts is non-empty, it takes precedence over Content.
    // For backward compatibility, if Parts is empty, Content will be used.
    Parts []ContentPart `json:"parts,omitempty"`

    // Tool invocations (for assistant messages that call tools)
    ToolCalls []MessageToolCall `json:"tool_calls,omitempty"`

    // Tool result (for tool role messages)
    // When Role="tool", this contains the tool execution result
    ToolResult *MessageToolResult `json:"tool_result,omitempty"`

    // Source indicates where this message originated (runtime-only, not persisted in JSON)
    // Values: "statestore" (loaded from StateStore), "pipeline" (created during execution), "" (user input)
    Source string `json:"-"`

    // Metadata for observability and tracking
    Timestamp time.Time              `json:"timestamp,omitempty"`  // When the message was created
    LatencyMs int64                  `json:"latency_ms,omitempty"` // Time taken to generate (for assistant messages)
    CostInfo  *CostInfo              `json:"cost_info,omitempty"`  // Token usage and cost tracking
    Meta      map[string]interface{} `json:"meta,omitempty"`       // Custom metadata

    // Validation results (for assistant messages)
    Validations []ValidationResult `json:"validations,omitempty"`
}
```

<a name="CloneMessage"></a>
### func CloneMessage

```go
func CloneMessage(msg Message) Message
```

CloneMessage creates a deep copy of a message

<a name="CombineTextAndMedia"></a>
### func CombineTextAndMedia

```go
func CombineTextAndMedia(role, text string, mediaParts []ContentPart) Message
```

CombineTextAndMedia creates a multimodal message from separate text and media parts. This is the inverse of SplitMultimodalMessage.

<a name="ConvertTextToMultimodal"></a>
### func ConvertTextToMultimodal

```go
func ConvertTextToMultimodal(role, content string) Message
```

ConvertTextToMultimodal is a convenience function that creates a multimodal message from a role and text content. This helps with code migration.

<a name="Message.AddAudioPart"></a>
### func \(\*Message\) AddAudioPart

```go
func (m *Message) AddAudioPart(filePath string) error
```

AddAudioPart adds an audio content part from a file path

<a name="Message.AddImagePart"></a>
### func \(\*Message\) AddImagePart

```go
func (m *Message) AddImagePart(filePath string, detail *string) error
```

AddImagePart adds an image content part from a file path

<a name="Message.AddImagePartFromURL"></a>
### func \(\*Message\) AddImagePartFromURL

```go
func (m *Message) AddImagePartFromURL(url string, detail *string)
```

AddImagePartFromURL adds an image content part from a URL

<a name="Message.AddPart"></a>
### func \(\*Message\) AddPart

```go
func (m *Message) AddPart(part ContentPart)
```

AddPart adds a content part to the message. If this is the first part added, it clears the legacy Content field.

<a name="Message.AddTextPart"></a>
### func \(\*Message\) AddTextPart

```go
func (m *Message) AddTextPart(text string)
```

AddTextPart adds a text content part to the message

<a name="Message.AddVideoPart"></a>
### func \(\*Message\) AddVideoPart

```go
func (m *Message) AddVideoPart(filePath string) error
```

AddVideoPart adds a video content part from a file path

<a name="Message.GetContent"></a>
### func \(\*Message\) GetContent

```go
func (m *Message) GetContent() string
```

GetContent returns the content of the message. If Parts is non\-empty, it returns only the text parts concatenated. Otherwise, it returns the legacy Content field.

<a name="Message.HasMediaContent"></a>
### func \(\*Message\) HasMediaContent

```go
func (m *Message) HasMediaContent() bool
```

HasMediaContent returns true if the message contains any media \(image, audio, video\)

<a name="Message.IsMultimodal"></a>
### func \(\*Message\) IsMultimodal

```go
func (m *Message) IsMultimodal() bool
```

IsMultimodal returns true if the message contains multimodal content \(Parts\)

<a name="Message.MarshalJSON"></a>
### func \(Message\) MarshalJSON

```go
func (m Message) MarshalJSON() ([]byte, error)
```

MarshalJSON implements custom JSON marshaling for Message. This enhances the output by: 1. Populating the Content field with a human\-readable summary when Parts exist 2. Adding a MediaSummary field for observability of multimodal content

<a name="Message.SetMultimodalContent"></a>
### func \(\*Message\) SetMultimodalContent

```go
func (m *Message) SetMultimodalContent(parts []ContentPart)
```

SetMultimodalContent sets the message content to multimodal parts. This clears the legacy Content field.

<a name="Message.SetTextContent"></a>
### func \(\*Message\) SetTextContent

```go
func (m *Message) SetTextContent(text string)
```

SetTextContent sets the message content to simple text. This clears any existing Parts and sets the legacy Content field.

<a name="MessageToolCall"></a>
## type MessageToolCall

MessageToolCall represents a request to call a tool within a Message. The Args field contains the JSON\-encoded arguments for the tool.

```go
type MessageToolCall struct {
    ID   string          `json:"id"`   // Unique identifier for this tool call
    Name string          `json:"name"` // Name of the tool to invoke
    Args json.RawMessage `json:"args"` // JSON-encoded tool arguments
}
```

<a name="MessageToolResult"></a>
## type MessageToolResult

MessageToolResult represents the result of a tool execution in a Message. When embedded in Message, the Message.Role should be "tool".

```go
type MessageToolResult struct {
    ID        string `json:"id"`              // References the MessageToolCall.ID that triggered this result
    Name      string `json:"name"`            // Tool name that was executed
    Content   string `json:"content"`         // Result content or error message
    Error     string `json:"error,omitempty"` // Error message if tool execution failed
    LatencyMs int64  `json:"latency_ms"`      // Tool execution latency in milliseconds
}
```

<a name="StreamingMediaConfig"></a>
## type StreamingMediaConfig

StreamingMediaConfig configures streaming media input parameters. Used to configure audio/video streaming sessions with providers.

Example usage for audio streaming:

```
config := &StreamingMediaConfig{
    Type:       ContentTypeAudio,
    ChunkSize:  8192,    // 8KB chunks
    SampleRate: 16000,   // 16kHz audio
    Encoding:   "pcm",   // Raw PCM audio
    Channels:   1,       // Mono
    BufferSize: 10,      // Buffer 10 chunks
}
```

```go
type StreamingMediaConfig struct {
    // Type specifies the media type being streamed
    // Values: ContentTypeAudio, ContentTypeVideo
    Type string `json:"type"`

    // ChunkSize is the target size in bytes for each chunk
    // Typical values: 4096-8192 for audio, 32768-65536 for video
    ChunkSize int `json:"chunk_size"`

    // SampleRate is the audio sample rate in Hz
    // Common values: 8000 (phone quality), 16000 (wideband), 44100 (CD quality), 48000 (pro audio)
    SampleRate int `json:"sample_rate,omitempty"`

    // Encoding specifies the audio encoding format
    // Values: "pcm" (raw), "opus", "mp3", "aac"
    Encoding string `json:"encoding,omitempty"`

    // Channels is the number of audio channels
    // Values: 1 (mono), 2 (stereo)
    Channels int `json:"channels,omitempty"`

    // BitDepth is the audio bit depth in bits
    // Common values: 16, 24, 32
    BitDepth int `json:"bit_depth,omitempty"`

    // Width is the video width in pixels
    Width int `json:"width,omitempty"`

    // Height is the video height in pixels
    Height int `json:"height,omitempty"`

    // FrameRate is the video frame rate (FPS)
    // Common values: 24, 30, 60
    FrameRate int `json:"frame_rate,omitempty"`

    // BufferSize is the maximum number of chunks to buffer
    // Larger values increase latency but provide more stability
    // Typical values: 5-20
    BufferSize int `json:"buffer_size,omitempty"`

    // FlushInterval is how often to flush buffered data (if applicable)
    FlushInterval time.Duration `json:"flush_interval,omitempty"`

    // Metadata contains additional provider-specific configuration
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}
```

<a name="StreamingMediaConfig.Validate"></a>
### func \(\*StreamingMediaConfig\) Validate

```go
func (c *StreamingMediaConfig) Validate() error
```

Validate checks if the StreamingMediaConfig is valid

<a name="ToolDef"></a>
## type ToolDef

ToolDef represents a tool definition that can be provided to an LLM. The InputSchema and OutputSchema use JSON Schema format for validation.

```go
type ToolDef struct {
    Name         string          `json:"name"`                    // Unique tool name
    Description  string          `json:"description"`             // Human-readable description of what the tool does
    InputSchema  json.RawMessage `json:"input_schema"`            // JSON Schema for input validation
    OutputSchema json.RawMessage `json:"output_schema,omitempty"` // Optional JSON Schema for output validation
}
```

<a name="ToolStats"></a>
## type ToolStats

ToolStats tracks tool usage statistics across a conversation or run. Useful for monitoring which tools are being used and how frequently.

```go
type ToolStats struct {
    TotalCalls int            `json:"total_calls"` // Total number of tool calls
    ByTool     map[string]int `json:"by_tool"`     // Count of calls per tool name
}
```

<a name="ValidationError"></a>
## type ValidationError

ValidationError represents a validation failure in tool usage or message content. Used to provide structured error information when validation fails.

```go
type ValidationError struct {
    Type   string `json:"type"`   // Error type: "args_invalid" | "result_invalid" | "policy_violation"
    Tool   string `json:"tool"`   // Name of the tool that failed validation
    Detail string `json:"detail"` // Human-readable error details
}
```

<a name="ValidationResult"></a>
## type ValidationResult

ValidationResult represents the outcome of a validator check on a message. These are attached to assistant messages to show which validations passed or failed.

```go
type ValidationResult struct {
    ValidatorType string                 `json:"validator_type"`      // Type of validator
    Passed        bool                   `json:"passed"`              // Whether the validation passed
    Details       map[string]interface{} `json:"details,omitempty"`   // Validator-specific details
    Timestamp     time.Time              `json:"timestamp,omitempty"` // When validation was performed
}
```

# validators

```go
import "github.com/AltairaLabs/PromptKit/runtime/validators"
```

Package validators provides content validation for LLM responses and user inputs.

This package implements various validators to ensure conversation quality:

- Length and sentence count limits
- Banned word detection
- Role integrity \(preventing role confusion\)
- Required field presence
- Question and commit block validation

Validators are used during test execution to catch policy violations and ensure LLM responses meet quality standards.

## Index

- [Variables](<#variables>)
- [type BannedWordsValidator](<#BannedWordsValidator>)
  - [func NewBannedWordsValidator\(bannedWords \[\]string\) \*BannedWordsValidator](<#NewBannedWordsValidator>)
  - [func \(v \*BannedWordsValidator\) SupportsStreaming\(\) bool](<#BannedWordsValidator.SupportsStreaming>)
  - [func \(v \*BannedWordsValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#BannedWordsValidator.Validate>)
  - [func \(v \*BannedWordsValidator\) ValidateChunk\(chunk providers.StreamChunk, params ...map\[string\]interface\{\}\) error](<#BannedWordsValidator.ValidateChunk>)
- [type CommitValidator](<#CommitValidator>)
  - [func NewCommitValidator\(\) \*CommitValidator](<#NewCommitValidator>)
  - [func \(v \*CommitValidator\) SupportsStreaming\(\) bool](<#CommitValidator.SupportsStreaming>)
  - [func \(v \*CommitValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#CommitValidator.Validate>)
- [type LengthValidator](<#LengthValidator>)
  - [func NewLengthValidator\(\) \*LengthValidator](<#NewLengthValidator>)
  - [func \(v \*LengthValidator\) SupportsStreaming\(\) bool](<#LengthValidator.SupportsStreaming>)
  - [func \(v \*LengthValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#LengthValidator.Validate>)
  - [func \(v \*LengthValidator\) ValidateChunk\(chunk providers.StreamChunk, params ...map\[string\]interface\{\}\) error](<#LengthValidator.ValidateChunk>)
- [type MaxSentencesValidator](<#MaxSentencesValidator>)
  - [func NewMaxSentencesValidator\(\) \*MaxSentencesValidator](<#NewMaxSentencesValidator>)
  - [func \(v \*MaxSentencesValidator\) SupportsStreaming\(\) bool](<#MaxSentencesValidator.SupportsStreaming>)
  - [func \(v \*MaxSentencesValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#MaxSentencesValidator.Validate>)
- [type Registry](<#Registry>)
  - [func NewRegistry\(\) \*Registry](<#NewRegistry>)
  - [func \(r \*Registry\) Get\(validatorType string\) \(ValidatorFactory, bool\)](<#Registry.Get>)
  - [func \(r \*Registry\) HasValidator\(validatorType string\) bool](<#Registry.HasValidator>)
  - [func \(r \*Registry\) Register\(validatorType string, factory ValidatorFactory\)](<#Registry.Register>)
- [type RequiredFieldsValidator](<#RequiredFieldsValidator>)
  - [func NewRequiredFieldsValidator\(\) \*RequiredFieldsValidator](<#NewRequiredFieldsValidator>)
  - [func \(v \*RequiredFieldsValidator\) SupportsStreaming\(\) bool](<#RequiredFieldsValidator.SupportsStreaming>)
  - [func \(v \*RequiredFieldsValidator\) Validate\(content string, params map\[string\]interface\{\}\) ValidationResult](<#RequiredFieldsValidator.Validate>)
- [type StreamingValidator](<#StreamingValidator>)
- [type ValidationResult](<#ValidationResult>)
- [type Validator](<#Validator>)
- [type ValidatorConfig](<#ValidatorConfig>)
- [type ValidatorFactory](<#ValidatorFactory>)


## Variables

<a name="DefaultRegistry"></a>DefaultRegistry is the global validator registry.

```go
var DefaultRegistry = NewRegistry()
```

<a name="BannedWordsValidator"></a>
## type BannedWordsValidator

BannedWordsValidator checks for banned words

```go
type BannedWordsValidator struct {
    // contains filtered or unexported fields
}
```

<a name="NewBannedWordsValidator"></a>
### func NewBannedWordsValidator

```go
func NewBannedWordsValidator(bannedWords []string) *BannedWordsValidator
```

NewBannedWordsValidator creates a new banned words validator

<a name="BannedWordsValidator.SupportsStreaming"></a>
### func \(\*BannedWordsValidator\) SupportsStreaming

```go
func (v *BannedWordsValidator) SupportsStreaming() bool
```

SupportsStreaming returns true as banned words can be detected incrementally

<a name="BannedWordsValidator.Validate"></a>
### func \(\*BannedWordsValidator\) Validate

```go
func (v *BannedWordsValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for banned words in content

<a name="BannedWordsValidator.ValidateChunk"></a>
### func \(\*BannedWordsValidator\) ValidateChunk

```go
func (v *BannedWordsValidator) ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error
```

ValidateChunk validates a stream chunk for banned words and aborts if found

<a name="CommitValidator"></a>
## type CommitValidator

CommitValidator checks for commit/decision blocks in conversation responses

```go
type CommitValidator struct{}
```

<a name="NewCommitValidator"></a>
### func NewCommitValidator

```go
func NewCommitValidator() *CommitValidator
```

NewCommitValidator creates a new commit validator

<a name="CommitValidator.SupportsStreaming"></a>
### func \(\*CommitValidator\) SupportsStreaming

```go
func (v *CommitValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as commit validation requires complete content

<a name="CommitValidator.Validate"></a>
### func \(\*CommitValidator\) Validate

```go
func (v *CommitValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for commit block with required fields

<a name="LengthValidator"></a>
## type LengthValidator

LengthValidator checks content length limits

```go
type LengthValidator struct{}
```

<a name="NewLengthValidator"></a>
### func NewLengthValidator

```go
func NewLengthValidator() *LengthValidator
```

NewLengthValidator creates a new length validator

<a name="LengthValidator.SupportsStreaming"></a>
### func \(\*LengthValidator\) SupportsStreaming

```go
func (v *LengthValidator) SupportsStreaming() bool
```

SupportsStreaming returns true as length can be checked incrementally

<a name="LengthValidator.Validate"></a>
### func \(\*LengthValidator\) Validate

```go
func (v *LengthValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks content length against limits

<a name="LengthValidator.ValidateChunk"></a>
### func \(\*LengthValidator\) ValidateChunk

```go
func (v *LengthValidator) ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error
```

ValidateChunk validates stream chunk against length limits and aborts if exceeded

<a name="MaxSentencesValidator"></a>
## type MaxSentencesValidator

MaxSentencesValidator checks sentence count limits

```go
type MaxSentencesValidator struct{}
```

<a name="NewMaxSentencesValidator"></a>
### func NewMaxSentencesValidator

```go
func NewMaxSentencesValidator() *MaxSentencesValidator
```

NewMaxSentencesValidator creates a new sentence count validator

<a name="MaxSentencesValidator.SupportsStreaming"></a>
### func \(\*MaxSentencesValidator\) SupportsStreaming

```go
func (v *MaxSentencesValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as sentence counting requires complete content

<a name="MaxSentencesValidator.Validate"></a>
### func \(\*MaxSentencesValidator\) Validate

```go
func (v *MaxSentencesValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks sentence count against max limit

<a name="Registry"></a>
## type Registry

Registry maps validator type names to factory functions. This allows dynamic instantiation of validators from configuration.

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

<a name="NewRegistry"></a>
### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new validator registry with built\-in validators.

<a name="Registry.Get"></a>
### func \(\*Registry\) Get

```go
func (r *Registry) Get(validatorType string) (ValidatorFactory, bool)
```

Get retrieves a validator factory by type.

<a name="Registry.HasValidator"></a>
### func \(\*Registry\) HasValidator

```go
func (r *Registry) HasValidator(validatorType string) bool
```

HasValidator returns true if a validator type is registered.

<a name="Registry.Register"></a>
### func \(\*Registry\) Register

```go
func (r *Registry) Register(validatorType string, factory ValidatorFactory)
```

Register adds a validator factory to the registry.

<a name="RequiredFieldsValidator"></a>
## type RequiredFieldsValidator

RequiredFieldsValidator checks for required fields in content

```go
type RequiredFieldsValidator struct{}
```

<a name="NewRequiredFieldsValidator"></a>
### func NewRequiredFieldsValidator

```go
func NewRequiredFieldsValidator() *RequiredFieldsValidator
```

NewRequiredFieldsValidator creates a new required fields validator

<a name="RequiredFieldsValidator.SupportsStreaming"></a>
### func \(\*RequiredFieldsValidator\) SupportsStreaming

```go
func (v *RequiredFieldsValidator) SupportsStreaming() bool
```

SupportsStreaming returns false as required fields must be in complete content

<a name="RequiredFieldsValidator.Validate"></a>
### func \(\*RequiredFieldsValidator\) Validate

```go
func (v *RequiredFieldsValidator) Validate(content string, params map[string]interface{}) ValidationResult
```

Validate checks for required fields in content

<a name="StreamingValidator"></a>
## type StreamingValidator

StreamingValidator interface for validators that can check content incrementally and abort streaming early if validation fails

```go
type StreamingValidator interface {
    Validator

    // ValidateChunk validates a stream chunk and returns error to abort stream
    // Returns nil to continue, ValidationAbortError to abort stream
    ValidateChunk(chunk providers.StreamChunk, params ...map[string]interface{}) error

    // SupportsStreaming returns true if this validator can validate incrementally
    SupportsStreaming() bool
}
```

<a name="ValidationResult"></a>
## type ValidationResult

ValidationResult holds the result of a validation check

```go
type ValidationResult struct {
    Passed  bool        `json:"passed"`
    Details interface{} `json:"details,omitempty"`
}
```

<a name="Validator"></a>
## type Validator

Validator interface for all validation checks

```go
type Validator interface {
    Validate(content string, params map[string]interface{}) ValidationResult
}
```

<a name="ValidatorConfig"></a>
## type ValidatorConfig

ValidatorConfig defines a validator configuration from a prompt pack. This is just configuration data \- validators are instantiated by the registry.

```go
type ValidatorConfig struct {
    Type   string                 `json:"type" yaml:"type"`
    Params map[string]interface{} `json:"params" yaml:"params"`
}
```

<a name="ValidatorFactory"></a>
## type ValidatorFactory

ValidatorFactory creates a validator instance from configuration params. Params from the config are passed at construction time to allow validators to pre\-compile patterns, build state, etc.

```go
type ValidatorFactory func(params map[string]interface{}) Validator
```

# json

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/json"
```

Package json provides JSON file\-based implementations of persistence repositories.

This package can be used for production environments where JSON is preferred over YAML.

## Index

- [type JSONPromptRepository](<#JSONPromptRepository>)
  - [func NewJSONPromptRepository\(basePath string, taskTypeToFile map\[string\]string\) \*JSONPromptRepository](<#NewJSONPromptRepository>)
  - [func \(r \*JSONPromptRepository\) ListPrompts\(\) \(\[\]string, error\)](<#JSONPromptRepository.ListPrompts>)
  - [func \(r \*JSONPromptRepository\) LoadFragment\(name string, relativePath string, baseDir string\) \(\*prompt.Fragment, error\)](<#JSONPromptRepository.LoadFragment>)
  - [func \(r \*JSONPromptRepository\) LoadPrompt\(taskType string\) \(\*prompt.PromptConfig, error\)](<#JSONPromptRepository.LoadPrompt>)
  - [func \(r \*JSONPromptRepository\) SavePrompt\(config \*prompt.PromptConfig\) error](<#JSONPromptRepository.SavePrompt>)
- [type JSONToolRepository](<#JSONToolRepository>)
  - [func NewJSONToolRepository\(basePath string\) \*JSONToolRepository](<#NewJSONToolRepository>)
  - [func \(r \*JSONToolRepository\) ListTools\(\) \(\[\]string, error\)](<#JSONToolRepository.ListTools>)
  - [func \(r \*JSONToolRepository\) LoadDirectory\(dirPath string\) error](<#JSONToolRepository.LoadDirectory>)
  - [func \(r \*JSONToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#JSONToolRepository.LoadTool>)
  - [func \(r \*JSONToolRepository\) LoadToolFromFile\(filename string\) error](<#JSONToolRepository.LoadToolFromFile>)
  - [func \(r \*JSONToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#JSONToolRepository.RegisterTool>)
  - [func \(r \*JSONToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#JSONToolRepository.SaveTool>)


<a name="JSONPromptRepository"></a>
## type JSONPromptRepository

JSONPromptRepository loads prompts from JSON files on disk

```go
type JSONPromptRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewJSONPromptRepository"></a>
### func NewJSONPromptRepository

```go
func NewJSONPromptRepository(basePath string, taskTypeToFile map[string]string) *JSONPromptRepository
```

NewJSONPromptRepository creates a JSON file\-based prompt repository

<a name="JSONPromptRepository.ListPrompts"></a>
### func \(\*JSONPromptRepository\) ListPrompts

```go
func (r *JSONPromptRepository) ListPrompts() ([]string, error)
```

ListPrompts returns all available prompt task types

<a name="JSONPromptRepository.LoadFragment"></a>
### func \(\*JSONPromptRepository\) LoadFragment

```go
func (r *JSONPromptRepository) LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name

<a name="JSONPromptRepository.LoadPrompt"></a>
### func \(\*JSONPromptRepository\) LoadPrompt

```go
func (r *JSONPromptRepository) LoadPrompt(taskType string) (*prompt.PromptConfig, error)
```

LoadPrompt loads a prompt configuration by task type

<a name="JSONPromptRepository.SavePrompt"></a>
### func \(\*JSONPromptRepository\) SavePrompt

```go
func (r *JSONPromptRepository) SavePrompt(config *prompt.PromptConfig) error
```

SavePrompt saves a prompt configuration \(not yet implemented\)

<a name="JSONToolRepository"></a>
## type JSONToolRepository

JSONToolRepository loads tools from JSON files on disk

```go
type JSONToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewJSONToolRepository"></a>
### func NewJSONToolRepository

```go
func NewJSONToolRepository(basePath string) *JSONToolRepository
```

NewJSONToolRepository creates a JSON file\-based tool repository

<a name="JSONToolRepository.ListTools"></a>
### func \(\*JSONToolRepository\) ListTools

```go
func (r *JSONToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="JSONToolRepository.LoadDirectory"></a>
### func \(\*JSONToolRepository\) LoadDirectory

```go
func (r *JSONToolRepository) LoadDirectory(dirPath string) error
```

LoadDirectory recursively loads all JSON tool files from a directory

<a name="JSONToolRepository.LoadTool"></a>
### func \(\*JSONToolRepository\) LoadTool

```go
func (r *JSONToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="JSONToolRepository.LoadToolFromFile"></a>
### func \(\*JSONToolRepository\) LoadToolFromFile

```go
func (r *JSONToolRepository) LoadToolFromFile(filename string) error
```

LoadToolFromFile loads a tool from a JSON file

<a name="JSONToolRepository.RegisterTool"></a>
### func \(\*JSONToolRepository\) RegisterTool

```go
func (r *JSONToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool descriptor directly

<a name="JSONToolRepository.SaveTool"></a>
### func \(\*JSONToolRepository\) SaveTool

```go
func (r *JSONToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor \(not yet implemented\)

# memory

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/memory"
```

Package memory provides in\-memory implementations of persistence repositories.

This package is primarily for testing and SDK use, allowing prompts and tools to be registered programmatically without file system dependencies.

## Index

- [type MemoryPromptRepository](<#MemoryPromptRepository>)
  - [func NewMemoryPromptRepository\(\) \*MemoryPromptRepository](<#NewMemoryPromptRepository>)
  - [func \(r \*MemoryPromptRepository\) ListPrompts\(\) \(\[\]string, error\)](<#MemoryPromptRepository.ListPrompts>)
  - [func \(r \*MemoryPromptRepository\) LoadFragment\(name string, relativePath string, baseDir string\) \(\*prompt.Fragment, error\)](<#MemoryPromptRepository.LoadFragment>)
  - [func \(r \*MemoryPromptRepository\) LoadPrompt\(taskType string\) \(\*prompt.PromptConfig, error\)](<#MemoryPromptRepository.LoadPrompt>)
  - [func \(r \*MemoryPromptRepository\) RegisterFragment\(name string, fragment \*prompt.Fragment\)](<#MemoryPromptRepository.RegisterFragment>)
  - [func \(r \*MemoryPromptRepository\) RegisterPrompt\(taskType string, config \*prompt.PromptConfig\)](<#MemoryPromptRepository.RegisterPrompt>)
  - [func \(r \*MemoryPromptRepository\) SavePrompt\(config \*prompt.PromptConfig\) error](<#MemoryPromptRepository.SavePrompt>)
- [type MemoryToolRepository](<#MemoryToolRepository>)
  - [func NewMemoryToolRepository\(\) \*MemoryToolRepository](<#NewMemoryToolRepository>)
  - [func \(r \*MemoryToolRepository\) ListTools\(\) \(\[\]string, error\)](<#MemoryToolRepository.ListTools>)
  - [func \(r \*MemoryToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#MemoryToolRepository.LoadTool>)
  - [func \(r \*MemoryToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#MemoryToolRepository.RegisterTool>)
  - [func \(r \*MemoryToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#MemoryToolRepository.SaveTool>)


<a name="MemoryPromptRepository"></a>
## type MemoryPromptRepository

MemoryPromptRepository stores prompts in memory \(for testing/SDK\)

```go
type MemoryPromptRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewMemoryPromptRepository"></a>
### func NewMemoryPromptRepository

```go
func NewMemoryPromptRepository() *MemoryPromptRepository
```

NewMemoryPromptRepository creates a new in\-memory prompt repository

<a name="MemoryPromptRepository.ListPrompts"></a>
### func \(\*MemoryPromptRepository\) ListPrompts

```go
func (r *MemoryPromptRepository) ListPrompts() ([]string, error)
```

ListPrompts returns all available prompt task types

<a name="MemoryPromptRepository.LoadFragment"></a>
### func \(\*MemoryPromptRepository\) LoadFragment

```go
func (r *MemoryPromptRepository) LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name

<a name="MemoryPromptRepository.LoadPrompt"></a>
### func \(\*MemoryPromptRepository\) LoadPrompt

```go
func (r *MemoryPromptRepository) LoadPrompt(taskType string) (*prompt.PromptConfig, error)
```

LoadPrompt loads a prompt configuration by task type

<a name="MemoryPromptRepository.RegisterFragment"></a>
### func \(\*MemoryPromptRepository\) RegisterFragment

```go
func (r *MemoryPromptRepository) RegisterFragment(name string, fragment *prompt.Fragment)
```

RegisterFragment adds a fragment to the in\-memory store

<a name="MemoryPromptRepository.RegisterPrompt"></a>
### func \(\*MemoryPromptRepository\) RegisterPrompt

```go
func (r *MemoryPromptRepository) RegisterPrompt(taskType string, config *prompt.PromptConfig)
```

RegisterPrompt adds a prompt to the in\-memory store

<a name="MemoryPromptRepository.SavePrompt"></a>
### func \(\*MemoryPromptRepository\) SavePrompt

```go
func (r *MemoryPromptRepository) SavePrompt(config *prompt.PromptConfig) error
```

SavePrompt saves a prompt configuration

<a name="MemoryToolRepository"></a>
## type MemoryToolRepository

MemoryToolRepository stores tools in memory \(for testing/SDK\)

```go
type MemoryToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewMemoryToolRepository"></a>
### func NewMemoryToolRepository

```go
func NewMemoryToolRepository() *MemoryToolRepository
```

NewMemoryToolRepository creates a new in\-memory tool repository

<a name="MemoryToolRepository.ListTools"></a>
### func \(\*MemoryToolRepository\) ListTools

```go
func (r *MemoryToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="MemoryToolRepository.LoadTool"></a>
### func \(\*MemoryToolRepository\) LoadTool

```go
func (r *MemoryToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="MemoryToolRepository.RegisterTool"></a>
### func \(\*MemoryToolRepository\) RegisterTool

```go
func (r *MemoryToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool to the in\-memory store

<a name="MemoryToolRepository.SaveTool"></a>
### func \(\*MemoryToolRepository\) SaveTool

```go
func (r *MemoryToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor

# yaml

```go
import "github.com/AltairaLabs/PromptKit/runtime/persistence/yaml"
```

Package yaml provides YAML file\-based implementations of persistence repositories.

This package is primarily for Arena and development use, loading prompts and tools from YAML configuration files on disk.

## Index

- [type YAMLPromptRepository](<#YAMLPromptRepository>)
  - [func NewYAMLPromptRepository\(basePath string, taskTypeToFile map\[string\]string\) \*YAMLPromptRepository](<#NewYAMLPromptRepository>)
  - [func \(r \*YAMLPromptRepository\) ListPrompts\(\) \(\[\]string, error\)](<#YAMLPromptRepository.ListPrompts>)
  - [func \(r \*YAMLPromptRepository\) LoadFragment\(name string, relativePath string, baseDir string\) \(\*prompt.Fragment, error\)](<#YAMLPromptRepository.LoadFragment>)
  - [func \(r \*YAMLPromptRepository\) LoadPrompt\(taskType string\) \(\*prompt.PromptConfig, error\)](<#YAMLPromptRepository.LoadPrompt>)
  - [func \(r \*YAMLPromptRepository\) SavePrompt\(config \*prompt.PromptConfig\) error](<#YAMLPromptRepository.SavePrompt>)
- [type YAMLToolRepository](<#YAMLToolRepository>)
  - [func NewYAMLToolRepository\(basePath string\) \*YAMLToolRepository](<#NewYAMLToolRepository>)
  - [func \(r \*YAMLToolRepository\) ListTools\(\) \(\[\]string, error\)](<#YAMLToolRepository.ListTools>)
  - [func \(r \*YAMLToolRepository\) LoadDirectory\(dirPath string\) error](<#YAMLToolRepository.LoadDirectory>)
  - [func \(r \*YAMLToolRepository\) LoadTool\(name string\) \(\*tools.ToolDescriptor, error\)](<#YAMLToolRepository.LoadTool>)
  - [func \(r \*YAMLToolRepository\) LoadToolFromFile\(filename string\) error](<#YAMLToolRepository.LoadToolFromFile>)
  - [func \(r \*YAMLToolRepository\) RegisterTool\(name string, descriptor \*tools.ToolDescriptor\)](<#YAMLToolRepository.RegisterTool>)
  - [func \(r \*YAMLToolRepository\) SaveTool\(descriptor \*tools.ToolDescriptor\) error](<#YAMLToolRepository.SaveTool>)


<a name="YAMLPromptRepository"></a>
## type YAMLPromptRepository

YAMLPromptRepository loads prompts from YAML files on disk

```go
type YAMLPromptRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewYAMLPromptRepository"></a>
### func NewYAMLPromptRepository

```go
func NewYAMLPromptRepository(basePath string, taskTypeToFile map[string]string) *YAMLPromptRepository
```

NewYAMLPromptRepository creates a YAML file\-based prompt repository If taskTypeToFile mappings are provided, they will be used for lookups. Otherwise, the repository will search the basePath directory.

<a name="YAMLPromptRepository.ListPrompts"></a>
### func \(\*YAMLPromptRepository\) ListPrompts

```go
func (r *YAMLPromptRepository) ListPrompts() ([]string, error)
```

ListPrompts returns all available prompt task types

<a name="YAMLPromptRepository.LoadFragment"></a>
### func \(\*YAMLPromptRepository\) LoadFragment

```go
func (r *YAMLPromptRepository) LoadFragment(name string, relativePath string, baseDir string) (*prompt.Fragment, error)
```

LoadFragment loads a fragment by name and optional path

<a name="YAMLPromptRepository.LoadPrompt"></a>
### func \(\*YAMLPromptRepository\) LoadPrompt

```go
func (r *YAMLPromptRepository) LoadPrompt(taskType string) (*prompt.PromptConfig, error)
```

LoadPrompt loads a prompt configuration by task type

<a name="YAMLPromptRepository.SavePrompt"></a>
### func \(\*YAMLPromptRepository\) SavePrompt

```go
func (r *YAMLPromptRepository) SavePrompt(config *prompt.PromptConfig) error
```

SavePrompt saves a prompt configuration \(not yet implemented\)

<a name="YAMLToolRepository"></a>
## type YAMLToolRepository

YAMLToolRepository loads tools from YAML files on disk

```go
type YAMLToolRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewYAMLToolRepository"></a>
### func NewYAMLToolRepository

```go
func NewYAMLToolRepository(basePath string) *YAMLToolRepository
```

NewYAMLToolRepository creates a YAML file\-based tool repository

<a name="YAMLToolRepository.ListTools"></a>
### func \(\*YAMLToolRepository\) ListTools

```go
func (r *YAMLToolRepository) ListTools() ([]string, error)
```

ListTools returns all available tool names

<a name="YAMLToolRepository.LoadDirectory"></a>
### func \(\*YAMLToolRepository\) LoadDirectory

```go
func (r *YAMLToolRepository) LoadDirectory(dirPath string) error
```

LoadDirectory recursively loads all YAML tool files from a directory

<a name="YAMLToolRepository.LoadTool"></a>
### func \(\*YAMLToolRepository\) LoadTool

```go
func (r *YAMLToolRepository) LoadTool(name string) (*tools.ToolDescriptor, error)
```

LoadTool loads a tool descriptor by name

<a name="YAMLToolRepository.LoadToolFromFile"></a>
### func \(\*YAMLToolRepository\) LoadToolFromFile

```go
func (r *YAMLToolRepository) LoadToolFromFile(filename string) error
```

LoadToolFromFile loads a tool from a YAML file and registers it

<a name="YAMLToolRepository.RegisterTool"></a>
### func \(\*YAMLToolRepository\) RegisterTool

```go
func (r *YAMLToolRepository) RegisterTool(name string, descriptor *tools.ToolDescriptor)
```

RegisterTool adds a tool descriptor directly to the repository

<a name="YAMLToolRepository.SaveTool"></a>
### func \(\*YAMLToolRepository\) SaveTool

```go
func (r *YAMLToolRepository) SaveTool(descriptor *tools.ToolDescriptor) error
```

SaveTool saves a tool descriptor \(not yet implemented\)

# middleware

```go
import "github.com/AltairaLabs/PromptKit/runtime/pipeline/middleware"
```

## Index

- [func ContextBuilderMiddleware\(policy \*ContextBuilderPolicy\) pipeline.Middleware](<#ContextBuilderMiddleware>)
- [func ContextExtractionMiddleware\(\) pipeline.Middleware](<#ContextExtractionMiddleware>)
- [func DebugMiddleware\(stage string\) pipeline.Middleware](<#DebugMiddleware>)
- [func DynamicValidatorMiddleware\(registry \*validators.Registry\) pipeline.Middleware](<#DynamicValidatorMiddleware>)
- [func DynamicValidatorMiddlewareWithSuppression\(registry \*validators.Registry, suppressExceptions bool\) pipeline.Middleware](<#DynamicValidatorMiddlewareWithSuppression>)
- [func GetContextMetadata\(execCtx \*pipeline.ExecutionContext\) \(truncated bool, originalCount, truncatedCount int\)](<#GetContextMetadata>)
- [func PromptAssemblyMiddleware\(promptRegistry \*prompt.Registry, taskType string, baseVariables map\[string\]string\) pipeline.Middleware](<#PromptAssemblyMiddleware>)
- [func ProviderMiddleware\(provider providers.Provider, toolRegistry \*tools.Registry, toolPolicy \*pipeline.ToolPolicy, config \*ProviderMiddlewareConfig\) pipeline.Middleware](<#ProviderMiddleware>)
- [func StateStoreLoadMiddleware\(config \*pipeline.StateStoreConfig\) pipeline.Middleware](<#StateStoreLoadMiddleware>)
- [func StateStoreSaveMiddleware\(config \*pipeline.StateStoreConfig\) pipeline.Middleware](<#StateStoreSaveMiddleware>)
- [func TemplateMiddleware\(\) pipeline.Middleware](<#TemplateMiddleware>)
- [type ContextBuilderPolicy](<#ContextBuilderPolicy>)
- [type ProviderMiddlewareConfig](<#ProviderMiddlewareConfig>)
- [type TruncationStrategy](<#TruncationStrategy>)


<a name="ContextBuilderMiddleware"></a>
## func ContextBuilderMiddleware

```go
func ContextBuilderMiddleware(policy *ContextBuilderPolicy) pipeline.Middleware
```

ContextBuilderMiddleware manages conversation context with token budget enforcement This middleware should be placed BEFORE ProviderMiddleware in the pipeline

<a name="ContextExtractionMiddleware"></a>
## func ContextExtractionMiddleware

```go
func ContextExtractionMiddleware() pipeline.Middleware
```



<a name="DebugMiddleware"></a>
## func DebugMiddleware

```go
func DebugMiddleware(stage string) pipeline.Middleware
```

DebugMiddleware creates middleware that logs the full execution context as JSON. The stage parameter identifies where in the pipeline this middleware is placed. You can add this middleware multiple times at different stages to trace state changes.

Example:

```
middleware.DebugMiddleware("after-prompt-assembly"),
middleware.DebugMiddleware("after-provider"),
```

Note: This middleware serializes the entire context to JSON, which can be expensive. Only use in development/debugging scenarios.

<a name="DynamicValidatorMiddleware"></a>
## func DynamicValidatorMiddleware

```go
func DynamicValidatorMiddleware(registry *validators.Registry) pipeline.Middleware
```

DynamicValidatorMiddleware creates middleware that dynamically instantiates validators from configurations stored in ExecutionContext. It uses the validator registry to create validators on\-demand and passes their params from the config.

<a name="DynamicValidatorMiddlewareWithSuppression"></a>
## func DynamicValidatorMiddlewareWithSuppression

```go
func DynamicValidatorMiddlewareWithSuppression(registry *validators.Registry, suppressExceptions bool) pipeline.Middleware
```

DynamicValidatorMiddlewareWithSuppression creates middleware with validation suppression enabled. This is primarily used by test frameworks \(like Arena\) to allow validation failures to be recorded without halting execution, enabling assertions on guardrail behavior.

<a name="GetContextMetadata"></a>
## func GetContextMetadata

```go
func GetContextMetadata(execCtx *pipeline.ExecutionContext) (truncated bool, originalCount, truncatedCount int)
```

GetContextMetadata extracts context truncation metadata from ExecutionContext

<a name="PromptAssemblyMiddleware"></a>
## func PromptAssemblyMiddleware

```go
func PromptAssemblyMiddleware(promptRegistry *prompt.Registry, taskType string, baseVariables map[string]string) pipeline.Middleware
```

PromptAssemblyMiddleware loads and assembles prompts from the prompt registry. It populates execCtx.SystemPrompt, execCtx.AllowedTools, and base variables. This middleware should run BEFORE context extraction and template substitution.

<a name="ProviderMiddleware"></a>
## func ProviderMiddleware

```go
func ProviderMiddleware(provider providers.Provider, toolRegistry *tools.Registry, toolPolicy *pipeline.ToolPolicy, config *ProviderMiddlewareConfig) pipeline.Middleware
```

ProviderMiddleware executes LLM calls and handles tool execution via the ToolRegistry. It supports multi\-round execution when tools are involved. In streaming mode, it forwards chunks to execCtx.StreamOutput.

The provider, toolRegistry, toolPolicy, and configuration are provided at construction time, simplifying the ExecutionContext and avoiding the need to pass Config around.

<a name="StateStoreLoadMiddleware"></a>
## func StateStoreLoadMiddleware

```go
func StateStoreLoadMiddleware(config *pipeline.StateStoreConfig) pipeline.Middleware
```

StateStoreLoadMiddleware loads conversation history from StateStore. It should be placed FIRST in the pipeline, before any other middleware. If the conversation doesn't exist, it starts with an empty history.

<a name="StateStoreSaveMiddleware"></a>
## func StateStoreSaveMiddleware

```go
func StateStoreSaveMiddleware(config *pipeline.StateStoreConfig) pipeline.Middleware
```

StateStoreSaveMiddleware saves conversation state to StateStore. It should be placed LAST in the pipeline, after all other middleware. It saves even if the pipeline execution failed \(to preserve partial state\).

<a name="TemplateMiddleware"></a>
## func TemplateMiddleware

```go
func TemplateMiddleware() pipeline.Middleware
```

TemplateMiddleware substitutes variables in the system prompt. It replaces \{\{variable\}\} placeholders with values from ExecutionContext.Variables.

<a name="ContextBuilderPolicy"></a>
## type ContextBuilderPolicy

ContextBuilderPolicy defines token budget and truncation behavior

```go
type ContextBuilderPolicy struct {
    TokenBudget      int                // Max tokens for context (0 = unlimited)
    ReserveForOutput int                // Reserve tokens for response
    Strategy         TruncationStrategy // How to handle overflow
    CacheBreakpoints bool               // Insert cache markers (Anthropic)
}
```

<a name="ProviderMiddlewareConfig"></a>
## type ProviderMiddlewareConfig

ProviderMiddlewareConfig contains configuration for the provider middleware

```go
type ProviderMiddlewareConfig struct {
    MaxTokens    int
    Temperature  float32
    Seed         *int
    DisableTrace bool // Disable execution tracing (default: false = tracing enabled)
}
```

<a name="TruncationStrategy"></a>
## type TruncationStrategy

TruncationStrategy defines how to handle messages when over token budget

```go
type TruncationStrategy string
```

<a name="TruncateOldest"></a>

```go
const (
    // TruncateOldest drops oldest messages first (simple, preserves recent context)
    TruncateOldest TruncationStrategy = "oldest"

    // TruncateLeastRelevant drops least relevant messages (requires embeddings)
    TruncateLeastRelevant TruncationStrategy = "relevance"

    // TruncateSummarize compresses old messages into summaries
    TruncateSummarize TruncationStrategy = "summarize"

    // TruncateFail returns error if over budget (strict mode)
    TruncateFail TruncationStrategy = "fail"
)
```

# claude

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/claude"
```

## Index

- [type ClaudeProvider](<#ClaudeProvider>)
  - [func NewClaudeProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*ClaudeProvider](<#NewClaudeProvider>)
  - [func \(p \*ClaudeProvider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#ClaudeProvider.CalculateCost>)
  - [func \(p \*ClaudeProvider\) GetMultimodalCapabilities\(\) providers.MultimodalCapabilities](<#ClaudeProvider.GetMultimodalCapabilities>)
  - [func \(p \*ClaudeProvider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#ClaudeProvider.Predict>)
  - [func \(p \*ClaudeProvider\) PredictMultimodal\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#ClaudeProvider.PredictMultimodal>)
  - [func \(p \*ClaudeProvider\) PredictMultimodalStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#ClaudeProvider.PredictMultimodalStream>)
  - [func \(p \*ClaudeProvider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#ClaudeProvider.PredictStream>)
- [type ClaudeToolProvider](<#ClaudeToolProvider>)
  - [func NewClaudeToolProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*ClaudeToolProvider](<#NewClaudeToolProvider>)
  - [func \(p \*ClaudeToolProvider\) BuildTooling\(descriptors \[\]\*providers.ToolDescriptor\) \(interface\{\}, error\)](<#ClaudeToolProvider.BuildTooling>)
  - [func \(p \*ClaudeToolProvider\) PredictWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#ClaudeToolProvider.PredictWithTools>)


<a name="ClaudeProvider"></a>
## type ClaudeProvider

ClaudeProvider implements the Provider interface for Anthropic Claude

```go
type ClaudeProvider struct {
    providers.BaseProvider
    // contains filtered or unexported fields
}
```

<a name="NewClaudeProvider"></a>
### func NewClaudeProvider

```go
func NewClaudeProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *ClaudeProvider
```

NewClaudeProvider creates a new Claude provider

<a name="ClaudeProvider.CalculateCost"></a>
### func \(\*ClaudeProvider\) CalculateCost

```go
func (p *ClaudeProvider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="ClaudeProvider.GetMultimodalCapabilities"></a>
### func \(\*ClaudeProvider\) GetMultimodalCapabilities

```go
func (p *ClaudeProvider) GetMultimodalCapabilities() providers.MultimodalCapabilities
```

GetMultimodalCapabilities returns Claude's multimodal support capabilities

<a name="ClaudeProvider.Predict"></a>
### func \(\*ClaudeProvider\) Predict

```go
func (p *ClaudeProvider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict sends a predict request to Claude

<a name="ClaudeProvider.PredictMultimodal"></a>
### func \(\*ClaudeProvider\) PredictMultimodal

```go
func (p *ClaudeProvider) PredictMultimodal(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

PredictMultimodal sends a multimodal predict request to Claude

<a name="ClaudeProvider.PredictMultimodalStream"></a>
### func \(\*ClaudeProvider\) PredictMultimodalStream

```go
func (p *ClaudeProvider) PredictMultimodalStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictMultimodalStream sends a streaming multimodal predict request to Claude

<a name="ClaudeProvider.PredictStream"></a>
### func \(\*ClaudeProvider\) PredictStream

```go
func (p *ClaudeProvider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream streams a predict response from Claude

<a name="ClaudeToolProvider"></a>
## type ClaudeToolProvider

ClaudeToolProvider extends ClaudeProvider with tool support

```go
type ClaudeToolProvider struct {
    *ClaudeProvider
}
```

<a name="NewClaudeToolProvider"></a>
### func NewClaudeToolProvider

```go
func NewClaudeToolProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *ClaudeToolProvider
```

NewClaudeToolProvider creates a new Claude provider with tool support

<a name="ClaudeToolProvider.BuildTooling"></a>
### func \(\*ClaudeToolProvider\) BuildTooling

```go
func (p *ClaudeToolProvider) BuildTooling(descriptors []*providers.ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to Claude format

<a name="ClaudeToolProvider.PredictWithTools"></a>
### func \(\*ClaudeToolProvider\) PredictWithTools

```go
func (p *ClaudeToolProvider) PredictWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictWithTools performs a predict request with tool support

# gemini

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/gemini"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func ClassifyError\(apiErr \*GeminiAPIError\) error](<#ClassifyError>)
- [type AudioEncoder](<#AudioEncoder>)
  - [func NewAudioEncoder\(\) \*AudioEncoder](<#NewAudioEncoder>)
  - [func NewAudioEncoderWithChunkSize\(chunkSize int\) \(\*AudioEncoder, error\)](<#NewAudioEncoderWithChunkSize>)
  - [func \(e \*AudioEncoder\) AssembleChunks\(chunks \[\]\*types.MediaChunk\) \(\[\]byte, error\)](<#AudioEncoder.AssembleChunks>)
  - [func \(e \*AudioEncoder\) ConvertInt16ToPCM\(samples \[\]int16\) \[\]byte](<#AudioEncoder.ConvertInt16ToPCM>)
  - [func \(e \*AudioEncoder\) ConvertPCMToInt16\(pcmData \[\]byte\) \(\[\]int16, error\)](<#AudioEncoder.ConvertPCMToInt16>)
  - [func \(e \*AudioEncoder\) CreateChunks\(ctx context.Context, pcmData \[\]byte\) \(\[\]\*types.MediaChunk, error\)](<#AudioEncoder.CreateChunks>)
  - [func \(e \*AudioEncoder\) DecodePCM\(base64Data string\) \(\[\]byte, error\)](<#AudioEncoder.DecodePCM>)
  - [func \(e \*AudioEncoder\) EncodePCM\(pcmData \[\]byte\) \(string, error\)](<#AudioEncoder.EncodePCM>)
  - [func \(e \*AudioEncoder\) GenerateSineWave\(frequency float64, durationMs int, amplitude float64\) \[\]byte](<#AudioEncoder.GenerateSineWave>)
  - [func \(e \*AudioEncoder\) GetChunkDurationMs\(chunkSize int\) float64](<#AudioEncoder.GetChunkDurationMs>)
  - [func \(e \*AudioEncoder\) GetChunkSize\(\) int](<#AudioEncoder.GetChunkSize>)
  - [func \(e \*AudioEncoder\) GetSampleRate\(\) int](<#AudioEncoder.GetSampleRate>)
  - [func \(e \*AudioEncoder\) ReadChunks\(ctx context.Context, reader io.Reader\) \(\<\-chan \*types.MediaChunk, \<\-chan error\)](<#AudioEncoder.ReadChunks>)
  - [func \(e \*AudioEncoder\) ValidateConfig\(config \*types.StreamingMediaConfig\) error](<#AudioEncoder.ValidateConfig>)
- [type ErrorResponse](<#ErrorResponse>)
- [type GeminiAPIError](<#GeminiAPIError>)
  - [func \(e \*GeminiAPIError\) Error\(\) string](<#GeminiAPIError.Error>)
  - [func \(e \*GeminiAPIError\) IsAuthError\(\) bool](<#GeminiAPIError.IsAuthError>)
  - [func \(e \*GeminiAPIError\) IsPolicyViolation\(\) bool](<#GeminiAPIError.IsPolicyViolation>)
  - [func \(e \*GeminiAPIError\) IsRetryable\(\) bool](<#GeminiAPIError.IsRetryable>)
- [type GeminiProvider](<#GeminiProvider>)
  - [func NewGeminiProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*GeminiProvider](<#NewGeminiProvider>)
  - [func \(p \*GeminiProvider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#GeminiProvider.CalculateCost>)
  - [func \(p \*GeminiProvider\) CreateStreamSession\(ctx context.Context, req \*providers.StreamInputRequest\) \(providers.StreamInputSession, error\)](<#GeminiProvider.CreateStreamSession>)
  - [func \(p \*GeminiProvider\) GetMultimodalCapabilities\(\) providers.MultimodalCapabilities](<#GeminiProvider.GetMultimodalCapabilities>)
  - [func \(p \*GeminiProvider\) GetStreamingCapabilities\(\) providers.StreamingCapabilities](<#GeminiProvider.GetStreamingCapabilities>)
  - [func \(p \*GeminiProvider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#GeminiProvider.Predict>)
  - [func \(p \*GeminiProvider\) PredictMultimodal\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#GeminiProvider.PredictMultimodal>)
  - [func \(p \*GeminiProvider\) PredictMultimodalStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#GeminiProvider.PredictMultimodalStream>)
  - [func \(p \*GeminiProvider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#GeminiProvider.PredictStream>)
  - [func \(p \*GeminiProvider\) SupportsStreamInput\(\) \[\]string](<#GeminiProvider.SupportsStreamInput>)
- [type GeminiStreamSession](<#GeminiStreamSession>)
  - [func NewGeminiStreamSession\(ctx context.Context, wsURL, apiKey string, config StreamSessionConfig\) \(\*GeminiStreamSession, error\)](<#NewGeminiStreamSession>)
  - [func \(s \*GeminiStreamSession\) Close\(\) error](<#GeminiStreamSession.Close>)
  - [func \(s \*GeminiStreamSession\) CompleteTurn\(ctx context.Context\) error](<#GeminiStreamSession.CompleteTurn>)
  - [func \(s \*GeminiStreamSession\) Done\(\) \<\-chan struct\{\}](<#GeminiStreamSession.Done>)
  - [func \(s \*GeminiStreamSession\) Error\(\) error](<#GeminiStreamSession.Error>)
  - [func \(s \*GeminiStreamSession\) Response\(\) \<\-chan providers.StreamChunk](<#GeminiStreamSession.Response>)
  - [func \(s \*GeminiStreamSession\) SendChunk\(ctx context.Context, chunk \*types.MediaChunk\) error](<#GeminiStreamSession.SendChunk>)
  - [func \(s \*GeminiStreamSession\) SendText\(ctx context.Context, text string\) error](<#GeminiStreamSession.SendText>)
- [type GeminiToolProvider](<#GeminiToolProvider>)
  - [func NewGeminiToolProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*GeminiToolProvider](<#NewGeminiToolProvider>)
  - [func \(p \*GeminiToolProvider\) BuildTooling\(descriptors \[\]\*providers.ToolDescriptor\) \(interface\{\}, error\)](<#GeminiToolProvider.BuildTooling>)
  - [func \(p \*GeminiToolProvider\) PredictWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#GeminiToolProvider.PredictWithTools>)
- [type InlineData](<#InlineData>)
- [type ModelTurn](<#ModelTurn>)
- [type Part](<#Part>)
- [type PromptFeedback](<#PromptFeedback>)
  - [func \(f \*PromptFeedback\) GetBlockReason\(\) string](<#PromptFeedback.GetBlockReason>)
  - [func \(f \*PromptFeedback\) IsBlocked\(\) bool](<#PromptFeedback.IsBlocked>)
- [type RecoveryStrategy](<#RecoveryStrategy>)
  - [func DetermineRecoveryStrategy\(err error\) RecoveryStrategy](<#DetermineRecoveryStrategy>)
- [type SafetyRating](<#SafetyRating>)
- [type ServerContent](<#ServerContent>)
- [type ServerMessage](<#ServerMessage>)
  - [func \(s \*ServerMessage\) UnmarshalJSON\(data \[\]byte\) error](<#ServerMessage.UnmarshalJSON>)
- [type SetupComplete](<#SetupComplete>)
- [type StreamSessionConfig](<#StreamSessionConfig>)
- [type WebSocketManager](<#WebSocketManager>)
  - [func NewWebSocketManager\(url, apiKey string\) \*WebSocketManager](<#NewWebSocketManager>)
  - [func \(wm \*WebSocketManager\) Close\(\) error](<#WebSocketManager.Close>)
  - [func \(wm \*WebSocketManager\) Connect\(ctx context.Context\) error](<#WebSocketManager.Connect>)
  - [func \(wm \*WebSocketManager\) ConnectWithRetry\(ctx context.Context\) error](<#WebSocketManager.ConnectWithRetry>)
  - [func \(wm \*WebSocketManager\) IsConnected\(\) bool](<#WebSocketManager.IsConnected>)
  - [func \(wm \*WebSocketManager\) Receive\(ctx context.Context, v interface\{\}\) error](<#WebSocketManager.Receive>)
  - [func \(wm \*WebSocketManager\) Send\(msg interface\{\}\) error](<#WebSocketManager.Send>)
  - [func \(wm \*WebSocketManager\) SendPing\(\) error](<#WebSocketManager.SendPing>)
  - [func \(wm \*WebSocketManager\) StartHeartbeat\(ctx context.Context, interval time.Duration\)](<#WebSocketManager.StartHeartbeat>)


## Constants

<a name="DefaultChunkDuration"></a>

```go
const (

    // DefaultChunkDuration is 100ms of audio
    DefaultChunkDuration = 100 // milliseconds
    // DefaultChunkSize is the number of bytes for 100ms at 16kHz 16-bit mono
    // 16000 Hz * 0.1 sec * 2 bytes/sample = 3200 bytes
    DefaultChunkSize = (geminiSampleRate * DefaultChunkDuration / 1000) * bytesPerSample
)
```

<a name="ErrNotConnected"></a>Common error messages

```go
const (
    ErrNotConnected  = "not connected"
    ErrManagerClosed = "manager is closed"
)
```

<a name="ErrSessionClosed"></a>Common error messages

```go
const (
    ErrSessionClosed = "session is closed"
)
```

## Variables

<a name="ErrInvalidSampleRate"></a>

```go
var (
    // ErrInvalidSampleRate indicates an unsupported sample rate
    ErrInvalidSampleRate = errors.New("invalid sample rate: must be 16000 Hz")
    // ErrInvalidChannels indicates an unsupported channel count
    ErrInvalidChannels = errors.New("invalid channels: must be mono (1 channel)")
    // ErrInvalidBitDepth indicates an unsupported bit depth
    ErrInvalidBitDepth = errors.New("invalid bit depth: must be 16 bits")
    // ErrInvalidChunkSize indicates chunk size is not aligned
    ErrInvalidChunkSize = errors.New("invalid chunk size: must be multiple of sample size")
    // ErrEmptyAudioData indicates no audio data provided
    ErrEmptyAudioData = errors.New("empty audio data")
)
```

<a name="ErrInvalidAudioFormat"></a>Common errors for Gemini streaming

```go
var (
    // ErrInvalidAudioFormat indicates audio format doesn't meet Gemini requirements
    ErrInvalidAudioFormat = errors.New("invalid audio format")

    // ErrRateLimitExceeded indicates too many requests
    ErrRateLimitExceeded = errors.New("rate limit exceeded")

    // ErrAuthenticationFailed indicates invalid API key
    ErrAuthenticationFailed = errors.New("authentication failed")

    // ErrServiceUnavailable indicates temporary service issue
    ErrServiceUnavailable = errors.New("service unavailable")

    // ErrPolicyViolation indicates content policy violation
    ErrPolicyViolation = errors.New("policy violation")

    // ErrInvalidRequest indicates malformed request
    ErrInvalidRequest = errors.New("invalid request")
)
```

<a name="ClassifyError"></a>
## func ClassifyError

```go
func ClassifyError(apiErr *GeminiAPIError) error
```

ClassifyError converts an API error code to a standard error

<a name="AudioEncoder"></a>
## type AudioEncoder

AudioEncoder handles PCM Linear16 audio encoding for Gemini Live API

```go
type AudioEncoder struct {
    // contains filtered or unexported fields
}
```

<a name="NewAudioEncoder"></a>
### func NewAudioEncoder

```go
func NewAudioEncoder() *AudioEncoder
```

NewAudioEncoder creates a new audio encoder with Gemini Live API specifications

<a name="NewAudioEncoderWithChunkSize"></a>
### func NewAudioEncoderWithChunkSize

```go
func NewAudioEncoderWithChunkSize(chunkSize int) (*AudioEncoder, error)
```

NewAudioEncoderWithChunkSize creates an encoder with custom chunk size

<a name="AudioEncoder.AssembleChunks"></a>
### func \(\*AudioEncoder\) AssembleChunks

```go
func (e *AudioEncoder) AssembleChunks(chunks []*types.MediaChunk) ([]byte, error)
```



<a name="AudioEncoder.ConvertInt16ToPCM"></a>
### func \(\*AudioEncoder\) ConvertInt16ToPCM

```go
func (e *AudioEncoder) ConvertInt16ToPCM(samples []int16) []byte
```

ConvertInt16ToPCM converts \[\]int16 samples to PCM bytes \(little\-endian\)

<a name="AudioEncoder.ConvertPCMToInt16"></a>
### func \(\*AudioEncoder\) ConvertPCMToInt16

```go
func (e *AudioEncoder) ConvertPCMToInt16(pcmData []byte) ([]int16, error)
```

ConvertPCMToInt16 converts PCM bytes to \[\]int16 samples \(little\-endian\)

<a name="AudioEncoder.CreateChunks"></a>
### func \(\*AudioEncoder\) CreateChunks

```go
func (e *AudioEncoder) CreateChunks(ctx context.Context, pcmData []byte) ([]*types.MediaChunk, error)
```

CreateChunks splits PCM audio data into appropriately sized chunks

<a name="AudioEncoder.DecodePCM"></a>
### func \(\*AudioEncoder\) DecodePCM

```go
func (e *AudioEncoder) DecodePCM(base64Data string) ([]byte, error)
```

DecodePCM decodes base64\-encoded audio data back to raw PCM

<a name="AudioEncoder.EncodePCM"></a>
### func \(\*AudioEncoder\) EncodePCM

```go
func (e *AudioEncoder) EncodePCM(pcmData []byte) (string, error)
```

EncodePCM encodes raw PCM audio data to base64 for WebSocket transmission

<a name="AudioEncoder.GenerateSineWave"></a>
### func \(\*AudioEncoder\) GenerateSineWave

```go
func (e *AudioEncoder) GenerateSineWave(frequency float64, durationMs int, amplitude float64) []byte
```

GenerateSineWave generates PCM audio for a sine wave \(useful for testing\)

<a name="AudioEncoder.GetChunkDurationMs"></a>
### func \(\*AudioEncoder\) GetChunkDurationMs

```go
func (e *AudioEncoder) GetChunkDurationMs(chunkSize int) float64
```

GetChunkDurationMs calculates the duration of a chunk in milliseconds

<a name="AudioEncoder.GetChunkSize"></a>
### func \(\*AudioEncoder\) GetChunkSize

```go
func (e *AudioEncoder) GetChunkSize() int
```

GetChunkSize returns the configured chunk size in bytes

<a name="AudioEncoder.GetSampleRate"></a>
### func \(\*AudioEncoder\) GetSampleRate

```go
func (e *AudioEncoder) GetSampleRate() int
```

GetSampleRate returns the configured sample rate

<a name="AudioEncoder.ReadChunks"></a>
### func \(\*AudioEncoder\) ReadChunks

```go
func (e *AudioEncoder) ReadChunks(ctx context.Context, reader io.Reader) (<-chan *types.MediaChunk, <-chan error)
```

ReadChunks reads audio from an io.Reader and creates chunks on\-the\-fly

<a name="AudioEncoder.ValidateConfig"></a>
### func \(\*AudioEncoder\) ValidateConfig

```go
func (e *AudioEncoder) ValidateConfig(config *types.StreamingMediaConfig) error
```

ValidateConfig validates audio configuration against Gemini requirements

<a name="ErrorResponse"></a>
## type ErrorResponse

ErrorResponse wraps a GeminiAPIError in a message format

```go
type ErrorResponse struct {
    Error *GeminiAPIError `json:"error"`
}
```

<a name="GeminiAPIError"></a>
## type GeminiAPIError

GeminiAPIError represents an error from the Gemini API

```go
type GeminiAPIError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Status  string `json:"status"`
}
```

<a name="GeminiAPIError.Error"></a>
### func \(\*GeminiAPIError\) Error

```go
func (e *GeminiAPIError) Error() string
```

Error implements the error interface

<a name="GeminiAPIError.IsAuthError"></a>
### func \(\*GeminiAPIError\) IsAuthError

```go
func (e *GeminiAPIError) IsAuthError() bool
```

IsAuthError returns true if the error is authentication\-related

<a name="GeminiAPIError.IsPolicyViolation"></a>
### func \(\*GeminiAPIError\) IsPolicyViolation

```go
func (e *GeminiAPIError) IsPolicyViolation() bool
```

IsPolicyViolation returns true if the error is a content policy violation

<a name="GeminiAPIError.IsRetryable"></a>
### func \(\*GeminiAPIError\) IsRetryable

```go
func (e *GeminiAPIError) IsRetryable() bool
```

IsRetryable returns true if the error can be retried

<a name="GeminiProvider"></a>
## type GeminiProvider

GeminiProvider implements the Provider interface for Google Gemini

```go
type GeminiProvider struct {
    providers.BaseProvider
    Model    string
    BaseURL  string
    ApiKey   string
    Defaults providers.ProviderDefaults
}
```

<a name="NewGeminiProvider"></a>
### func NewGeminiProvider

```go
func NewGeminiProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *GeminiProvider
```

NewGeminiProvider creates a new Gemini provider

<a name="GeminiProvider.CalculateCost"></a>
### func \(\*GeminiProvider\) CalculateCost

```go
func (p *GeminiProvider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="GeminiProvider.CreateStreamSession"></a>
### func \(\*GeminiProvider\) CreateStreamSession

```go
func (p *GeminiProvider) CreateStreamSession(ctx context.Context, req *providers.StreamInputRequest) (providers.StreamInputSession, error)
```

CreateStreamSession creates a new bidirectional streaming session with Gemini Live API

Response Modalities: By default, the session is configured to return TEXT responses only. To request audio responses, pass "response\_modalities" in the request metadata:

```
req := providers.StreamInputRequest{
    Config: config,
    Metadata: map[string]interface{}{
        "response_modalities": []string{"AUDIO"},        // Audio only
        // OR
        "response_modalities": []string{"TEXT", "AUDIO"}, // Both text and audio
    },
}
```

Audio responses will be delivered in the StreamChunk.Metadata\["audio\_data"\] field as base64\-encoded PCM.

<a name="GeminiProvider.GetMultimodalCapabilities"></a>
### func \(\*GeminiProvider\) GetMultimodalCapabilities

```go
func (p *GeminiProvider) GetMultimodalCapabilities() providers.MultimodalCapabilities
```

GetMultimodalCapabilities returns Gemini's multimodal support capabilities

<a name="GeminiProvider.GetStreamingCapabilities"></a>
### func \(\*GeminiProvider\) GetStreamingCapabilities

```go
func (p *GeminiProvider) GetStreamingCapabilities() providers.StreamingCapabilities
```

GetStreamingCapabilities returns detailed information about Gemini's streaming support

<a name="GeminiProvider.Predict"></a>
### func \(\*GeminiProvider\) Predict

```go
func (p *GeminiProvider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict sends a predict request to Gemini

<a name="GeminiProvider.PredictMultimodal"></a>
### func \(\*GeminiProvider\) PredictMultimodal

```go
func (p *GeminiProvider) PredictMultimodal(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

PredictMultimodal performs a predict request with multimodal content

<a name="GeminiProvider.PredictMultimodalStream"></a>
### func \(\*GeminiProvider\) PredictMultimodalStream

```go
func (p *GeminiProvider) PredictMultimodalStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictMultimodalStream performs a streaming predict request with multimodal content

<a name="GeminiProvider.PredictStream"></a>
### func \(\*GeminiProvider\) PredictStream

```go
func (p *GeminiProvider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream streams a predict response from Gemini

<a name="GeminiProvider.SupportsStreamInput"></a>
### func \(\*GeminiProvider\) SupportsStreamInput

```go
func (p *GeminiProvider) SupportsStreamInput() []string
```

SupportsStreamInput returns the media types supported for streaming input

<a name="GeminiStreamSession"></a>
## type GeminiStreamSession

GeminiStreamSession implements StreamInputSession for Gemini Live API

```go
type GeminiStreamSession struct {
    // contains filtered or unexported fields
}
```

<a name="NewGeminiStreamSession"></a>
### func NewGeminiStreamSession

```go
func NewGeminiStreamSession(ctx context.Context, wsURL, apiKey string, config StreamSessionConfig) (*GeminiStreamSession, error)
```

NewGeminiStreamSession creates a new streaming session

<a name="GeminiStreamSession.Close"></a>
### func \(\*GeminiStreamSession\) Close

```go
func (s *GeminiStreamSession) Close() error
```

Close closes the session

<a name="GeminiStreamSession.CompleteTurn"></a>
### func \(\*GeminiStreamSession\) CompleteTurn

```go
func (s *GeminiStreamSession) CompleteTurn(ctx context.Context) error
```

CompleteTurn signals that the current turn is complete

<a name="GeminiStreamSession.Done"></a>
### func \(\*GeminiStreamSession\) Done

```go
func (s *GeminiStreamSession) Done() <-chan struct{}
```

Done returns a channel that's closed when the session ends

<a name="GeminiStreamSession.Error"></a>
### func \(\*GeminiStreamSession\) Error

```go
func (s *GeminiStreamSession) Error() error
```

Err returns the error that caused the session to close

<a name="GeminiStreamSession.Response"></a>
### func \(\*GeminiStreamSession\) Response

```go
func (s *GeminiStreamSession) Response() <-chan providers.StreamChunk
```

Response returns the channel for receiving responses

<a name="GeminiStreamSession.SendChunk"></a>
### func \(\*GeminiStreamSession\) SendChunk

```go
func (s *GeminiStreamSession) SendChunk(ctx context.Context, chunk *types.MediaChunk) error
```

SendChunk sends a media chunk to the server

<a name="GeminiStreamSession.SendText"></a>
### func \(\*GeminiStreamSession\) SendText

```go
func (s *GeminiStreamSession) SendText(ctx context.Context, text string) error
```

SendText sends a text message to the server and marks the turn as complete

<a name="GeminiToolProvider"></a>
## type GeminiToolProvider

GeminiToolProvider extends GeminiProvider with tool support

```go
type GeminiToolProvider struct {
    *GeminiProvider
    // contains filtered or unexported fields
}
```

<a name="NewGeminiToolProvider"></a>
### func NewGeminiToolProvider

```go
func NewGeminiToolProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *GeminiToolProvider
```

NewGeminiToolProvider creates a new Gemini provider with tool support

<a name="GeminiToolProvider.BuildTooling"></a>
### func \(\*GeminiToolProvider\) BuildTooling

```go
func (p *GeminiToolProvider) BuildTooling(descriptors []*providers.ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to Gemini format

<a name="GeminiToolProvider.PredictWithTools"></a>
### func \(\*GeminiToolProvider\) PredictWithTools

```go
func (p *GeminiToolProvider) PredictWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictWithTools performs a predict request with tool support

<a name="InlineData"></a>
## type InlineData

InlineData represents inline media data

```go
type InlineData struct {
    MimeType string `json:"mimeType,omitempty"` // camelCase!
    Data     string `json:"data,omitempty"`     // Base64 encoded
}
```

<a name="ModelTurn"></a>
## type ModelTurn

ModelTurn represents a model response turn

```go
type ModelTurn struct {
    Parts []Part `json:"parts,omitempty"`
}
```

<a name="Part"></a>
## type Part

Part represents a content part \(text or inline data\)

```go
type Part struct {
    Text       string      `json:"text,omitempty"`
    InlineData *InlineData `json:"inlineData,omitempty"` // camelCase!
}
```

<a name="PromptFeedback"></a>
## type PromptFeedback

PromptFeedback contains safety ratings and block reason

```go
type PromptFeedback struct {
    SafetyRatings []SafetyRating `json:"safetyRatings,omitempty"`
    BlockReason   string         `json:"blockReason,omitempty"`
}
```

<a name="PromptFeedback.GetBlockReason"></a>
### func \(\*PromptFeedback\) GetBlockReason

```go
func (f *PromptFeedback) GetBlockReason() string
```

GetBlockReason returns a human\-readable block reason

<a name="PromptFeedback.IsBlocked"></a>
### func \(\*PromptFeedback\) IsBlocked

```go
func (f *PromptFeedback) IsBlocked() bool
```

IsBlocked returns true if content was blocked by safety filters

<a name="RecoveryStrategy"></a>
## type RecoveryStrategy

RecoveryStrategy defines how to handle different error types

```go
type RecoveryStrategy int
```

<a name="RecoveryRetry"></a>

```go
const (
    // RecoveryRetry indicates the operation should be retried
    RecoveryRetry RecoveryStrategy = iota

    // RecoveryFailFast indicates the operation should fail immediately
    RecoveryFailFast

    // RecoveryGracefulDegradation indicates fallback to a simpler mode
    RecoveryGracefulDegradation

    // RecoveryWaitAndRetry indicates retry after a delay
    RecoveryWaitAndRetry
)
```

<a name="DetermineRecoveryStrategy"></a>
### func DetermineRecoveryStrategy

```go
func DetermineRecoveryStrategy(err error) RecoveryStrategy
```

DetermineRecoveryStrategy determines how to handle an error

<a name="SafetyRating"></a>
## type SafetyRating

SafetyRating represents content safety assessment

```go
type SafetyRating struct {
    Category    string `json:"category"`
    Probability string `json:"probability"`
}
```

<a name="ServerContent"></a>
## type ServerContent

ServerContent represents the server content

```go
type ServerContent struct {
    ModelTurn    *ModelTurn `json:"modelTurn,omitempty"`
    TurnComplete bool       `json:"turnComplete,omitempty"`
    Interrupted  bool       `json:"interrupted,omitempty"`
}
```

<a name="ServerMessage"></a>
## type ServerMessage

ServerMessage represents a message from the Gemini server

```go
type ServerMessage struct {
    SetupComplete *SetupComplete `json:"setupComplete,omitempty"`
    ServerContent *ServerContent `json:"serverContent,omitempty"`
}
```

<a name="ServerMessage.UnmarshalJSON"></a>
### func \(\*ServerMessage\) UnmarshalJSON

```go
func (s *ServerMessage) UnmarshalJSON(data []byte) error
```

Marshal methods for easier JSON serialization

<a name="SetupComplete"></a>
## type SetupComplete

SetupComplete indicates setup is complete \(empty object per docs\)

```go
type SetupComplete struct{}
```

<a name="StreamSessionConfig"></a>
## type StreamSessionConfig

StreamSessionConfig configures a streaming session

```go
type StreamSessionConfig struct {
    Model              string   // Model name (will be prefixed with "models/" automatically)
    ResponseModalities []string // "TEXT" and/or "AUDIO"
}
```

<a name="WebSocketManager"></a>
## type WebSocketManager

WebSocketManager manages a WebSocket connection with reconnection logic.

```go
type WebSocketManager struct {
    // contains filtered or unexported fields
}
```

<a name="NewWebSocketManager"></a>
### func NewWebSocketManager

```go
func NewWebSocketManager(url, apiKey string) *WebSocketManager
```

NewWebSocketManager creates a new WebSocket manager

<a name="WebSocketManager.Close"></a>
### func \(\*WebSocketManager\) Close

```go
func (wm *WebSocketManager) Close() error
```

Close gracefully closes the WebSocket connection

<a name="WebSocketManager.Connect"></a>
### func \(\*WebSocketManager\) Connect

```go
func (wm *WebSocketManager) Connect(ctx context.Context) error
```

Connect establishes a WebSocket connection to the Gemini Live API

<a name="WebSocketManager.ConnectWithRetry"></a>
### func \(\*WebSocketManager\) ConnectWithRetry

```go
func (wm *WebSocketManager) ConnectWithRetry(ctx context.Context) error
```

ConnectWithRetry connects with exponential backoff retry logic

<a name="WebSocketManager.IsConnected"></a>
### func \(\*WebSocketManager\) IsConnected

```go
func (wm *WebSocketManager) IsConnected() bool
```

IsConnected returns true if the WebSocket is connected

<a name="WebSocketManager.Receive"></a>
### func \(\*WebSocketManager\) Receive

```go
func (wm *WebSocketManager) Receive(ctx context.Context, v interface{}) error
```

Receive reads a message from the WebSocket

<a name="WebSocketManager.Send"></a>
### func \(\*WebSocketManager\) Send

```go
func (wm *WebSocketManager) Send(msg interface{}) error
```

Send sends a message through the WebSocket

<a name="WebSocketManager.SendPing"></a>
### func \(\*WebSocketManager\) SendPing

```go
func (wm *WebSocketManager) SendPing() error
```

SendPing sends a WebSocket ping to keep the connection alive

<a name="WebSocketManager.StartHeartbeat"></a>
### func \(\*WebSocketManager\) StartHeartbeat

```go
func (wm *WebSocketManager) StartHeartbeat(ctx context.Context, interval time.Duration)
```

StartHeartbeat starts a goroutine that sends periodic pings

# imagen

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/imagen"
```

## Index

- [type ImagenConfig](<#ImagenConfig>)
- [type ImagenProvider](<#ImagenProvider>)
  - [func NewImagenProvider\(config ImagenConfig\) \*ImagenProvider](<#NewImagenProvider>)
  - [func \(p \*ImagenProvider\) CalculateCost\(inputTokens, outputTokens, cachedTokens int\) types.CostInfo](<#ImagenProvider.CalculateCost>)
  - [func \(p \*ImagenProvider\) Close\(\) error](<#ImagenProvider.Close>)
  - [func \(p \*ImagenProvider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#ImagenProvider.Predict>)
  - [func \(p \*ImagenProvider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#ImagenProvider.PredictStream>)
  - [func \(p \*ImagenProvider\) SupportsStreaming\(\) bool](<#ImagenProvider.SupportsStreaming>)


<a name="ImagenConfig"></a>
## type ImagenConfig

ImagenConfig holds configuration for creating an Imagen provider

```go
type ImagenConfig struct {
    ID               string
    Model            string
    BaseURL          string
    ApiKey           string
    ProjectID        string
    Location         string
    IncludeRawOutput bool
    Defaults         providers.ProviderDefaults
}
```

<a name="ImagenProvider"></a>
## type ImagenProvider

ImagenProvider implements the Provider interface for Google's Imagen image generation

```go
type ImagenProvider struct {
    providers.BaseProvider
    Model      string
    BaseURL    string
    ApiKey     string
    ProjectID  string
    Location   string
    Defaults   providers.ProviderDefaults
    HTTPClient *http.Client
}
```

<a name="NewImagenProvider"></a>
### func NewImagenProvider

```go
func NewImagenProvider(config ImagenConfig) *ImagenProvider
```

NewImagenProvider creates a new Imagen provider

<a name="ImagenProvider.CalculateCost"></a>
### func \(\*ImagenProvider\) CalculateCost

```go
func (p *ImagenProvider) CalculateCost(inputTokens, outputTokens, cachedTokens int) types.CostInfo
```

CalculateCost calculates cost breakdown \(simplified for Imagen\)

<a name="ImagenProvider.Close"></a>
### func \(\*ImagenProvider\) Close

```go
func (p *ImagenProvider) Close() error
```

Close cleans up resources

<a name="ImagenProvider.Predict"></a>
### func \(\*ImagenProvider\) Predict

```go
func (p *ImagenProvider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict generates images based on the last user message

<a name="ImagenProvider.PredictStream"></a>
### func \(\*ImagenProvider\) PredictStream

```go
func (p *ImagenProvider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream is not supported for image generation

<a name="ImagenProvider.SupportsStreaming"></a>
### func \(\*ImagenProvider\) SupportsStreaming

```go
func (p *ImagenProvider) SupportsStreaming() bool
```

SupportsStreaming returns false for Imagen

# mock

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/mock"
```

## Index

- [type FileMockRepository](<#FileMockRepository>)
  - [func NewFileMockRepository\(configPath string\) \(\*FileMockRepository, error\)](<#NewFileMockRepository>)
  - [func \(r \*FileMockRepository\) GetResponse\(ctx context.Context, params MockResponseParams\) \(string, error\)](<#FileMockRepository.GetResponse>)
  - [func \(r \*FileMockRepository\) GetTurn\(ctx context.Context, params MockResponseParams\) \(\*MockTurn, error\)](<#FileMockRepository.GetTurn>)
- [type InMemoryMockRepository](<#InMemoryMockRepository>)
  - [func NewInMemoryMockRepository\(defaultResponse string\) \*InMemoryMockRepository](<#NewInMemoryMockRepository>)
  - [func \(r \*InMemoryMockRepository\) GetResponse\(ctx context.Context, params MockResponseParams\) \(string, error\)](<#InMemoryMockRepository.GetResponse>)
  - [func \(r \*InMemoryMockRepository\) GetTurn\(ctx context.Context, params MockResponseParams\) \(\*MockTurn, error\)](<#InMemoryMockRepository.GetTurn>)
  - [func \(r \*InMemoryMockRepository\) SetResponse\(scenarioID string, turnNumber int, response string\)](<#InMemoryMockRepository.SetResponse>)
- [type MockAudioURL](<#MockAudioURL>)
- [type MockConfig](<#MockConfig>)
- [type MockContentPart](<#MockContentPart>)
  - [func \(m \*MockContentPart\) ToContentPart\(\) \*types.ContentPart](<#MockContentPart.ToContentPart>)
- [type MockImageURL](<#MockImageURL>)
- [type MockProvider](<#MockProvider>)
  - [func NewMockProvider\(id, model string, includeRawOutput bool\) \*MockProvider](<#NewMockProvider>)
  - [func NewMockProviderWithRepository\(id, model string, includeRawOutput bool, repo MockResponseRepository\) \*MockProvider](<#NewMockProviderWithRepository>)
  - [func \(m \*MockProvider\) CalculateCost\(inputTokens, outputTokens, cachedTokens int\) types.CostInfo](<#MockProvider.CalculateCost>)
  - [func \(m \*MockProvider\) Close\(\) error](<#MockProvider.Close>)
  - [func \(m \*MockProvider\) ID\(\) string](<#MockProvider.ID>)
  - [func \(m \*MockProvider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#MockProvider.Predict>)
  - [func \(m \*MockProvider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#MockProvider.PredictStream>)
  - [func \(m \*MockProvider\) ShouldIncludeRawOutput\(\) bool](<#MockProvider.ShouldIncludeRawOutput>)
  - [func \(m \*MockProvider\) SupportsStreaming\(\) bool](<#MockProvider.SupportsStreaming>)
- [type MockResponseParams](<#MockResponseParams>)
- [type MockResponseRepository](<#MockResponseRepository>)
- [type MockToolCall](<#MockToolCall>)
- [type MockToolError](<#MockToolError>)
- [type MockToolProvider](<#MockToolProvider>)
  - [func NewMockToolProvider\(id, model string, includeRawOutput bool, additionalConfig map\[string\]interface\{\}\) \*MockToolProvider](<#NewMockToolProvider>)
  - [func NewMockToolProviderWithRepository\(id, model string, includeRawOutput bool, repo MockResponseRepository\) \*MockToolProvider](<#NewMockToolProviderWithRepository>)
  - [func \(m \*MockToolProvider\) BuildTooling\(descriptors \[\]\*providers.ToolDescriptor\) \(interface\{\}, error\)](<#MockToolProvider.BuildTooling>)
  - [func \(m \*MockToolProvider\) PredictWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#MockToolProvider.PredictWithTools>)
- [type MockToolResponse](<#MockToolResponse>)
- [type MockTurn](<#MockTurn>)
  - [func \(t \*MockTurn\) ToContentParts\(\) \[\]types.ContentPart](<#MockTurn.ToContentParts>)
- [type MockVideoURL](<#MockVideoURL>)
- [type ScenarioMockConfig](<#ScenarioMockConfig>)


<a name="FileMockRepository"></a>
## type FileMockRepository

FileMockRepository loads mock responses from a YAML configuration file. This is the default implementation for file\-based mock configurations.

```go
type FileMockRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewFileMockRepository"></a>
### func NewFileMockRepository

```go
func NewFileMockRepository(configPath string) (*FileMockRepository, error)
```

NewFileMockRepository creates a repository that loads mock responses from a YAML file. The file should follow the MockConfig structure with scenarios and turn\-specific responses.

<a name="FileMockRepository.GetResponse"></a>
### func \(\*FileMockRepository\) GetResponse

```go
func (r *FileMockRepository) GetResponse(ctx context.Context, params MockResponseParams) (string, error)
```

GetResponse retrieves a mock response based on the provided parameters. It follows this priority order: 1. Scenario \+ Turn specific response 2. Scenario default response 3. Global default response 4. Generic fallback message

<a name="FileMockRepository.GetTurn"></a>
### func \(\*FileMockRepository\) GetTurn

```go
func (r *FileMockRepository) GetTurn(ctx context.Context, params MockResponseParams) (*MockTurn, error)
```

GetTurn retrieves a structured mock turn response that may include tool calls. This method supports both backward\-compatible string responses and new structured MockTurn responses.

<a name="InMemoryMockRepository"></a>
## type InMemoryMockRepository

InMemoryMockRepository stores mock responses in memory. This is useful for testing and programmatic configuration without files.

```go
type InMemoryMockRepository struct {
    // contains filtered or unexported fields
}
```

<a name="NewInMemoryMockRepository"></a>
### func NewInMemoryMockRepository

```go
func NewInMemoryMockRepository(defaultResponse string) *InMemoryMockRepository
```

NewInMemoryMockRepository creates an in\-memory repository with a default response.

<a name="InMemoryMockRepository.GetResponse"></a>
### func \(\*InMemoryMockRepository\) GetResponse

```go
func (r *InMemoryMockRepository) GetResponse(ctx context.Context, params MockResponseParams) (string, error)
```

GetResponse retrieves a mock response based on the provided parameters.

<a name="InMemoryMockRepository.GetTurn"></a>
### func \(\*InMemoryMockRepository\) GetTurn

```go
func (r *InMemoryMockRepository) GetTurn(ctx context.Context, params MockResponseParams) (*MockTurn, error)
```

GetTurn retrieves a structured mock turn response. InMemoryMockRepository currently only supports simple text responses.

<a name="InMemoryMockRepository.SetResponse"></a>
### func \(\*InMemoryMockRepository\) SetResponse

```go
func (r *InMemoryMockRepository) SetResponse(scenarioID string, turnNumber int, response string)
```

SetResponse sets a mock response for a specific scenario and turn. Use turnNumber = 0 for scenario default, or \-1 for global default.

<a name="MockAudioURL"></a>
## type MockAudioURL

MockAudioURL represents audio content in a mock response.

```go
type MockAudioURL struct {
    URL string `yaml:"url"` // URL to the audio file (can be mock://, http://, https://, data:, or file path)
}
```

<a name="MockConfig"></a>
## type MockConfig

MockConfig represents the structure of a mock configuration file. This allows scenario\-specific and turn\-specific responses to be defined.

```go
type MockConfig struct {
    // Default response if no specific match is found
    DefaultResponse string `yaml:"defaultResponse"`

    // Scenario-specific responses keyed by scenario ID
    Scenarios map[string]ScenarioMockConfig `yaml:"scenarios,omitempty"`
}
```

<a name="MockContentPart"></a>
## type MockContentPart

MockContentPart represents a single content part in a multimodal mock response. This mirrors the structure of types.ContentPart but with YAML\-friendly field names.

```go
type MockContentPart struct {
    Type     string                 `yaml:"type"`                // "text", "image", "audio", or "video"
    Text     string                 `yaml:"text,omitempty"`      // Text content (for type="text")
    ImageURL *MockImageURL          `yaml:"image_url,omitempty"` // Image URL (for type="image")
    AudioURL *MockAudioURL          `yaml:"audio_url,omitempty"` // Audio URL (for type="audio")
    VideoURL *MockVideoURL          `yaml:"video_url,omitempty"` // Video URL (for type="video")
    Metadata map[string]interface{} `yaml:"metadata,omitempty"`  // Additional metadata
}
```

<a name="MockContentPart.ToContentPart"></a>
### func \(\*MockContentPart\) ToContentPart

```go
func (m *MockContentPart) ToContentPart() *types.ContentPart
```

ToContentPart converts a MockContentPart to types.ContentPart.

<a name="MockImageURL"></a>
## type MockImageURL

MockImageURL represents image content in a mock response.

```go
type MockImageURL struct {
    URL    string  `yaml:"url"`              // URL to the image (can be mock://, http://, https://, data:, or file path)
    Detail *string `yaml:"detail,omitempty"` // Detail level: "low", "high", "auto"
}
```

<a name="MockProvider"></a>
## type MockProvider

MockProvider is a provider implementation for testing and development. It returns mock responses without making any API calls, using a repository pattern to source responses from various backends \(files, memory, databases\).

MockProvider is designed to be reusable across different contexts:

- Arena testing: scenario and turn\-specific responses
- SDK examples: simple deterministic responses
- Unit tests: programmatic response configuration

```go
type MockProvider struct {
    // contains filtered or unexported fields
}
```

<a name="NewMockProvider"></a>
### func NewMockProvider

```go
func NewMockProvider(id, model string, includeRawOutput bool) *MockProvider
```

NewMockProvider creates a new mock provider with default in\-memory responses. This constructor maintains backward compatibility with existing code.

<a name="NewMockProviderWithRepository"></a>
### func NewMockProviderWithRepository

```go
func NewMockProviderWithRepository(id, model string, includeRawOutput bool, repo MockResponseRepository) *MockProvider
```

NewMockProviderWithRepository creates a mock provider with a custom response repository. This allows for advanced scenarios like file\-based or database\-backed mock responses.

<a name="MockProvider.CalculateCost"></a>
### func \(\*MockProvider\) CalculateCost

```go
func (m *MockProvider) CalculateCost(inputTokens, outputTokens, cachedTokens int) types.CostInfo
```

CalculateCost calculates cost breakdown for given token counts.

<a name="MockProvider.Close"></a>
### func \(\*MockProvider\) Close

```go
func (m *MockProvider) Close() error
```

Close is a no\-op for the mock provider.

<a name="MockProvider.ID"></a>
### func \(\*MockProvider\) ID

```go
func (m *MockProvider) ID() string
```

ID returns the provider ID.

<a name="MockProvider.Predict"></a>
### func \(\*MockProvider\) Predict

```go
func (m *MockProvider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict returns a mock response using the configured repository.

<a name="MockProvider.PredictStream"></a>
### func \(\*MockProvider\) PredictStream

```go
func (m *MockProvider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream returns a mock streaming response using the configured repository.

<a name="MockProvider.ShouldIncludeRawOutput"></a>
### func \(\*MockProvider\) ShouldIncludeRawOutput

```go
func (m *MockProvider) ShouldIncludeRawOutput() bool
```

ShouldIncludeRawOutput returns whether raw API responses should be included.

<a name="MockProvider.SupportsStreaming"></a>
### func \(\*MockProvider\) SupportsStreaming

```go
func (m *MockProvider) SupportsStreaming() bool
```

SupportsStreaming indicates whether the provider supports streaming.

<a name="MockResponseParams"></a>
## type MockResponseParams

MockResponseParams contains parameters for looking up mock responses. Different implementations may use different subsets of these fields.

```go
type MockResponseParams struct {
    ScenarioID string // Optional: ID of the scenario being executed
    TurnNumber int    // Optional: Turn number in a multi-turn conversation
    ProviderID string // Optional: ID of the provider being mocked
    ModelName  string // Optional: Model name being mocked
}
```

<a name="MockResponseRepository"></a>
## type MockResponseRepository

MockResponseRepository provides an interface for retrieving mock responses. This abstraction allows mock data to come from various sources \(files, databases, etc.\) and makes MockProvider reusable across different contexts \(Arena, SDK examples, unit tests\).

```go
type MockResponseRepository interface {
    // GetResponse retrieves a mock response for the given context.
    // Parameters can include scenario ID, turn number, provider ID, etc.
    // Returns the response text and any error encountered.
    GetResponse(ctx context.Context, params MockResponseParams) (string, error)

    // GetTurn retrieves a mock turn response that may include tool calls.
    // This extends GetResponse to support structured turn data with tool call simulation.
    GetTurn(ctx context.Context, params MockResponseParams) (*MockTurn, error)
}
```

<a name="MockToolCall"></a>
## type MockToolCall

MockToolCall represents a simulated tool call from the LLM.

```go
type MockToolCall struct {
    Name      string                 `yaml:"name"`      // Name of the tool to call
    Arguments map[string]interface{} `yaml:"arguments"` // Arguments to pass to the tool
}
```

<a name="MockToolError"></a>
## type MockToolError

MockToolError represents an error response for tool execution.

```go
type MockToolError struct {
    Type    string `yaml:"type"`    // Error type/category
    Message string `yaml:"message"` // Error message
}
```

<a name="MockToolProvider"></a>
## type MockToolProvider

MockToolProvider extends MockProvider to support tool/function calling. It implements the ToolSupport interface to enable tool call simulation while maintaining compatibility with the existing MockProvider API.

```go
type MockToolProvider struct {
    *MockProvider
}
```

<a name="NewMockToolProvider"></a>
### func NewMockToolProvider

```go
func NewMockToolProvider(id, model string, includeRawOutput bool, additionalConfig map[string]interface{}) *MockToolProvider
```

NewMockToolProvider creates a new mock provider with tool support. This uses default in\-memory responses for backward compatibility.

<a name="NewMockToolProviderWithRepository"></a>
### func NewMockToolProviderWithRepository

```go
func NewMockToolProviderWithRepository(id, model string, includeRawOutput bool, repo MockResponseRepository) *MockToolProvider
```

NewMockToolProviderWithRepository creates a mock provider with tool support using a custom response repository for advanced scenarios.

<a name="MockToolProvider.BuildTooling"></a>
### func \(\*MockToolProvider\) BuildTooling

```go
func (m *MockToolProvider) BuildTooling(descriptors []*providers.ToolDescriptor) (interface{}, error)
```

BuildTooling implements the ToolSupport interface. For mock providers, we just return the tools as\-is since we don't need to transform them into a provider\-specific format.

<a name="MockToolProvider.PredictWithTools"></a>
### func \(\*MockToolProvider\) PredictWithTools

```go
func (m *MockToolProvider) PredictWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictWithTools implements the ToolSupport interface. This method handles the initial predict request with tools available, potentially returning tool calls based on the mock configuration.

<a name="MockToolResponse"></a>
## type MockToolResponse

MockToolResponse represents a configured response for tool execution.

```go
type MockToolResponse struct {
    CallArgs map[string]interface{} `yaml:"call_args"`        // Match these arguments
    Result   interface{}            `yaml:"result,omitempty"` // Return this result
    Error    *MockToolError         `yaml:"error,omitempty"`  // Or return this error
}
```

<a name="MockTurn"></a>
## type MockTurn

MockTurn represents a structured mock response that may include tool calls and multimodal content. This extends simple text responses to support tool call simulation and multimodal content parts.

```go
type MockTurn struct {
    Type      string            `yaml:"type"`                 // "text", "tool_calls", or "multimodal"
    Content   string            `yaml:"content,omitempty"`    // Text content for the response
    Parts     []MockContentPart `yaml:"parts,omitempty"`      // Multimodal content parts (text, image, audio, video)
    ToolCalls []MockToolCall    `yaml:"tool_calls,omitempty"` // Tool calls to simulate
}
```

<a name="MockTurn.ToContentParts"></a>
### func \(\*MockTurn\) ToContentParts

```go
func (t *MockTurn) ToContentParts() []types.ContentPart
```

ToContentParts converts MockTurn to a slice of types.ContentPart. This handles both legacy text\-only responses and new multimodal responses.

<a name="MockVideoURL"></a>
## type MockVideoURL

MockVideoURL represents video content in a mock response.

```go
type MockVideoURL struct {
    URL string `yaml:"url"` // URL to the video file (can be mock://, http://, https://, data:, or file path)
}
```

<a name="ScenarioMockConfig"></a>
## type ScenarioMockConfig

ScenarioMockConfig defines mock responses for a specific scenario.

```go
type ScenarioMockConfig struct {
    // Default response for this scenario (overrides global default)
    DefaultResponse string `yaml:"defaultResponse,omitempty"`

    // Turn-specific responses keyed by turn number (1-indexed)
    // Supports both simple string responses (backward compatibility) and structured MockTurn responses
    Turns map[int]interface{} `yaml:"turns,omitempty"`

    // Tool execution responses for repository-backed tool mocking
    ToolResponses map[string][]MockToolResponse `yaml:"tool_responses,omitempty"`
}
```

# openai

```go
import "github.com/AltairaLabs/PromptKit/runtime/providers/openai"
```

## Index

- [type OpenAIProvider](<#OpenAIProvider>)
  - [func NewOpenAIProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool\) \*OpenAIProvider](<#NewOpenAIProvider>)
  - [func \(p \*OpenAIProvider\) CalculateCost\(tokensIn, tokensOut, cachedTokens int\) types.CostInfo](<#OpenAIProvider.CalculateCost>)
  - [func \(p \*OpenAIProvider\) GetMultimodalCapabilities\(\) providers.MultimodalCapabilities](<#OpenAIProvider.GetMultimodalCapabilities>)
  - [func \(p \*OpenAIProvider\) Predict\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#OpenAIProvider.Predict>)
  - [func \(p \*OpenAIProvider\) PredictMultimodal\(ctx context.Context, req providers.PredictionRequest\) \(providers.PredictionResponse, error\)](<#OpenAIProvider.PredictMultimodal>)
  - [func \(p \*OpenAIProvider\) PredictMultimodalStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#OpenAIProvider.PredictMultimodalStream>)
  - [func \(p \*OpenAIProvider\) PredictStream\(ctx context.Context, req providers.PredictionRequest\) \(\<\-chan providers.StreamChunk, error\)](<#OpenAIProvider.PredictStream>)
- [type OpenAIToolProvider](<#OpenAIToolProvider>)
  - [func NewOpenAIToolProvider\(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool, additionalConfig map\[string\]interface\{\}\) \*OpenAIToolProvider](<#NewOpenAIToolProvider>)
  - [func \(p \*OpenAIToolProvider\) BuildTooling\(descriptors \[\]\*providers.ToolDescriptor\) \(interface\{\}, error\)](<#OpenAIToolProvider.BuildTooling>)
  - [func \(p \*OpenAIToolProvider\) PredictMultimodalWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#OpenAIToolProvider.PredictMultimodalWithTools>)
  - [func \(p \*OpenAIToolProvider\) PredictWithTools\(ctx context.Context, req providers.PredictionRequest, tools interface\{\}, toolChoice string\) \(providers.PredictionResponse, \[\]types.MessageToolCall, error\)](<#OpenAIToolProvider.PredictWithTools>)


<a name="OpenAIProvider"></a>
## type OpenAIProvider

OpenAIProvider implements the Provider interface for OpenAI

```go
type OpenAIProvider struct {
    providers.BaseProvider
    // contains filtered or unexported fields
}
```

<a name="NewOpenAIProvider"></a>
### func NewOpenAIProvider

```go
func NewOpenAIProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool) *OpenAIProvider
```

NewOpenAIProvider creates a new OpenAI provider

<a name="OpenAIProvider.CalculateCost"></a>
### func \(\*OpenAIProvider\) CalculateCost

```go
func (p *OpenAIProvider) CalculateCost(tokensIn, tokensOut, cachedTokens int) types.CostInfo
```

CalculateCost calculates detailed cost breakdown including optional cached tokens

<a name="OpenAIProvider.GetMultimodalCapabilities"></a>
### func \(\*OpenAIProvider\) GetMultimodalCapabilities

```go
func (p *OpenAIProvider) GetMultimodalCapabilities() providers.MultimodalCapabilities
```

GetMultimodalCapabilities returns OpenAI's multimodal capabilities

<a name="OpenAIProvider.Predict"></a>
### func \(\*OpenAIProvider\) Predict

```go
func (p *OpenAIProvider) Predict(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

Predict sends a predict request to OpenAI

<a name="OpenAIProvider.PredictMultimodal"></a>
### func \(\*OpenAIProvider\) PredictMultimodal

```go
func (p *OpenAIProvider) PredictMultimodal(ctx context.Context, req providers.PredictionRequest) (providers.PredictionResponse, error)
```

PredictMultimodal performs a predict request with multimodal content

<a name="OpenAIProvider.PredictMultimodalStream"></a>
### func \(\*OpenAIProvider\) PredictMultimodalStream

```go
func (p *OpenAIProvider) PredictMultimodalStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictMultimodalStream performs a streaming predict request with multimodal content

<a name="OpenAIProvider.PredictStream"></a>
### func \(\*OpenAIProvider\) PredictStream

```go
func (p *OpenAIProvider) PredictStream(ctx context.Context, req providers.PredictionRequest) (<-chan providers.StreamChunk, error)
```

PredictStream streams a predict response from OpenAI

<a name="OpenAIToolProvider"></a>
## type OpenAIToolProvider

OpenAIToolProvider extends OpenAIProvider with tool support

```go
type OpenAIToolProvider struct {
    *OpenAIProvider
}
```

<a name="NewOpenAIToolProvider"></a>
### func NewOpenAIToolProvider

```go
func NewOpenAIToolProvider(id, model, baseURL string, defaults providers.ProviderDefaults, includeRawOutput bool, additionalConfig map[string]interface{}) *OpenAIToolProvider
```

NewOpenAIToolProvider creates a new OpenAI provider with tool support

<a name="OpenAIToolProvider.BuildTooling"></a>
### func \(\*OpenAIToolProvider\) BuildTooling

```go
func (p *OpenAIToolProvider) BuildTooling(descriptors []*providers.ToolDescriptor) (interface{}, error)
```

BuildTooling converts tool descriptors to OpenAI format

<a name="OpenAIToolProvider.PredictMultimodalWithTools"></a>
### func \(\*OpenAIToolProvider\) PredictMultimodalWithTools

```go
func (p *OpenAIToolProvider) PredictMultimodalWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictMultimodalWithTools implements providers.MultimodalToolSupport interface for OpenAIToolProvider This allows combining multimodal content \(images\) with tool calls in a single request

<a name="OpenAIToolProvider.PredictWithTools"></a>
### func \(\*OpenAIToolProvider\) PredictWithTools

```go
func (p *OpenAIToolProvider) PredictWithTools(ctx context.Context, req providers.PredictionRequest, tools interface{}, toolChoice string) (providers.PredictionResponse, []types.MessageToolCall, error)
```

PredictWithTools performs a prediction request with tool support

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
