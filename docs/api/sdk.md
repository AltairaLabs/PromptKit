<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# sdk

```go
import "github.com/AltairaLabs/PromptKit/sdk"
```

Package sdk provides a high\-level SDK for building LLM applications with PromptKit.

The SDK is built around PromptPacks \- compiled JSON files containing prompts, variables, tools, and validators. This PromptPack\-first approach ensures you get the full benefits of PromptKit's pipeline architecture including:

- Prompt assembly with variable interpolation
- Template rendering with fragments
- Tool orchestration and governance
- Response validation and guardrails
- State persistence across conversations

Two API Levels:

High\-Level API \(ConversationManager\):

- Simple interface for common use cases
- Automatic pipeline construction
- Load pack, create conversation, send messages

Low\-Level API \(PipelineBuilder\):

- Custom middleware injection
- Full pipeline control
- Advanced use cases \(custom context builders, observability\)

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func IsRetryableError\(err error\) bool](<#IsRetryableError>)
- [func IsTemporaryError\(err error\) bool](<#IsTemporaryError>)
- [func WrapPackError\(err error, packPath string\) error](<#WrapPackError>)
- [func WrapProviderError\(err error, provider string\) error](<#WrapProviderError>)
- [func WrapValidationError\(err error, validator string\) error](<#WrapValidationError>)
- [type Conversation](<#Conversation>)
  - [func \(c \*Conversation\) AddToolResult\(toolCallID, result string\) error](<#Conversation.AddToolResult>)
  - [func \(c \*Conversation\) Continue\(ctx context.Context\) \(\*Response, error\)](<#Conversation.Continue>)
  - [func \(c \*Conversation\) GetHistory\(\) \[\]types.Message](<#Conversation.GetHistory>)
  - [func \(c \*Conversation\) GetID\(\) string](<#Conversation.GetID>)
  - [func \(c \*Conversation\) GetPendingTools\(\) \[\]tools.PendingToolInfo](<#Conversation.GetPendingTools>)
  - [func \(c \*Conversation\) GetUserID\(\) string](<#Conversation.GetUserID>)
  - [func \(c \*Conversation\) HasPendingTools\(\) bool](<#Conversation.HasPendingTools>)
  - [func \(c \*Conversation\) Send\(ctx context.Context, userMessage string, opts ...SendOptions\) \(\*Response, error\)](<#Conversation.Send>)
  - [func \(c \*Conversation\) SendStream\(ctx context.Context, userMessage string, opts ...SendOptions\) \(\<\-chan StreamEvent, error\)](<#Conversation.SendStream>)
- [type ConversationConfig](<#ConversationConfig>)
- [type ConversationManager](<#ConversationManager>)
  - [func NewConversationManager\(opts ...ManagerOption\) \(\*ConversationManager, error\)](<#NewConversationManager>)
  - [func \(cm \*ConversationManager\) CreateConversation\(ctx context.Context, pack \*Pack, config ConversationConfig\) \(\*Conversation, error\)](<#ConversationManager.CreateConversation>)
  - [func \(cm \*ConversationManager\) GetConversation\(ctx context.Context, conversationID string, pack \*Pack\) \(\*Conversation, error\)](<#ConversationManager.GetConversation>)
  - [func \(cm \*ConversationManager\) LoadPack\(packPath string\) \(\*Pack, error\)](<#ConversationManager.LoadPack>)
- [type CustomContextMiddleware](<#CustomContextMiddleware>)
- [type ManagerConfig](<#ManagerConfig>)
- [type ManagerOption](<#ManagerOption>)
  - [func WithConfig\(config ManagerConfig\) ManagerOption](<#WithConfig>)
  - [func WithProvider\(provider providers.Provider\) ManagerOption](<#WithProvider>)
  - [func WithStateStore\(store statestore.Store\) ManagerOption](<#WithStateStore>)
  - [func WithToolRegistry\(registry \*tools.Registry\) ManagerOption](<#WithToolRegistry>)
- [type MiddlewareConfig](<#MiddlewareConfig>)
- [type ModelOverride](<#ModelOverride>)
- [type ObservabilityMiddleware](<#ObservabilityMiddleware>)
- [type Pack](<#Pack>)
  - [func \(p \*Pack\) CreateRegistry\(\) \(\*prompt.Registry, error\)](<#Pack.CreateRegistry>)
  - [func \(p \*Pack\) GetPrompt\(taskType string\) \(\*Prompt, error\)](<#Pack.GetPrompt>)
  - [func \(p \*Pack\) GetTools\(taskType string\) \(\[\]\*Tool, error\)](<#Pack.GetTools>)
  - [func \(p \*Pack\) ListPrompts\(\) \[\]string](<#Pack.ListPrompts>)
- [type PackManager](<#PackManager>)
  - [func NewPackManager\(\) \*PackManager](<#NewPackManager>)
  - [func \(pm \*PackManager\) GetPack\(packPath string\) \(\*Pack, bool\)](<#PackManager.GetPack>)
  - [func \(pm \*PackManager\) LoadPack\(packPath string\) \(\*Pack, error\)](<#PackManager.LoadPack>)
- [type Parameters](<#Parameters>)
- [type PipelineBuilder](<#PipelineBuilder>)
  - [func NewPipelineBuilder\(\) \*PipelineBuilder](<#NewPipelineBuilder>)
  - [func \(pb \*PipelineBuilder\) Build\(\) \*pipeline.Pipeline](<#PipelineBuilder.Build>)
  - [func \(pb \*PipelineBuilder\) WithConfig\(config \*pipeline.PipelineRuntimeConfig\) \*PipelineBuilder](<#PipelineBuilder.WithConfig>)
  - [func \(pb \*PipelineBuilder\) WithMiddleware\(m pipeline.Middleware\) \*PipelineBuilder](<#PipelineBuilder.WithMiddleware>)
  - [func \(pb \*PipelineBuilder\) WithProvider\(provider providers.Provider, toolRegistry \*tools.Registry, toolPolicy \*pipeline.ToolPolicy\) \*PipelineBuilder](<#PipelineBuilder.WithProvider>)
  - [func \(pb \*PipelineBuilder\) WithSimpleProvider\(provider providers.Provider\) \*PipelineBuilder](<#PipelineBuilder.WithSimpleProvider>)
  - [func \(pb \*PipelineBuilder\) WithTemplate\(\) \*PipelineBuilder](<#PipelineBuilder.WithTemplate>)
- [type PipelineConfig](<#PipelineConfig>)
- [type Prompt](<#Prompt>)
- [type Response](<#Response>)
- [type SendOptions](<#SendOptions>)
- [type StreamEvent](<#StreamEvent>)
- [type TemplateEngine](<#TemplateEngine>)
- [type TestedModel](<#TestedModel>)
- [type Tool](<#Tool>)
- [type ToolPolicy](<#ToolPolicy>)
- [type Validator](<#Validator>)
- [type Variable](<#Variable>)


## Constants

<a name="RoleAssistant"></a>Role constants for message types

```go
const (
    RoleAssistant = "assistant"
    RoleUser      = "user"
    RoleTool      = "tool"
)
```

## Variables

<a name="ErrPackNotFound"></a>Common error types for better error handling

```go
var (
    ErrPackNotFound     = errors.New("pack not found")
    ErrPromptNotFound   = errors.New("prompt not found")
    ErrInvalidConfig    = errors.New("invalid configuration")
    ErrProviderFailed   = errors.New("provider request failed")
    ErrValidationFailed = errors.New("validation failed")
)
```

<a name="IsRetryableError"></a>
## func IsRetryableError

```go
func IsRetryableError(err error) bool
```

IsRetryableError determines if an operation should be retried.

<a name="IsTemporaryError"></a>
## func IsTemporaryError

```go
func IsTemporaryError(err error) bool
```

IsTemporaryError checks if an error is temporary and should be retried.

<a name="WrapPackError"></a>
## func WrapPackError

```go
func WrapPackError(err error, packPath string) error
```

WrapPackError wraps an error with pack context information.

<a name="WrapProviderError"></a>
## func WrapProviderError

```go
func WrapProviderError(err error, provider string) error
```

WrapProviderError wraps an error with provider context information.

<a name="WrapValidationError"></a>
## func WrapValidationError

```go
func WrapValidationError(err error, validator string) error
```

WrapValidationError wraps an error with validation context information.

<a name="Conversation"></a>
## type Conversation

Conversation represents an active conversation

```go
type Conversation struct {
    // contains filtered or unexported fields
}
```

<a name="Conversation.AddToolResult"></a>
### func \(\*Conversation\) AddToolResult

```go
func (c *Conversation) AddToolResult(toolCallID, result string) error
```

AddToolResult adds a tool execution result to the conversation. This is used to provide the result of a tool call that was pending approval.

Parameters:

- toolCallID: The ID of the tool call \(from MessageToolCall.ID\)
- result: The JSON string result from the tool execution

<a name="Conversation.Continue"></a>
### func \(\*Conversation\) Continue

```go
func (c *Conversation) Continue(ctx context.Context) (*Response, error)
```

Continue resumes execution after tool results have been added. This should be called after one or more AddToolResult\(\) calls to continue the conversation with the LLM using the tool results.

Returns the assistant's response after processing the tool results.

<a name="Conversation.GetHistory"></a>
### func \(\*Conversation\) GetHistory

```go
func (c *Conversation) GetHistory() []types.Message
```

GetHistory returns the conversation message history

<a name="Conversation.GetID"></a>
### func \(\*Conversation\) GetID

```go
func (c *Conversation) GetID() string
```

GetID returns the conversation ID

<a name="Conversation.GetPendingTools"></a>
### func \(\*Conversation\) GetPendingTools

```go
func (c *Conversation) GetPendingTools() []tools.PendingToolInfo
```

GetPendingTools returns information about pending tool calls that require approval. This extracts PendingToolInfo from the conversation state metadata.

<a name="Conversation.GetUserID"></a>
### func \(\*Conversation\) GetUserID

```go
func (c *Conversation) GetUserID() string
```

GetUserID returns the user ID

<a name="Conversation.HasPendingTools"></a>
### func \(\*Conversation\) HasPendingTools

```go
func (c *Conversation) HasPendingTools() bool
```

HasPendingTools checks if the conversation has any pending tool calls awaiting approval

<a name="Conversation.Send"></a>
### func \(\*Conversation\) Send

```go
func (c *Conversation) Send(ctx context.Context, userMessage string, opts ...SendOptions) (*Response, error)
```

Send sends a user message and gets an assistant response

<a name="Conversation.SendStream"></a>
### func \(\*Conversation\) SendStream

```go
func (c *Conversation) SendStream(ctx context.Context, userMessage string, opts ...SendOptions) (<-chan StreamEvent, error)
```

SendStream sends a user message and returns a streaming response

<a name="ConversationConfig"></a>
## type ConversationConfig

ConversationConfig configures a new conversation

```go
type ConversationConfig struct {
    // Required fields
    UserID     string // User who owns this conversation
    PromptName string // Task type from the pack (e.g., "support", "sales")

    // Optional fields
    ConversationID string                 // If empty, auto-generated
    Variables      map[string]interface{} // Template variables
    SystemPrompt   string                 // Override system prompt
    Metadata       map[string]interface{} // Custom metadata

    // Context policy (token budget management)
    ContextPolicy *middleware.ContextBuilderPolicy
}
```

<a name="ConversationManager"></a>
## type ConversationManager

ConversationManager provides high\-level API for managing LLM conversations. It automatically constructs the pipeline with appropriate middleware based on the PromptPack configuration.

Key Features:

- Load PromptPacks and create conversations for specific prompts
- Automatic pipeline construction with middleware stack
- State persistence via StateStore
- Support for streaming and tool execution
- Multi\-turn conversation management

```go
type ConversationManager struct {
    // contains filtered or unexported fields
}
```

<a name="NewConversationManager"></a>
### func NewConversationManager

```go
func NewConversationManager(opts ...ManagerOption) (*ConversationManager, error)
```

NewConversationManager creates a new ConversationManager

<a name="ConversationManager.CreateConversation"></a>
### func \(\*ConversationManager\) CreateConversation

```go
func (cm *ConversationManager) CreateConversation(ctx context.Context, pack *Pack, config ConversationConfig) (*Conversation, error)
```

CreateConversation creates a new conversation for a specific prompt in the pack

<a name="ConversationManager.GetConversation"></a>
### func \(\*ConversationManager\) GetConversation

```go
func (cm *ConversationManager) GetConversation(ctx context.Context, conversationID string, pack *Pack) (*Conversation, error)
```

GetConversation loads an existing conversation from state store

<a name="ConversationManager.LoadPack"></a>
### func \(\*ConversationManager\) LoadPack

```go
func (cm *ConversationManager) LoadPack(packPath string) (*Pack, error)
```

LoadPack loads a PromptPack from a file

<a name="CustomContextMiddleware"></a>
## type CustomContextMiddleware

CustomContextMiddleware is an example of custom middleware for context building. Users can implement similar middleware for their specific needs.

Example:

```
type MyContextMiddleware struct {
    ragClient *RAGClient
}

func (m *MyContextMiddleware) Process(execCtx *pipeline.ExecutionContext, next func() error) error {
    // Extract query from last user message
    query := execCtx.Messages[len(execCtx.Messages)-1].Content

    // Fetch relevant documents
    docs, _ := m.ragClient.Search(query, 5)

    // Add to variables for template substitution
    execCtx.Variables["rag_context"] = formatDocs(docs)

    return next()
}
```

```go
type CustomContextMiddleware interface {
    pipeline.Middleware
}
```

<a name="ManagerConfig"></a>
## type ManagerConfig

ManagerConfig configures the ConversationManager

```go
type ManagerConfig struct {
    // MaxConcurrentExecutions limits parallel pipeline executions
    MaxConcurrentExecutions int

    // DefaultTimeout for LLM requests
    DefaultTimeout time.Duration

    // EnableMetrics enables built-in metrics collection
    EnableMetrics bool
}
```

<a name="ManagerOption"></a>
## type ManagerOption

ManagerOption configures ConversationManager

```go
type ManagerOption func(*ConversationManager) error
```

<a name="WithConfig"></a>
### func WithConfig

```go
func WithConfig(config ManagerConfig) ManagerOption
```

WithConfig sets the manager configuration

<a name="WithProvider"></a>
### func WithProvider

```go
func WithProvider(provider providers.Provider) ManagerOption
```

WithProvider sets the LLM provider

<a name="WithStateStore"></a>
### func WithStateStore

```go
func WithStateStore(store statestore.Store) ManagerOption
```

WithStateStore sets the state persistence backend

<a name="WithToolRegistry"></a>
### func WithToolRegistry

```go
func WithToolRegistry(registry *tools.Registry) ManagerOption
```

WithToolRegistry sets the tool registry for tool execution

<a name="MiddlewareConfig"></a>
## type MiddlewareConfig

MiddlewareConfig defines a single middleware configuration

```go
type MiddlewareConfig struct {
    Type   string                 `json:"type"`
    Config map[string]interface{} `json:"config,omitempty"`
}
```

<a name="ModelOverride"></a>
## type ModelOverride

ModelOverride defines model\-specific template overrides

```go
type ModelOverride struct {
    SystemTemplateSuffix string `json:"system_template_suffix,omitempty"`
}
```

<a name="ObservabilityMiddleware"></a>
## type ObservabilityMiddleware

ObservabilityMiddleware is an example of observability middleware. Users can implement similar middleware for LangFuse, DataDog, etc.

Example:

```
type LangFuseMiddleware struct {
    client *langfuse.Client
}

func (m *LangFuseMiddleware) Process(execCtx *pipeline.ExecutionContext, next func() error) error {
    traceID := m.client.StartTrace(...)
    spanID := m.client.StartSpan(traceID, ...)

    start := time.Now()
    err := next()
    duration := time.Since(start)

    m.client.EndSpan(spanID, langfuse.SpanResult{
        Duration: duration,
        TokensInput: execCtx.CostInfo.InputTokens,
        TokensOutput: execCtx.CostInfo.OutputTokens,
        Error: err,
    })

    return err
}
```

```go
type ObservabilityMiddleware interface {
    pipeline.Middleware
}
```

<a name="Pack"></a>
## type Pack

Pack represents a loaded PromptPack containing multiple prompts for related task types. A pack is a portable, JSON\-based bundle created by the packc compiler.

DESIGN DECISION: Why separate Pack types in sdk vs runtime?

This SDK Pack is optimized for LOADING & EXECUTION:

- Loaded from .pack.json files for application use
- Includes Tools map for runtime tool access
- Includes filePath to track source file location
- Thread\-safe with sync.RWMutex for concurrent access
- Returns validation errors for application error handling
- Rich types \(\*Variable, \*Validator, \*Tool\) with full functionality
- Has CreateRegistry\(\) to convert to runtime.Registry for pipeline execution
- Has convertToRuntimeConfig\(\) to bridge SDK â†” runtime formats

The runtime.prompt.Pack is optimized for COMPILATION:

- Created by PackCompiler during prompt compilation
- Includes Compilation and Metadata fields for provenance tracking
- Returns validation warnings \(\[\]string\) for compiler feedback
- No thread\-safety \(single\-threaded compilation process\)
- Simple types for clean JSON serialization
- No conversion methods \(produces, doesn't consume\)

Both types serialize to/from the SAME JSON format \(.pack.json files\), ensuring full interoperability between compilation and execution phases. The duplication is intentional and provides:

1. Clear separation of concerns \(compile vs execute\)
2. No circular dependencies \(sdk imports runtime, not vice versa\)
3. Independent evolution of each module
4. Type\-specific optimizations \(thread\-safety, validation behavior\)

Design: A pack contains MULTIPLE prompts \(task\_types\) that share common configuration like template engine and fragments, but each prompt has its own template, variables, tools, and validators.

See runtime/prompt/pack.go for the corresponding runtime\-side documentation.

```go
type Pack struct {
    // Pack identity
    ID          string `json:"id"`
    Name        string `json:"name"`
    Version     string `json:"version"`
    Description string `json:"description"`

    // Shared configuration across all prompts
    TemplateEngine TemplateEngine `json:"template_engine"`

    // Map of task_type -> prompt configuration
    Prompts map[string]*Prompt `json:"prompts"`

    // Shared fragments used by all prompts
    Fragments map[string]string `json:"fragments,omitempty"`

    // Tool definitions (referenced by prompts)
    Tools map[string]*Tool `json:"tools,omitempty"`
    // contains filtered or unexported fields
}
```

<a name="Pack.CreateRegistry"></a>
### func \(\*Pack\) CreateRegistry

```go
func (p *Pack) CreateRegistry() (*prompt.Registry, error)
```

CreateRegistry creates a runtime prompt.Registry from this pack. The registry allows the runtime pipeline to access prompts using the standard prompt assembly middleware. Each prompt in the pack is registered by its task\_type.

This bridges the SDK's .pack.json format with the runtime's prompt.Registry format.

<a name="Pack.GetPrompt"></a>
### func \(\*Pack\) GetPrompt

```go
func (p *Pack) GetPrompt(taskType string) (*Prompt, error)
```

GetPrompt retrieves a specific prompt from a pack

<a name="Pack.GetTools"></a>
### func \(\*Pack\) GetTools

```go
func (p *Pack) GetTools(taskType string) ([]*Tool, error)
```

GetTools retrieves tools used by a specific prompt

<a name="Pack.ListPrompts"></a>
### func \(\*Pack\) ListPrompts

```go
func (p *Pack) ListPrompts() []string
```

ListPrompts returns all available task types in the pack

<a name="PackManager"></a>
## type PackManager

PackManager manages loading and caching of PromptPacks

```go
type PackManager struct {
    // contains filtered or unexported fields
}
```

<a name="NewPackManager"></a>
### func NewPackManager

```go
func NewPackManager() *PackManager
```

NewPackManager creates a new PackManager

<a name="PackManager.GetPack"></a>
### func \(\*PackManager\) GetPack

```go
func (pm *PackManager) GetPack(packPath string) (*Pack, bool)
```

GetPack retrieves a cached pack by path

<a name="PackManager.LoadPack"></a>
### func \(\*PackManager\) LoadPack

```go
func (pm *PackManager) LoadPack(packPath string) (*Pack, error)
```

LoadPack loads a PromptPack from a .pack.json file

<a name="Parameters"></a>
## type Parameters

Parameters defines LLM generation parameters

```go
type Parameters struct {
    Temperature float32 `json:"temperature,omitempty"`
    MaxTokens   int     `json:"max_tokens,omitempty"`
    TopP        float32 `json:"top_p,omitempty"`
    TopK        *int    `json:"top_k,omitempty"`
}
```

<a name="PipelineBuilder"></a>
## type PipelineBuilder

PipelineBuilder provides low\-level API for constructing custom pipelines with middleware.

Use this when you need:

- Custom middleware injection
- Custom context builders
- Observability integration \(LangFuse, DataDog, etc.\)
- Advanced pipeline control

For simple use cases, use ConversationManager instead.

Example:

```
builder := sdk.NewPipelineBuilder().
    WithProvider(provider).
    WithMiddleware(customMiddleware).
    WithMiddleware(observabilityMiddleware)

pipe := builder.Build()
result, err := pipe.Execute(ctx, "user", "Hello!")
```

```go
type PipelineBuilder struct {
    // contains filtered or unexported fields
}
```

<a name="NewPipelineBuilder"></a>
### func NewPipelineBuilder

```go
func NewPipelineBuilder() *PipelineBuilder
```

NewPipelineBuilder creates a new pipeline builder

<a name="PipelineBuilder.Build"></a>
### func \(\*PipelineBuilder\) Build

```go
func (pb *PipelineBuilder) Build() *pipeline.Pipeline
```

Build constructs the pipeline

<a name="PipelineBuilder.WithConfig"></a>
### func \(\*PipelineBuilder\) WithConfig

```go
func (pb *PipelineBuilder) WithConfig(config *pipeline.PipelineRuntimeConfig) *PipelineBuilder
```

WithConfig sets the pipeline runtime configuration

<a name="PipelineBuilder.WithMiddleware"></a>
### func \(\*PipelineBuilder\) WithMiddleware

```go
func (pb *PipelineBuilder) WithMiddleware(m pipeline.Middleware) *PipelineBuilder
```

WithMiddleware adds middleware to the pipeline. Middleware executes in the order added.

<a name="PipelineBuilder.WithProvider"></a>
### func \(\*PipelineBuilder\) WithProvider

```go
func (pb *PipelineBuilder) WithProvider(provider providers.Provider, toolRegistry *tools.Registry, toolPolicy *pipeline.ToolPolicy) *PipelineBuilder
```

WithProvider adds a provider middleware to the pipeline. This is a convenience method that wraps the runtime ProviderMiddleware.

<a name="PipelineBuilder.WithSimpleProvider"></a>
### func \(\*PipelineBuilder\) WithSimpleProvider

```go
func (pb *PipelineBuilder) WithSimpleProvider(provider providers.Provider) *PipelineBuilder
```

WithSimpleProvider adds a provider middleware without tools or custom config. This is the simplest way to add LLM execution to a pipeline.

<a name="PipelineBuilder.WithTemplate"></a>
### func \(\*PipelineBuilder\) WithTemplate

```go
func (pb *PipelineBuilder) WithTemplate() *PipelineBuilder
```

WithTemplate adds template substitution middleware. This replaces \{\{variable\}\} placeholders in the system prompt.

<a name="PipelineConfig"></a>
## type PipelineConfig

PipelineConfig defines pipeline middleware configuration

```go
type PipelineConfig struct {
    Stages     []string            `json:"stages"`
    Middleware []*MiddlewareConfig `json:"middleware"`
}
```

<a name="Prompt"></a>
## type Prompt

Prompt represents a single prompt configuration within a pack

```go
type Prompt struct {
    ID          string `json:"id"`
    Name        string `json:"name"`
    Description string `json:"description"`
    Version     string `json:"version"`

    // Template
    SystemTemplate string `json:"system_template"`

    // Variables for this prompt
    Variables []*Variable `json:"variables"`

    // Tool references (names that map to pack.Tools)
    ToolNames []string `json:"tools,omitempty"`

    // Tool policy
    ToolPolicy *ToolPolicy `json:"tool_policy,omitempty"`

    // Multimodal media configuration
    MediaConfig *prompt.MediaConfig `json:"media,omitempty"`

    // Pipeline configuration
    Pipeline *PipelineConfig `json:"pipeline,omitempty"`

    // LLM parameters
    Parameters *Parameters `json:"parameters,omitempty"`

    // Validators
    Validators []*Validator `json:"validators,omitempty"`

    // Model testing results
    TestedModels []*TestedModel `json:"tested_models,omitempty"`

    // Model-specific overrides
    ModelOverrides map[string]*ModelOverride `json:"model_overrides,omitempty"`
}
```

<a name="Response"></a>
## type Response

Response represents a conversation turn response

```go
type Response struct {
    Content      string
    ToolCalls    []types.MessageToolCall
    TokensUsed   int
    Cost         float64
    LatencyMs    int64
    Validations  []types.ValidationResult
    Truncated    bool                    // True if context was truncated
    PendingTools []tools.PendingToolInfo // Tools awaiting external approval/input
}
```

<a name="SendOptions"></a>
## type SendOptions

SendOptions configures message sending behavior

```go
type SendOptions struct {
    Stream       bool                   // Enable streaming
    MaxToolCalls int                    // Max tool calls per turn (0 = use prompt default)
    Metadata     map[string]interface{} // Turn-specific metadata
}
```

<a name="StreamEvent"></a>
## type StreamEvent

StreamEvent represents a streaming response event

```go
type StreamEvent struct {
    Type     string // "content", "tool_call", "done", "error"
    Content  string
    ToolCall *types.MessageToolCall
    Error    error
    Final    *Response // Set when Type="done"
}
```

<a name="TemplateEngine"></a>
## type TemplateEngine

TemplateEngine describes the template engine configuration shared across prompts

```go
type TemplateEngine struct {
    Version  string   `json:"version"`
    Syntax   string   `json:"syntax"`
    Features []string `json:"features"`
}
```

<a name="TestedModel"></a>
## type TestedModel

TestedModel contains testing results for a specific model

```go
type TestedModel struct {
    Provider     string  `json:"provider"`
    Model        string  `json:"model"`
    Date         string  `json:"date"`
    SuccessRate  float64 `json:"success_rate"`
    AvgTokens    int     `json:"avg_tokens"`
    AvgCost      float64 `json:"avg_cost"`
    AvgLatencyMs int     `json:"avg_latency_ms"`
}
```

<a name="Tool"></a>
## type Tool

Tool defines a tool that can be called by the LLM

```go
type Tool struct {
    Name        string                 `json:"name"`
    Description string                 `json:"description"`
    Parameters  map[string]interface{} `json:"parameters"`
}
```

<a name="ToolPolicy"></a>
## type ToolPolicy

ToolPolicy defines tool usage constraints

```go
type ToolPolicy struct {
    ToolChoice          string   `json:"tool_choice"` // "auto", "required", "none"
    MaxRounds           int      `json:"max_rounds,omitempty"`
    MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"`
    Blocklist           []string `json:"blocklist,omitempty"`
}
```

<a name="Validator"></a>
## type Validator

Validator defines a validation rule

```go
type Validator struct {
    Type            string                 `json:"type"`
    Enabled         bool                   `json:"enabled"`
    FailOnViolation bool                   `json:"fail_on_violation"`
    Params          map[string]interface{} `json:"params"`
}
```

<a name="Variable"></a>
## type Variable

Variable defines a template variable with validation rules

```go
type Variable struct {
    Name        string                 `json:"name"`
    Type        string                 `json:"type"` // "string", "number", "boolean", "object", "array"
    Required    bool                   `json:"required"`
    Default     interface{}            `json:"default,omitempty"`
    Description string                 `json:"description"`
    Example     interface{}            `json:"example,omitempty"`
    Validation  map[string]interface{} `json:"validation,omitempty"`
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
